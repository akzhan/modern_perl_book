<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="style.css" type="text/css"></head><body><h1>Что упущено</h1>

<p>Perl 5 не совершенен, но податлив &mdash; частично из-за того, что нет единой конфигурации, идеальной для каждого программиста и каждой цели. Некоторые полезные поведения доступны как базовые библиотеки. Ещё больше их доступно в CPAN. Ваша эффективность как Perl-программиста зависит от вашего использования этих улучшений.</p>

<h2>Недостающие умолчания</h2>

<p><a name="missing_defaults"></p>

<p>Дизайн-процесс Perl 5 пытается предугадать новые направляения для языка, но в 1994 году невозможно было предсказать будущее таким, каким оно будет в 2011 году. Perl 5 расширил язык, но остался совместим с Perl 1 из 1987 года.</p>

<p>Лучший код на Perl 5 в 2011 году очень сильно отличается от лучшего кода на Perl 5 в 1994 году, или лучшего кода на Perl 1 в 1987 году.</p>

<p></p>

<p>Хотя Perl 5 содержит огромную базовую библиотеку, она не всеобъемлюща. Многие из лучших модулей Perl 5 существуют в CPAN (<a href="chapter_02.html#cpan">CPAN</a>), а не в ядре. Метадистрибутив <code>Task::Kensho</code> включает несколько других дистрибутивов, которые представляют собой лучшее из того, что может предложить CPAN. Если вам нужно решить задачу, загляните сначала туда.</p>

<p>С учётом вышесказанного, несколько базовых прагм и модулей незаменимы для серьёзных Perl-программистов.</p>

<h3>Прагма strict</h3>

<p> </p>

<p>Прагма <code>strict</code> (<a href="chapter_08.html#pragmas">Прагмы</a>) позволяет вам запретить (или вновь разрешить) разные мощные языковые конструкции, создающие потенциальную возможность непреднамеренных ошибок.</p>

<p><code>strict</code> запрещает символические ссылки, требует объявления переменных (<a href="chapter_05.html#lexical_scope">Лексическая область видимости</a>) и запрещает использование необъявленных голых слов (<a href="chapter_11.html#barewords">Голые слова</a>). Тогда как редкое использование символических ссылок необходимо для манипулирования таблицами символов (<a href="chapter_09.html#import">Использование и импортирование</a>), использование переменной как имени переменной создаёт вероятность неочевидных ошибок действия на расстоянии &mdash; или, хуже, возможность для плоховалидированного пользовательского ввода манипулировать внутренними данными со злонамеренными целями.</p>

<p>Требование объявлений переменных помогает определить опечатки в именах переменных и поощряет использование соответствующих областей видимости лексических переменных. Намного проще видеть намеренную область видимости лексической переменной, если все переменные имеют объявления <code>my</code> или <code>our</code> в соответствующей области видимости.</p>

<p><code>strict</code> имеет лексическое действие, основанное на области видимости времени компиляции её использования (<a href="chapter_09.html#import">Использование и импортирование</a>) и отключения (с помощью <code>no</code>). Смотрите <code>perldoc strict</code> для больших подробностей.</p>

<h3>Прагма warnings</h3>

<p>Прагма <code>warnings</code> (<a href="chapter_09.html#handling_warnings">Обработка предупреждений</a>) контролирует сообщения о разных классах предупреждений в Perl 5, таких как попытка преобразовать в строку значение <code>undef</code> или использование со значениями неверного типа оператора. Она также предупреждает об использовании нерекомендуемых возможностей.</p>

<p>Наиболее полезные предупреждения объясняют, что Perl имеет сложности с пониманием того, что вы имели ввиду, и вынужден угадывать соответствующую интерпретацию. Даже несмотря на то, что Perl зачастую угадывает корректно, устранение неоднозначности с вашей стороны приведёт к уверенности, что программа работает корректно.</p>

<p>Прагма <code>warnings</code> имеет лексическое действие в области видимости времени компиляции её использования или отключения (с помощью <code>no</code>). Смотрите <code>perldoc perllexwarn</code> и <code>perldoc warnings</code> для больших подробностей.</p>

<p>Объедините <code>use warnings</code> с <code>use diagnostics</code>, чтобы получить расширенные диагностические сообщения для каждого предупреждения, присутствующего в вашей программе. Эта расширенная диагностика поступает из <code>perldoc perldiag</code>. Это поведение полезно при изучении Perl. Отключите его перед внедрением вашей программы, потому что оно производит многословный вывод, который может заполнить ваши логи и показать слишком много информации пользователям.</p>

<h3><code>IO::File</code> и <code>IO::Handle</code></h3>

<p> </p>

<p>До Perl 5.14 лексические дескрипторы файлов были объектами класса <code>IO::Handle</code>, но вам требовалось явно загрузить <code>IO::Handle</code>, прежде чем вы могли вызывать на них методы. С Perl 5.14 лексические дескрипторы файлов &mdash; экземпляры <code>IO::File</code>, и Perl сам загружает <code>IO::File</code> за вас.</p>

<p>Добавьте <code>IO::Handle</code> в код, запускающийся на Perl 5.12 или раньше, если вы вызываете методы на лексических дескрипторах файлов.</p>

<h3>Прагма autodie</h3>

<p><a name="autodie">  </p>

<p>Perl 5 оставляет обработку ошибок (или игнорирование ошибок) вам. Если вы не достаточно внимательны, чтобы проверять, например, возвращаемое значение каждого вызова <code>open()</code>, вы можете попытаться прочитать из закрытого дескриптора файла &mdash; или, хуже, потерять данные при попытке записать в него. Прагма <code>autodie</code> изменяет поведение по умолчанию. Если вы напишете:</p>

<pre><code>    use autodie;

    open my $fh, &#39;&gt;&#39;, $file;</code></pre>

<p>&hellip;неудачный вызов <code>open()</code> выбросит исключение. Учитывая, что наиболее подходящий подход для неудавшегося системного вызова &mdash; выбросить исключение, эта прагма может удалить много шаблонного кода и подарить вам душевное спокойствие от знания того, что вы не забыли проверить возвращаемое значение.</p>

<p>Эта прагма появилась в ядре Perl 5 с Perl 5.10.1. Смотрите <code>perldoc autodie</code> для большей информации.</p>

</body></html>