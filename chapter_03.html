<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="style.css" type="text/css"></head><body><h1>Язык Perl</h1>

<p>Как и разговорный язык, Perl в целом &mdash; это комбинация нескольких меньших, но взаимосвязанных частей. В отличие от разговорного языка, где оттенок и интонация голоса и интуиция позволяют людям общаться, несмотря на некоторое недопонимание и неясные представления, компьютеры и программный код требуют точности. Вы можете писать эффективный код на Perl, не зная каждой детали каждой возможности языка, но для написания хорошего кода вы должны понимать, как они работают вместе.</p>

<h2>Имена</h2>

<p><a name="names"></p>

<p> </p>

<p><em>Имена</em> (или <em>идентификаторы</em>) в программах на Perl повсюду: переменные, функции, пакеты, классы и даже дескрипторы файлов. Все эти имена начинаются с буквы или знака подчёркивания и могут включать любую комбинацию букв, цифр и знаков подчёркивания. Если задействована прагма <code>utf8</code> (<a href="chapter_03.html#unicode">Юникод и строки</a>), вы можете использовать в идентификаторах любые словарные символы UTF-8. Всё это допустимые в Perl идентификаторы:</p>

<pre><code>    my $name;
    my @_private_names;
    my %Names_to_Addresses;

    sub anAwkwardName3;

    # &#x441; &#x432;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x43D;&#x44B;&#x43C; use utf8;
    package Ingy::D&ouml;t::Net;</code></pre>

<p>Такие идентификаторы недопустимы в Perl:</p>

<pre><code>    my $invalid name;
    my @3;
    my %~flags;

    package a-lisp-style-name;</code></pre>

<p></p>

<p><em>Имена существуют в первую очередь для пользы программиста</em>. Эти правила применяются только к именам литералов, которые появляются в вашем исходном коде &laquo;как есть&raquo;, таким как <code>sub fetch_pie</code> или <code>my $waffleiron</code>. Только парсер Perl принуждает следовать правилам об именах идентификаторов.</p>

<p>Динамическая натура Perl позволяет вам ссылаться на сущности с помощью имён, генерируемых во время исполнения или указанных как входные данные программы. Этот <em>символьный поиск</em> обеспечивает гибкость ценой некоторого ущерба безопасности. В частности, непрямой вызов функций или методов или поиск символов в пространстве имён позволяет вам обойти парсер Perl.</p>

<p>Такое поведение может привести к запутанному коду. Как эффективно рекомендует Марк Джейсон Доминус (Mark Jason Dominus) (footnote: http://perl.plover.com/varvarname.html), лучше используйте хеши или вложенные структуры данных (<a href="chapter_03.html#nested_data_structures">Вложенные структуры данных</a>).</p>

<h3>Имена переменных и сигилы</h3>

<p>        </p>

<p><em>Имена переменных</em> всегда имеют предшествующий <em>сигил</em> (или символ), который обозначает тип значения переменной. <em>Скалярные переменные</em> (<a href="chapter_03.html#scalars">Скаляры</a>) используют знак доллара (<code>$</code>). <em>Переменные-массивы</em> (<a href="chapter_03.html#arrays">Массивы</a>) используют знак &laquo;at&raquo; (&laquo;собака&raquo;), (<code>@</code>). <em>Переменные-хеши</em> (<a href="chapter_03.html#hashes">Хеши</a>) используют знак процента (<code>%</code>):</p>

<pre><code>    my $scalar;
    my @array;
    my %hash;</code></pre>

<p>Эти сигилы обеспечивают визуальное разделение пространств имён для имён переменных. Возможно &mdash; хотя это и может привести к путанице &mdash; объявить несколько переменных с одним и тем же именем, но разными типами:</p>

<pre><code>    my ($bad_name, @bad_name, %bad_name);</code></pre>

<p>Хотя Perl и не будет сбит с толку, люди, читающие этот код, будут.</p>

<p></p>

<p>Сигилы Perl 5 &mdash; <em>варьирующиеся сигилы</em>. Как контекст определяет, сколько элементов вы ожидаете от операции, или какого типа данные вы ожидаете получить, так и сигил определяет, как вы манипулируете данными переменной. Например, для доступа к единственному элементу массива или хеша вы должны использовать сигил скаляра (<code>$</code>):</p>

<pre><code>    my $hash_element  = $hash{ $key };
    my $array_element = $array[ $index ]

    $hash{ $key }     = &#39;value&#39;;
    $array[ $index ]  = &#39;item&#39;;</code></pre>

<p> </p>

<p>Параллель с контекстом количества важна. Использование скалярного элемента структуры как <em>lvalue</em>, левого значения (цель присвоения, находящаяся слева от знака <code>=</code>), налагает скалярный контекст (<a href="chapter_01.html#context_philosophy">Контекст</a>) на <em>rvalue</em>, правое значение (присваемое значение, находящееся справа от знака <code>=</code>).</p>

<p></p>

<p>Аналогично, доступ к нескольким элементам хеша или массива &mdash; операция, известная как <em>получение среза</em> &mdash; использует символ <code>@</code> и налагает списочный контекст (footnote: &hellip;даже если сам список содержит ноль или один элемент):</p>

<pre><code>    my @hash_elements  = @hash{ @keys };
    my @array_elements = @array[ @indexes ];

    my %hash;
    @hash{ @keys }     = @values;</code></pre>

<p>Наиболее надёжный способ определить тип переменной &mdash; скаляр, массив или хеш &mdash; обратить внимание на производимые с ней операции. Скаляры поддерживают все базовые операции, такие как строковые, числовые и булевы манипуляции. Массивы поддерживают доступ по индексу посредством квадратных скобок. Хеши поддерживают доступ по ключу посредством фигурных скобок.</p>

<h3>Пространства имён</h3>

<p> </p>

<p>Perl предоставляет механизм группировки сходных функций и переменных в их собственные уникальные именованные пространства &mdash; <em>пространства имён</em> (<a href="chapter_03.html#packages">Пакеты</a>). Пространство имён &mdash; это именованная коллекция символов. Perl позволяет использование многоуровневых пространств имён, с именами, соединёнными двойным двоеточием (<code>::</code>), где <code>DessertShop::IceCream</code> ссылается на логическую коллекцию родственных переменных и функций, таких как <code>scoop()</code> и <code>pour_hot_fudge()</code>.</p>

<p>Внутри пространства имён вы можете использовать короткие имена его членов. Снаружи пространства имён ссылайтесь на его член, используя его <em>полностью определённое имя</em>. Таким образом, <code>add_sprinkles()</code> внутри <code>DessertShop::IceCream</code> ссылается на ту же самую функцию, что и <code>DessertShop::IceCream::add_sprinkles()</code> снаружи пространства имён.</p>

<p>Хотя к именам пакетов применимы стандартные правила именования, по соглашению имена определённых пользователями пакетов начинаются с заглавных букв. Ядро Perl резервирует строчные имена пакетов для прагм ядра (<a href="chapter_08.html#pragmas">Прагмы</a>), таких как <code>strict</code> и <code>warnings</code>. Эта политика закреплена в первую очередь рекомендациями сообщества.</p>

<p>Все пространства имён в Perl 5 глобально видимы. Когда Perl ищет символ в <code>DessertShop::IceCream::Freezer</code>, он ищет в символьной таблице <code>main::</code> символ, представляющий пространство имён <code>DessertShop::</code>, затем в нём &mdash; пространство имён <code>IceCream::</code>, и так далее. <code>Freezer::</code> видим снаружи пространства имён <code>IceCream::</code>. Вложенность одного в другое &mdash; всего лишь механизм хранения, и ничего не говорит об отношениях между родительскими и дочерними пакетами, или пакетами, находящимися на одном уровне. Только программист может сделать <em>логические</em> отношения между сущностями очевидными &mdash; выбрав хорошие имена и правильно их организовав.</p>

<h2>Переменные</h2>

<p><a name="variables"> </p>

<p><em>Переменная</em> в Perl &mdash; это место хранения значения (<a href="chapter_03.html#values">Значения</a>). Хотя простая программа может манипулировать значениями напрямую, большинство программ работают с переменными для упрощения логики кода. Переменные представляют значения; проще объяснить теорему Пифагора в терминах переменных <code>a</code>, <code>b</code> и <code>c</code>, чем демонстрируя её принцип длинным списком корректных значений. Эта концепция может выглядеть очевидной, но эффективное программирование требует от вас справляться с искусством балансирования между общим и повторно используемым с одной стороны и конкретным &mdash; с другой.</p>

<h3>Области видимости переменных</h3>

<p><a name="variable_scopes"></p>

<p>  </p>

<p>Переменные видны частям вашей программы в зависимости от их области видимости (<a href="chapter_05.html#scope">Область видимости</a>). Большая часть переменных, с которыми вы встретитесь, имеет лексическую область видимости (<a href="chapter_05.html#lexical_scope">Лексическая область видимости</a>). Сами <em>файлы</em> задают свои собственные лексические области видимости, так что объявление <code>package</code> само по себе новую область видимости не создаёт:</p>

<pre><code>    package Store::Toy;

    my $discount = 0.10;

    package Store::Music;

    # &#x43F;&#x435;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x430;&#x44F; $discount &#x432;&#x441;&#x451; &#x435;&#x449;&#x451; &#x432;&#x438;&#x434;&#x438;&#x43C;&#x430;
    say &quot;Our current discount is $discount!&quot;;</code></pre>

<p></p>

<p>Начиная с Perl 5.14, вы можете задать блок для объявления <code>package</code>. Такой синтаксис <em>создаёт</em> лексическую область видимости:</p>

<pre><code>    package Store::Toy
    {
        my $discount = 0.10;
    }

    package Store::Music
    {
        # &#x43F;&#x435;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x430;&#x44F; $discount &#x43D;&#x435; &#x434;&#x43E;&#x441;&#x442;&#x443;&#x43F;&#x43D;&#x430;
    }

    package Store::BoardGame;

    # &#x43F;&#x435;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x430;&#x44F; $discount &#x432;&#x441;&#x451; &#x435;&#x449;&#x451; &#x43D;&#x435; &#x434;&#x43E;&#x441;&#x442;&#x443;&#x43F;&#x43D;&#x430;</code></pre>

<h3>Сигилы переменных</h3>

<p><a name="sigils"></p>

<p> </p>

<p>Сигил переменной в объявлении определяет тип переменной: скаляр, массив или хеш. Сигил, используемый при доступе к переменной, варьируется в зависимости от того, что вы делаете с переменной. Например, вы объявляете массив как <code>@values</code>. <code>$values[0]</code> &mdash; доступ к первому элементу массива &mdash; единичному значению. <code>@values[ @indices ]</code> &mdash; доступ к списку значений из массива.</p>

<h3>Анонимные переменные</h3>

<p> </p>

<p>Переменные в Perl не <em>требуют</em> имён. Имена существуют чтобы помочь вам, программисту, следить за <code>$apple</code>, <code>@barrels</code> или <code>%cheap_meals</code>. Переменные, созданные в вашем программном коде <em>без</em> литеральных имён, называются <em>анонимными</em> переменными. Единственный способ обратиться к анонимной переменной &mdash; по ссылке (<a href="chapter_03.html#references">Ссылки</a>).</p>

<h3>Переменные, типы и приведение типов</h3>

<p>  </p>

<p>Переменная в Perl 5 представляет как значение (курс доллара, доступные начинки для пиццы, гитарные магазины с телефонными номерами), так и контейнер, в котором хранится это значение. Система типов Perl имеет дело с <em>типами значений</em> и <em>типами контейнеров</em>. Тогда как <em>тип контейнера</em> переменной &mdash; скаляр, массив или хеш &mdash; не может измениться, относительно типа значения переменной Perl проявляет гибкость. Вы можете сохранить строку в переменной в одной строке кода, добавить к этой переменной число в следующей и переназначить ей ссылку на функцию (<a href="chapter_03.html#function_references">Ссылки на функции</a>) в третьей.</p>

<p>Выполнение над переменной операции, требующей конкретного типа значения, может вызвать приведение (<a href="chapter_03.html#coercion">Приведение типов</a>) из текущего типа значения переменной.</p>

<p>Например, документированный способ определить количество элементов в массиве &mdash; обратиться к нему в скалярном контексте (<a href="chapter_01.html#context_philosophy">Контекст</a>). Так как скалярная переменная может содержать только скаляр, присвоение массива скаляру налагает на операцию скалярный контекст, и массив, вычисленный в скалярном контексте, возвращает количество элементов в этом массиве:</p>

<pre><code>    my $count = @items;</code></pre>

<p>Отношения между типами переменных, сигилами и контекстом имеют первостепенную важность.</p>

<h2>Значения</h2>

<p><a name="values"></p>

<p> </p>

<p>Структура программы в большой степени зависит от способов, используя которые вы моделируете ваши данные с помощью соответствующих переменных.</p>

<p>Тогда как переменные позволяют производить абстрактные манипуляции с данными, значения, которые они содержат, делают программы конкретными и полезными. Чем более точны значения, тем лучше ваши программы. Эти значения &mdash; это данные: имя и адрес вашей тётушки, расстояние между вашим офисом и полем для игры в гольф на луне или вес всех печенек, которые вы съели за прошлый год. Внутри вашей программы правила, касающиеся формата этих данных, зачастую строги. Действенные программы требуют действенных (простых, быстрых, более компактных, более эффективных) способов представления их данных.</p>

<h3>Строки</h3>

<p></p>

<p><em>Строка</em> &mdash; это кусок текстовых или двоичных данных без какого-либо особого форматирования или содержимого. Это может быть ваше имя, содержимое файла изображения или сама ваша программа. Строка имеет значение в программе только когда вы придаёте ей это значение.</p>

<p></p>

<p>Для представляения литеральной строки в вашей программе, окружите её парой символов заключения в кавычки. Наиболее распространённые <em>ограничители строк</em> &mdash; одиночные и двойные кавычки:</p>

<pre><code>    my $name    = <strong>&#39;Donner Odinson, Bringer of Despair&#39;</strong>;
    my $address = <strong>&quot;Room 539, Bilskirnir, Valhalla&quot;</strong>;</code></pre>

<p></p>

<p>Символы в <em>строке, заключённой в одиночные кавычки</em>, представляют в точности себя, за двумя исключениями. Одиночная кавычка, помещаемая в заключённую в одиночные кавычки строку, должна быть экранирована предшествующим обратным слешем:</p>

<pre><code>    my $reminder = &#39;Don<strong>\&#39;</strong>t forget to escape &#39;
                 . &#39;the single quote!&#39;;</code></pre>

<p>Также вы должны экранировать обратный слеш, находящийся в конце строки, чтобы избежать экранирования закрывающего ограничителя и получения синтаксической ошибки:</p>

<pre><code>    my $exception = &#39;This string ends with a &#39;
                  . &#39;backslash, not a quote: <strong>\\</strong>&#39;;</code></pre>

<p>Любой другой обратный слеш станет частью строки как есть, если только два обратных слеша не расположены друг за другом, в этом случае первый будет экранировать второй:</p>

<pre><code>    is(&#39;Modern <strong>\</strong> Perl&#39;, &#39;Modern <strong>\\</strong> Perl&#39;,
        &#39;single quotes backslash escaping&#39;);</code></pre>

<p></p>

<p>Для <em>строки, заключённой в двойные кавычки</em>, доступно ещё некоторое количество специальных символов. Например, вы можете закодировать в строке иначе невидимые пробельные символы:</p>

<pre><code>    my $tab       = &quot;<strong>\t</strong>&quot;;
    my $newline   = &quot;<strong>\n</strong>&quot;;
    my $carriage  = &quot;<strong>\r</strong>&quot;;
    my $formfeed  = &quot;<strong>\f</strong>&quot;;
    my $backspace = &quot;<strong>\b</strong>&quot;;</code></pre>

<p>Это демонстрирует полезный принцип: синтаксис, используемый для объявления строки, может варьироваться. Вы можете представить символ табуляции в строке как <code>\t</code> или введя его напрямую. С точки зрения Perl, обе строки ведут себя одинаково, несмотря на то, что конкретное представление строки в исходном коде может отличаться.</p>

<p>Объявление строки может пересекать логические переводы строк; эти два объявления эквивалентны:</p>

<pre><code>    my $escaped = &quot;two\nlines&quot;;
    my $literal = &quot;two
    lines&quot;;
    is $escaped, $literal, &#39;equivalent \n and newline&#39;;</code></pre>

<p>Эти последовательности зачастую проще читать, чем их пробельные эквивалентны.</p>

<p>  </p>

<p>Строки в Perl имеют переменную длину. По мере того, как вы манипулируете строками и модифицируете их, Perl будет соответствующим образом изменять их размер. Например, вы можете объединить несколько строк в одну большую строку с помощью оператора <em>конкатенации</em> <code>.</code>:</p>

<pre><code>    my $kitten = &#39;Choco&#39; . &#39; &#39; . &#39;Spidermonkey&#39;;</code></pre>

<p>Это фактически то же самое, что и инициализация строки сразу целиком.</p>

<p> </p>

<p>Также вы можете <em>интерполировать</em> значение скалярной переменной или значений массива в строке, заключённой в двойные кавычки, так что <em>текущее</em> содержимое переменной станет частью строки, как если бы вы их конкатенировали:</p>

<pre><code>    my $factoid = &quot;<strong>$name</strong> lives at <strong>$address</strong>!&quot;;

    # &#x44D;&#x43A;&#x432;&#x438;&#x432;&#x430;&#x43B;&#x435;&#x43D;&#x442;&#x43D;&#x43E;
    my $factoid = $name . &#39; lives at &#39; . $address . &#39;!&#39;;</code></pre>

<p></p>

<p>Включение двойной кавычки в заключённую в двойные кавычки строку требует её <em>экранирования</em> (то есть предварения её обратным слешем):</p>

<pre><code>    my $quote = &quot;\&quot;Ouch,\&quot;, he cried.  \&quot;That <em>hurt</em>!\&quot;&quot;;</code></pre>

<p>    </p>

<p>Когда повторение обратных слешей становится громоздким, используйте альтернативный <em>оператор заключения в кавычки</em>, для которого вы можете выбрать альтернативный ограничитель строк. Оператор <code>q</code> аналогичен одиночным кавычкам, тогда как оператор <code>qq</code> обеспечивает поведение двойных кавычек. Символ, следующий сразу за оператором, определяет, какой символ используется для ограничения строк. Если этот символ является открывающим символом симметричной пары &mdash; такой как открывающая и закрывающая скобки &mdash; закрывающий символ будет конечным ограничителем. В ином случае, сам указанный символ будет как начальным, так и конечным ограничителем.</p>

<pre><code>    my $quote     = <strong>qq{</strong>&quot;Ouch&quot;, he said.  &quot;That <em>hurt</em>!&quot;<strong>}</strong>;
    my $reminder  =  <strong>q^</strong>Don&#39;t escape the single quote!<strong>^</strong>;
    my $complaint =  <strong>q{</strong>It&#39;s too early to be awake.<strong>}</strong>;</code></pre>

<p> </p>

<p>Если объявление сложной строки, содержащей последовательность экранированных символов, слишком утомительно, используйте синтаксис <em>heredoc</em> (встроенных документов) для присвоения строке одной или нескольких строчек текста:</p>

<pre><code>    my $blurb =&lt;&lt;&#39;END_BLURB&#39;;

    He looked up. &quot;Time is never on our side, my child.
    Do you see the irony? All they know is change.
    Change is the constant on which they all can agree.
    We instead, born out of time, remain perfect and
    perfectly self-aware. We only suffer change as we
    pursue it. It is against our nature. We rebel
    against that change. Shall we consider them
    greater for it?&quot;
    END_BLURB</code></pre>

<p>Синтаксис <code><<'END_BLURB'</code> имеет три части. Двойные угловые скобки открывают встроенный документ. Кавычки определяют, будет ли он проявлять поведение одиночных или двойных кавычек. Поведение по умолчанию &mdash; интерполяция двойных кавычек. <code>END_BLURB</code> &mdash; произвольный идентификатор, который парсер Perl 5 использует как конечный ограничитель.</p>

<p>Будьте внимательны &mdash; независимо от отступа самого объявления встроенного документа, конечный ограничитель <em>должен</em> быть расположен в начале строки:</p>

<pre><code>    sub some_function {
        my $ingredients =&lt;&lt;&#39;END_INGREDIENTS&#39;;
        Two eggs
        One cup flour
        Two ounces butter
        One-quarter teaspoon salt
        One cup milk
        One drop vanilla
        Season to taste
    END_INGREDIENTS
    }</code></pre>

<blockquote>

<p>Если идентификатор начинается с пробельных символов, те же самые пробельные символы должны присутствовать перед конечным ограничителем. Тем не менее, если вы сделаете отступ у идентификатора, Perl 5 <em>не будет</em> удалять соответствующие пробелы из начала каждой строки встроенного документа.</p>

</blockquote>

<p>Использование строки в нестроковом контексте приведёт к приведению типа (<a href="chapter_03.html#coercion">Приведение типов</a>).</p>

<h3>Юникод и строки</h3>

<p><a name="unicode"> </p>

<p><em>Юникод</em> &mdash; это система представления символов письменных языков мира. В то время как большая часть английского текста использует набор символов, состоящий всего из 127 символов (что требует для хранения семи битов и замечательно вписывается в восьмибитовый байт), наивно предполагать, что вам рано или поздно не понадобится умляут.</p>

<p>Строки в Perl 5 могут представлять один из двух отдельных, но связанных типов данных:</p>

<p></p>

<ul>

<li>Последовательности символов Юникод

<p>Каждый символ имеет <em>код</em>, уникальное число, которое идентифицирует его в таблице символов Юникод.</p>

<li>Последовательность октетов

<p></p>

<p>Двоичные данные &mdash; это последовательность <em>октетов</em>, восьмибитовых чисел, каждое из которых может представлять число от 0 до 255.</p>

</ul>

<p>Почему <em>octet</em> а не <em>байт</em>? Предположение, что один символ помещается в один байт, принесёт вам бесконечную юникодовую скорбь. Разделяйте идеи хранения в памяти и представления символов.</p>

<p>Юникодовые строки и двоичные строки выглядят похоже. Каждая имеет длину (<code>length()</code>). Каждая поддерживает стандартные строковые операции, такие как конкатенация, работа с подстроками и обработка регулярными выражениями. Любая строка, не являющаяся чистыми двоичными данными, есть текстовые данные, и должна быть представлена последовательностью символов Юникод.</p>

<p>Однако, из-за того, как ваша операционная система представляет данные на диске, или полученные от пользователей, или передаваемые по сети &mdash; как последовательность октетов &mdash; Perl не может знать, являются ли читаемые вами данные файлом изображения, или текстовым документом, или чем-нибудь ещё. По умолчанию Perl воспринимает все входящие данные как последовательность октетов. Вы должны наделить эти данные конкретным значением.</p>

<h4>Кодировки символов</h4>

<p>    </p>

<p>Строка Юникод &mdash; это последовательность октетов, которая представляет последовательность символов. <em>Кодировка Юникод</em> устанавливает соответствие последовательностей октетов символам. Некоторые кодировки, такие как UTF-8, могут кодировать все символы из набора символов Юникод. Другие кодировки представляют его подмножество. Например, ASCII кодирует простой английский текст без диакритических символов, тогда как Latin-1 может представлять текст на большинстве языков, использующих латинский алфавит.</p>

<p>Чтобы избежать большинства проблем с Юникодом, всегда используйте соответствующие кодировки для декодирования входных и выходных данных вашей программы.</p>

<p>Perl 5.12 поддерживает стандарт Юникод 5.2, тогда как Perl 5.14 поддерживает Юникод 6.0. Если вам нужно заботиться о различиях между версиями Юникод, вы, вероятно, уже знаете, что нужно смотреть на http://unicode.org/versions/.</p>

<h4>Юникод в ваших дескрипторах файлов</h4>

<p>  </p>

<p>Если вы скажете Perl, что определённый дескриптор файла (<a href="chapter_09.html#files">Файлы</a>) работает с кодированным текстом, Perl будет конвертировать входящие октеты в строки Юникод автоматически. Чтобы это сделать, добавьте слой ввода-вывода к режиму встроенной функции <code>open</code>. <em>Слой ввода-вывода</em> оборачивается вокруг входа и выхода и конвертирует данные. В данном случае, слой <code>:utf8</code> декодирует данные в UTF-8:</p>

<pre><code>    use autodie;

    open my $fh, &#39;&lt;:utf8&#39;, $textfile;

    my $unicode_string = &lt;$fh&gt;;</code></pre>

<p> </p>

<p>Также вы можете модифицировать существующий дескриптор файла с помощью <code>binmode</code>, как для ввода, так и для вывода:</p>

<pre><code>    binmode $fh, &#39;:utf8&#39;;
    my $unicode_string = &lt;$fh&gt;;

    binmode STDOUT, &#39;:utf8&#39;;
    say $unicode_string;</code></pre>

<p>Без режима <code>utf8</code> печать строк Юникод в дескриптор файла приведёт к предупреждению (<code>Wide character in %s</code>), потому что файлы содержат октеты, а не символы Юникод.</p>

<h4>Юникод в ваших данных</h4>

<p>  </p>

<p>Базовый модуль <code>Encode</code> предоставляет функцию, называемую <code>decode()</code>, для конвертации скаляра, содержащего данные, в строку Юникод. Соответствующая функция <code>encode()</code> конвертирует из внутренней кодировки Perl в желаемую выходную кодировку:</p>

<pre><code>    my $from_utf8 = decode(&#39;utf8&#39;, $data);
    my $to_latin1 = encode(&#39;iso-8859-1&#39;, $string);</code></pre>

<h4>Юникод в ваших программах</h4>

<p>  </p>

<p>Вы можете включать символы Юникод в ваши программы тремя способами. Самый простой &mdash; использовать прагму <code>utf8</code> (<a href="chapter_08.html#pragmas">Прагмы</a>), которая указывает парсеру Perl интерпретировать остальную часть файла исходного кода как имеющую кодировку UTF-8. Это позволяет вам использовать символы Юникод в строках и идентификаторах:</p>

<pre><code>    use utf8;

    sub &pound;_to_&yen; { ... }

    my $yen = &pound;_to_&yen;(&#39;1000&pound;&#39;);</code></pre>

<p>Чтобы <em>писать</em> такой код, ваш текстовый редактор должен понимать UTF-8, а вы должны сохранить файл в соответствующей кодировке.</p>

<p> </p>

<p>Внутри строк в двойных кавычках вы можете использовать экранированные последовательности Юникод для представления кодировок символов. Синтаксис <code>\x{}</code> представляет один символ; поместите в фигурных скобках шестнадцатиричную форму номера символа в Юникод:</p>

<pre><code>    my $escaped_thorn = &quot;\x{00FE}&quot;;</code></pre>

<p>   </p>

<p>Некоторые символы Юникод имеют имена, и эти имена зачастую проще читать, чем номера Юникод. Используйте прагму <code>charnames</code> для того, чтобы их включить, и <code>\N{}</code>, чтобы на них ссылаться:</p>

<pre><code>    use charnames &#39;:full&#39;;
    use Test::More tests =&gt; 1;

    my $escaped_thorn = &quot;\x{00FE}&quot;;
    my $named_thorn   = &quot;\N{LATIN SMALL LETTER THORN}&quot;;

    is $escaped_thorn, $named_thorn,
        &#39;Thorn equivalence check&#39;;</code></pre>

<p>Вы можете использовать формы <code>\x{}</code> и <code>\N{}</code> в регулярных выражениях, так же как и в любых местах, где допустимо использовать строку или символ.</p>

<h4>Неявная конвертация</h4>

<p>Большинство проблем Юникод в Perl проистекают из того факта, что строка может быть или последовательностью октетов, или последовательностью символов. Perl позволяет вам комбинировать эти типы посредством неявных конвертаций. Когда эти конвертации неверны, они редко <em>очевидно</em> неверны.</p>

<p>Когда Perl конкатенирует последовательность октетов с последовательностью символов Юникод, он неявно декодирует последовательность октетов, используя кодировку Latin-1. Результирующая строка будет содержать символы Юникод. Когда вы печатаете символы Юникод, Perl кодирует строку, используя UTF-8, потому что Latin-1 не может отображать весть набор символов Юникод: Latin-1 &mdash; подмножество UTF-8.</p>

<p>Эта асимметрия может привести к строкам Юникод, закодированным как UTF-8 для вывода и декодированным как Latin-1 на вводе.</p>

<p>Хуже того, если текст содержит только английские символы без знаков диакритики, то ошибка скрывается &mdash; потому что обе кодировки одинаково отображают каждый символ.</p>

<pre><code>    my $hello    = &quot;Hello, &quot;;
    my $greeting = $hello . $name;</code></pre>

<p>Если <code>$name</code> содержит английское имя, такое как <em>Alice</em>, вы никогда не заметите никаких проблем, потому что представление Latin-1 точно такое же, как представление UTF-8. Если <code>$name</code> содержит такое имя, как <em>Jos&eacute;</em>, <code>$name</code> может содержать несколько возможных значений:</p>

<ul>

<li><code>$name</code> содержит четыре символа Юникод.</li>

<li><code>$name</code> содержит четыре октета Latin-1, представляющих четыре символа Юникод.</li>

<li><code>$name</code> содержит пять октетов UTF-8, представляющих четыре символа Юникод.</li>

</ul>

<p>Строковый литерал имеет несколько возможных сценариев:</p>

<ul>

<li>Это строковый литерал ASCII, содержащий октеты.</li>

<pre><code>    my $hello = &quot;Hello, &quot;;</code></pre>

<li>Это строковый литерал Latin-1 без определённой кодировки, содержащий октеты.</li>

<pre><code>    my $hello = &quot;&iexcl;Hola, &quot;;</code></pre>

<p>Строковый литерал содержит октеты.</p>

<li>Это строковый литерал не-ASCII с действующей прагмой <code>utf8</code> или <code>encoding</code>, содержащий символы Юникод.</li>

<pre><code>    use utf8;
    my $hello = &quot;Kuirab&aacute;, &quot;;</code></pre>

</ul>

<p>Если и <code>$hello</code>, и <code>$name</code> &mdash; строки Юникод, конкатенация порождает другую строку Юникод.</p>

<p>Если обе строки &mdash; потоки октетов, Perl конкатенирует их в новую строку, содержащую октеты. Если оба значения &mdash; октеты с одной и той же кодировкой, например, оба &mdash; Latin-1, конкатенация сработает корректно. Если же октеты имеют разную кодировку, например, конкатенация добавляет данные в UTF-8 к данным в Latin-1, то результирующая последовательность октетов не будет иметь смысла <em>ни в какой</em> из кодировок. Это может случиться, если пользователь ввёл имя как данные UTF-8, а приветствие было строковым литералом Latin-1, но программа не декодировала ни то, ни другое.</p>

<p>Если только одно из значений &mdash; строка Юникод, Perl будет декодировать другое как данные Latin-1. Если это не корректная кодировка, результирующие символы Юникод будут неверными. Например, если пользовательский ввод был данными в UTF-8, а строковый литерал был строкой Юникод, имя было бы некорректно декодировано в пять символов Юникод в виде <em>Jos&Atilde;&copy;</em> (<em>именно!</em>) вместо <em>Jos&eacute;</em>, потому что данные UTF-8 означают что-то совсем другое, когда декодируются как данные Latin-1.</p>

<p>Смотрите <code>perldoc perluniintro</code> для получения намного более детального объяснения Юникод, кодировок, и того, как управлять входящими и исходящими данными в мире Юникод (footnote: Для <em>ещё</em> больших подробностей на тему эффективного управления Юникодом в ваших программах, смотрите ответ Тома Кристиансена (Tom Christiansen) на вопрос &laquo;Почему Современный Perl избегает UTF-8 по умолчанию?&raquo; http://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default/6163129#6163129).</p>

<blockquote>

<p> </p>

<p>В Perl 5.12 была добавлена возможность, <code>unicode_strings</code>, которая активирует семантику Юникод для всех строковых операций в своей области видимости. Perl 5.14 улучшил эту возможность; если вы работаете с Юникодом в Perl, стоит обновиться хотя бы до Perl 5.14.</p>

</blockquote>

<h3>Числа</h3>

<p>  </p>

<p>Perl поддерживает числа в виде как целых значений, так и значений с плавающей точкой. Вы можете выражать их в научной нотации, так же как в двоичной, восьмеричной и шестнадцатиричной формах:</p>

<pre><code>    my $integer   = 42;
    my $float     = 0.007;
    my $sci_float = 1.02e14;
    my $binary    = <strong>0b</strong>101010;
    my $octal     = <strong>0</strong>52;
    my $hex       = <strong>0x</strong>20;</code></pre>

<p>   </p>

<p>Выделенные жирным символы &mdash; числовые префиксы для двоичной, восьмеричной и шестнадцатиричной нотации соответственно. Имейте ввиду, что ведущий ноль в целом числе <em>всегда</em> означает восьмеричный режим.</p>

<p> </p>

<p>Хотя в Perl 5 вы и можете явно записывать значения с плавающей точкой с совершенной точностью, Perl 5 внутренне хранит их двоичном формате. Это представление иногда неточно специфическим образом; проконсультируйтесь с <code>perldoc perlnumber</code> для больших деталей.</p>

<p>Вы не можете использовать запятые для отделения тысяч в числовых литералах, потому что парсер сочтёт запятую оператором запятой. Вместо этого используйте в числах подчёркивания. Парсер будет будет воспринимать их как невидимые символы; ваши читатели, возможно, нет. Эти записи равнозначны:</p>

<pre><code>    my $billion = 1000000000;
    my $billion = 1_000_000_000;
    my $billion = 10_0_00_00_0_0_0;</code></pre>

<p>Подумайте, какой вариант наиболее читабелен.</p>

<p> </p>

<p>Из-за приведения типа (<a href="chapter_03.html#coercion">Приведение типов</a>), Perl-программистам редко приходится беспокоиться о конвертации текста, прочитанного из-за пределов программы, в числа. Perl будет обращаться со всем, что выглядит как число, <em>как</em> с числом в числовом контексте. В редких ситуациях, когда вам нужно знать, выглядит ли нечто как число для Perl, используйте функцию <code>looks_like_number</code> из базового модуля <code>Scalar::Util</code>. Эта функция возвращает истину, если Perl будет считать переданный аргумент числовым.</p>

<p></p>

<p>Модуль <code>Regexp::Common</code> из CPAN предоставляет несколько хорошо протестированных регулярных выражений для определения более конкретных допустимых <em>типов</em> числовых значений (целое число, целое значение, значение с плавающей точкой).</p>

<h3>Undef</h3>

<p></p>

<p>Значение <code>undef</code> в Perl 5 представляет собой неприсвоенное, неопределённое и неизвестное значение. Объявленные, но не определённые скалярные переменные всегда содержат <code>undef</code>:</p>

<pre><code>    my $name = undef;   # &#x43D;&#x435;&#x43E;&#x431;&#x44F;&#x437;&#x430;&#x442;&#x435;&#x43B;&#x44C;&#x43D;&#x43E;&#x435; &#x43F;&#x440;&#x438;&#x441;&#x432;&#x430;&#x438;&#x432;&#x430;&#x43D;&#x438;&#x435;
    my $rank;           # &#x442;&#x43E;&#x436;&#x435; &#x441;&#x43E;&#x434;&#x435;&#x440;&#x436;&#x438;&#x442; undef</code></pre>

<p></p>

<p><code>undef</code> даёт ложь в булевом контексте. Использование <code>undef</code> в строковом контексте &mdash; например, интерполяция его в строке, &mdash; генерирует предупреждение <code>uninitialized value</code>:</p>

<pre><code>    my $undefined;
    my $defined = $undefined . &#39;... and so forth&#39;;</code></pre>

<p>&hellip;выдаёт:</p>

<pre><code>    Use of uninitialized value $undefined in
    concatenation (.) or string...</code></pre>

<p></p>

<p>Встроенная функция <code>defined</code> возвращает истинное значение, если её операнд является определённым значением (любым отличным от <code>undef</code>):</p>

<pre><code>    my $status = &#39;suffering from a cold&#39;;

    say <strong>defined</strong> $status;  # 1, &#x438;&#x441;&#x442;&#x438;&#x43D;&#x43D;&#x43E;&#x435; &#x437;&#x43D;&#x430;&#x447;&#x435;&#x43D;&#x438;&#x435;
    say <strong>defined</strong> undef;    # &#x43F;&#x443;&#x441;&#x442;&#x430;&#x44F; &#x441;&#x442;&#x440;&#x43E;&#x43A;&#x430;, &#x43B;&#x43E;&#x436;&#x43D;&#x43E;&#x435; &#x437;&#x43D;&#x430;&#x447;&#x435;&#x43D;&#x438;&#x435;</code></pre>

<h3>Пустой список</h3>

<p> </p>

<p>При использовании справа от присваивания, конструкция <code>()</code> обозначает пустой список. В скалярном контексте он вычисляется в <code>undef</code>. В списочном контексте это пустой список. При использовании слева от присваивания, конструкция <code>()</code> налагает списочный контекст. Для подсчёта количества элементов, возвращаемых выражением в списочном контексте, без использования временной переменной, используйте следующую идиому (<a href="chapter_10.html#idioms">Идиомы</a>):</p>

<pre><code>    my $count = <strong>()</strong> = get_all_clown_hats();</code></pre>

<p>Из-за правой ассоциативности (<a href="chapter_04.html#associativity">Ассоциативность</a>) оператора присваивания, Perl сначала вычисляет второе присваивание, вызывая <code>get_all_clown_hats()</code> в списочном контексте. Это генерирует список.</p>

<p>Присваивание пустому списоку отбрасывает все значения из списка, но это присваивание происходит в скалярном контексте, что выдаёт количество элементов на правой стороне присваивания. В результате <code>$count</code> содержит количество элементов в списке, возвращаемом <code>get_all_clown_hats()</code>.</p>

<p>Если сейчас эта концепция кажется вам сбивающей с толку, не бойтесь. Когда вы поймёте, как фундаментальные особенности дизайна Perl взаимодействуют на практике, это будет иметь больше смысла.</p>

<h3>Списки</h3>

<p></p>

<p>Список &mdash; это разделённая запятыми группа из одного или более выражений. Списки могут появляться в исходном коде буквально как значения:</p>

<pre><code>    my @first_fibs = (1, 1, 2, 3, 5, 8, 13, 21);</code></pre>

<p>&hellip;как цели присваивания:</p>

<pre><code>    my ($package, $filename, $line) = caller();</code></pre>

<p>&hellip;или списки выражений:</p>

<pre><code>    say name(), &#39; =&gt; &#39;, age();</code></pre>

<p>Скобки не <em>создают</em> списки. Списки создаёт оператор запятая. Скобки, там, где они присутствуют в этих примерах, группируют выражения для изменения их <em>приоритета</em> (<a href="chapter_04.html#precedence">Приоритет</a>).</p>

<p>  </p>

<p>Используйте оператор диапазона для создания списков литералов в компактной форме:</p>

<pre><code>    my @chars = &#39;a&#39; .. &#39;z&#39;;
    my @count = 13 .. 27;</code></pre>

<p> </p>

<p>Используйте оператор <code>qw()</code> чтобы разбить литеральную строку по пробелам и получить список строк:</p>

<pre><code>    my @stooges = qw( Larry Curly Moe Shemp Joey Kenny );</code></pre>

<p>Perl покажет предупреждение, если <code>qw()</code> содержит запятую или символ комментария (<code>#</code>), потому что такие символы не только редки в <code>qw()</code>, но их присутствие обычно указывает на недосмотр.</p>

<p>Списки могут (и это часто происходит) быть результатами выражений, но эти списки не появляются буквально в исходном коде.</p>

<p>Списки и массивы в Perl не взаимозаменяемы. Списки &mdash; это значения. Массивы &mdash; это контейнеры. Вы можете сохранить список в массиве или преобразовать массив в список, но это разные сущности. Например, индексация в списке всегда происходит в списочном контексте. Индексация в массиве может происходить в скалярном контексте (для единственного элемента) или списочном контексте (для среза):</p>

<pre><code>    # &#x43F;&#x43E;&#x43A;&#x430; &#x43D;&#x435; &#x431;&#x435;&#x441;&#x43F;&#x43E;&#x43A;&#x43E;&#x439;&#x442;&#x435;&#x441;&#x44C; &#x43E; &#x434;&#x435;&#x442;&#x430;&#x43B;&#x44F;&#x445;
    sub context
    {
        my $context = wantarray();

        say defined $context
             ? $context
                 ? &#39;list&#39;
                 : &#39;scalar&#39;
             : &#39;void&#39;;
        return 0;
    }

    my @list_slice  = (1, 2, 3)[context()];
    my @array_slice = @list_slice[context()];
    my $array_index = $array_slice[context()];

    say context(); # &#x441;&#x43F;&#x438;&#x441;&#x43E;&#x447;&#x43D;&#x44B;&#x439; &#x43A;&#x43E;&#x43D;&#x442;&#x435;&#x43A;&#x441;&#x442;
    context();     # &#x43F;&#x443;&#x441;&#x442;&#x43E;&#x439; &#x43A;&#x43E;&#x43D;&#x442;&#x435;&#x43A;&#x441;&#x442;</code></pre>

<h2>Поток управления</h2>

<p><a name="control_flow"></p>

<p></p>

<p>Базовый <em>поток управления</em> в Perl &mdash; прямой. Выполнение программы начинается с начала (первая строка исполняемого файла) и продолжается до конца:</p>

<pre><code>    say &#39;At start&#39;;
    say &#39;In middle&#39;;
    say &#39;At end&#39;;</code></pre>

<p></p>

<p><em>Директивы потока управления</em> в Perl изменяют порядок выполнения &mdash; что в программе произойдёт следущим &mdash; в зависимости от значений их выражений.</p>

<h3>Директивы ветвления</h3>

<p></p>

<p>Директива <code>if</code> выполняет связанное действие только если её условное выражение возвращает <em>истинное</em> значение:</p>

<pre><code>    say &#39;Hello, Bob!&#39; if $name eq &#39;Bob&#39;;</code></pre>

<p>Эта постфиксная форма удобна для простых выражений. Блочная форма группирует несколько выражений воедино:</p>

<pre><code>    if ($name eq &#39;Bob&#39;)
    {
        say &#39;Hello, Bob!&#39;;
        found_bob();
    }</code></pre>

<p>Блочная форма требует скобок вокруг своего условия, постфиксная же форма &mdash; нет:</p>

<p>Условное выражение может состоять из нескольких подвыражений, до тех пор пока оно вычисляется в одно выражение верхнего уровня:</p>

<pre><code>    if ($name eq &#39;Bob&#39; &amp;&amp; not greeted_bob())
    {
        say &#39;Hello, Bob!&#39;;
        found_bob();
    }</code></pre>

<p>В постфиксной форме добавление скобок может прояснить замысел кода ценой визуальной чистоты:</p>

<pre><code>    greet_bob() if ($name eq &#39;Bob&#39; &amp;&amp; not greeted_bob());</code></pre>

<p></p>

<p>Директива <code>unless</code> &mdash; отрицательная форма <code>if</code>. Perl выполнит действие в случае, если условное выражение возвращает <em>ложь</em>:</p>

<pre><code>    say &quot;You&#39;re not Bob!&quot; unless $name eq &#39;Bob&#39;;</code></pre>

<p>Как и <code>if</code>, <code>unless</code> тоже имеет блочную форму, хотя многие программисты избегают её, потому что со сложными условиями она очень быстро становится сложной для чтения:</p>

<pre><code>    unless (is_leap_year() and is_full_moon())
    {
        frolic();
        gambol();
    }</code></pre>

<p><code>unless</code> очень хорошо работает для постфиксных условий, особенно для валидации параметров в функциях (<a href="chapter_10.html#postfix_parameter_validation">Постфиксная валидация параметров</a>):</p>

<pre><code>    sub frolic
    {
        return unless @_;

        for my $chant (@_) { ... }
    }</code></pre>

<p></p>

<p>Блочные формы как <code>if</code>, так и <code>unless</code>, работают с директивой <code>else</code>, предоставляющей код для выполнения в случае, если условное выражение не возвращает истину (для <code>if</code>) или ложь (для <code>unless</code>):</p>

<pre><code>    if ($name eq &#39;Bob&#39;)
    {
        say &#39;Hi, Bob!&#39;;
        greet_user();
    }
    else
    {
        say &quot;I don&#39;t know you.&quot;;
        shun_user();
    }</code></pre>

<p>Блоки <code>else</code> позволяют переписать условия <code>if</code> и <code>unless</code> в терминах друг друга:</p>

<pre><code>    unless ($name eq &#39;Bob&#39;)
    {
        say &quot;I don&#39;t know you.&quot;;
        shun_user();
    }
    else
    {
        say &#39;Hi, Bob!&#39;;
        greet_user();
    }</code></pre>

<p>Однако, подразумеваемое двойное отрицание при использовании <code>unless</code> с блоком <code>else</code> может сбивать с толку. Этот пример, возможно, единственное место, где вы его когда-либо увидите.</p>

<p>Perl не только предоставляет вам и <code>if</code>, и <code>unless</code>, чтобы дать возможность выразить ваши условия наиболее читаемым способом, вы также можете выбирать между положительными и отрицательными условными операторами:</p>

<pre><code>    if ($name <strong>ne</strong> &#39;Bob&#39;)
    {
        say &quot;I don&#39;t know you.&quot;;
        shun_user();
    }
    else
    {
        say &#39;Hi, Bob!&#39;;
        greet_user();
    }</code></pre>

<p>&hellip;хотя двойное отрицание, создаваемое присутствием блока <code>else</code>, наводит на мысль инвертировать условие.</p>

<p></p>

<p>Одна или более директив <code>elsif</code> может следовать за блочной формой <code>if</code> и предшествовать единственной директиве <code>else</code>:</p>

<pre><code>    if ($name eq &#39;Bob&#39;)
    {
        say &#39;Hi, Bob!&#39;;
        greet_user();
    }
    elsif ($name eq &#39;Jim&#39;)
    {
        say &#39;Hi, Jim!&#39;;
        greet_user();
    }
    else
    {
        say &quot;You&#39;re not my uncle.&quot;;
        shun_user();
    }</code></pre>

<p>Цепочка <code>unless</code> тоже может использовать блок <code>elsif</code> (footnote: Удачи с расшифровкой этого!). Однако, не существует директивы <code>elseunless</code>.</p>

<p>Написание <code>else if</code> &mdash; синтаксическая ошибка (footnote: Ларри предпочитает <code>elsif</code> исходя из эстетических причин, а также предшествующего искусства языка програмирования Ada.):</p>

<pre><code>    if ($name eq &#39;Rick&#39;)
    {
        say &#39;Hi, cousin!&#39;;
    }

    # &#x432;&#x43D;&#x438;&#x43C;&#x430;&#x43D;&#x438;&#x435;, &#x441;&#x438;&#x43D;&#x442;&#x430;&#x43A;&#x441;&#x438;&#x447;&#x435;&#x441;&#x43A;&#x430;&#x44F; &#x43E;&#x448;&#x438;&#x431;&#x43A;&#x430;
    else if ($name eq &#39;Kristen&#39;)
    {
        say &#39;Hi, cousin-in-law!&#39;;
    }</code></pre>

<h3>Тернарный условный оператор</h3>

<p> </p>

<p><em>Тернарный условный</em> оператор вычисляет условное выражение и возвращает одну из двух альтернатив:</p>

<pre><code>    my $time_suffix = after_noon($time)
                    ? &#39;afternoon&#39;
                    : &#39;morning&#39;;</code></pre>

<p>Условное выражение предшествует символу вопросительного знака (<code>?</code>), а символ двоеточия (<code>:</code>) разделяет альтернативы. Альтернативы &mdash; это выражения произвольной сложности, включая другие тернарные условные выражения.</p>

<blockquote>

<p>Интересная, хотя и малоизвестная, идиома &mdash; использование тернарного условия для выбора между альтернативными <em>переменными</em>, а не только значениями:</p>

<pre><code>    push @{ rand() &gt; 0.5 ? \@red_team : \@blue_team },
        Player-&gt;new;</code></pre>

<p>И снова, взвесьте выгоды ясности против выгод краткости.</p>

</blockquote>

<h4>Короткое замыкание</h4>

<p><a name="short_circuiting"> </p>

<p>Perl проявляет поведение, называемое <em>коротким замыканием</em>, когда встречается со сложными условными выражениями. Если Perl может определить, будет ли сложное выражение истинно или ложно, не вычисляя каждое подвыражение, он не будет вычислять последующие подвыражения. Это наиболее очевидно на примере:</p>

<pre><code>    say &quot;Both true!&quot; if ok( 1, &#39;subexpression one&#39; )
                     &amp;&amp; ok( 1, &#39;subexpression two&#39; );

    done_testing();</code></pre>

<p>Возвращаемое значение <code>ok()</code> (<a href="chapter_09.html#testing">Тестирование</a>) &mdash; это булево значение, полученное при вычислении первого аргумента, поэтому этот код выведет:</p>

<pre><code>    ok 1 - subexpression one
    ok 2 - subexpression two
    Both true!</code></pre>

<p>Если первое подвыражение &mdash; первый вызов <code>ok</code> &mdash; возвращает истинное значение, Perl должен будет вычислить второе подвыражение. Если бы первое подвыражение вернуло ложное значение, то не было бы необходимости проверять последующие подвыражения, так как всё выражение уже не может быть истинным:</p>

<pre><code>    say &quot;Both true!&quot; if ok( 0, &#39;subexpression one&#39; )
                     &amp;&amp; ok( 1, &#39;subexpression two&#39; );</code></pre>

<p>Этот пример выводит:</p>

<pre><code>    not ok 1 - subexpression one</code></pre>

<p>Хотя второе подвыражение очевидно вернёт истину, Perl никогда не вычислит его. То же самое короткое замыкание очевидно для операций логического или:</p>

<pre><code>    say &quot;Either true!&quot; if ok( 1, &#39;subexpression one&#39; )
                       || ok( 1, &#39;subexpression two&#39; );</code></pre>

<p>Этот пример выводит:</p>

<pre><code>    ok 1 - subexpression one
    Either true!</code></pre>

<p>В случае истинности первого подвыражения, Perl может избежать вычисления второго подвыражения. Если бы первое подвыражение было ложным, результат вычисления второго подвыражения определил бы результат вычисления всего выражения.</p>

<p>Короткое замыкание позволяет вам не только избежать потенциально дорогих вычислений, но и избежать ошибок и предупреждений, как в случае, когда использование неопределённого значения может вызвать предупреждение:</p>

<pre><code>    my $bbq;
    if (defined $bbq and $bbq eq &#39;brisket&#39;) { ... }</code></pre>

<h3>Контекст в условных директивах</h3>

<p>   </p>

<p>Все условные директивы &mdash; <code>if</code>, <code>unless</code> и тернарный условный оператор &mdash; вычисляют выражение в булевом контексте (<a href="chapter_01.html#context_philosophy">Контекст</a>). В то время как операторы сравнения, такие как <code>eq</code>, <code>==</code>, <code>ne</code> и <code>!=</code>, возвращают булевы значения при их вычислении, результаты других выражений &mdash; включая переменные и значения &mdash; Perl преобразует в булевы формы.</p>

<p>В Perl 5 нет единого истинного значения, как и единого ложного. Любое число, преобразуемое в 0, ложно. Это относится к <code>0</code>, <code>0.0</code>, <code>0e0</code>, <code>0x0</code> и т. д. Пустая строка (<code>''</code>) и <code>'0'</code> преобразуются в ложное значение, но строки <code>'0.0'</code>, <code>'0e0'</code> и т. д. &mdash; нет. Идиома <code>'0 but true'</code> преобразуется в 0 в числовом контексте, но истинно в булевом контексте, благодаря своему строковому содержанию.</p>

<p>Пустой список и <code>undef</code> преобразуются в ложное значение. Пустые массивы и хеши возвращают число 0 в скалярном контексте, поэтому в булевом контексте преобразуются в ложь. Массив, содержащий хотя бы один элемент, пусть даже <code>undef</code>, преобразуется в истину в булевом контексте. Хеш, содержащий хотя бы один элемент, даже если и ключ, и значение &mdash; <code>undef</code>, преобразуется в истинное значение в булевом контексте.</p>

<p> </p>

<p>Модуль <code>Want</code> из CPAN позволяет вам определять булев контекст с помощью своих собственных функций. Встроенная прагма <code>overloading</code> (<a href="chapter_09.html#overloading">Перегрузка</a>) позволяет вам указать, что ваши собственные типы данных возвращают при вычислении в разных контекстах.</p>

<h3>Директивы циклов</h3>

<p><a name="looping_directives"></p>

<p> </p>

<p>Perl предоставляет несколько директив для организации циклов и итераций. Цикл в стиле <em>foreach</em> вычисляет выражение, возвращающее список, и выполняет инструкцию или блок, пока не израсходует весь этот список:</p>

<pre><code>    foreach (1 .. 10)
    {
        say &quot;$_ * $_ = &quot;, $_ * $_;
    }</code></pre>

<p>Этот пример использует оператор диапазона для генерации списка целых чисел от единицы до десяти включительно. Директива <code>foreach</code> циклически проходит по ним, устанавливая переменную-топик <code>$_</code> (<a href="chapter_01.html#default_scalar_variable">Подразумеваемая переменная-скаляр</a>) в каждое из них по очереди. Perl выполняет блок для каждого целого числа и выводит их квадраты.</p>

<p> </p>

<p>Многие Perl-программисты подразумевают под итерациями циклы <code>foreach</code>, но Perl считает имена <code>foreach</code> и <code>for</code> взаимозаменяемыми. Последующий код определяет тип и поведение цикла.</p>

<p>Как и <code>if</code> и <code>unless</code>, этот цикл имеет постфиксную форму:</p>

<pre><code>    say &quot;$_ * $_ = &quot;, $_ * $_ for 1 .. 10;</code></pre>

<p>Цикл <code>for</code> может использовать именованную переменную вместо переменной-топика:</p>

<pre><code>    for my $i (1 .. 10)
    {
        say &quot;$i * $i = &quot;, $i * $i;
    }</code></pre>

<p>Когда цикл <code>for</code> использует переменную-итератор, область видимости этой переменной &mdash; <em>внутри</em> цикла. Perl будет назначать этой лексической переменной значение каждого элемента итерации. Perl не будет модифицировать переменную-топик (<code>$_</code>). Если вы объявили лексическую переменную <code>$i</code> во внешней области видимости, её значение сохранится снаружи цикла:</p>

<pre><code>    my $i = &#39;cow&#39;;

    for my $i (1 .. 10)
    {
        say &quot;$i * $i = &quot;, $i * $i;
    }

    is( $i, &#39;cow&#39;, &#39;Value preserved in outer scope&#39; );</code></pre>

<p>Эта локализация происходит даже если вы не переобъявляли переменную итерации как лексическую (footnote: &mdash;однако <em>объявляйте</em> ваши переменные итераций как лексические, чтобы уменьшить их область видимости.):</p>

<pre><code>    my $i = &#39;horse&#39;;

    for $i (1 .. 10)
    {
        say &quot;$i * $i = &quot;, $i * $i;
    }

    is( $i, &#39;horse&#39;, &#39;Value preserved in outer scope&#39; );</code></pre>

<h3>Итерации и псевдонимы</h3>

<p>  </p>

<p>Цикл <code>for</code> создаёт переменную-итератор как <em>псевдоним</em> для значения в итерации, так что любые модификации значения итератора сразу же изменяют исходное значение:</p>

<pre><code>    my @nums = 1 .. 10;

    $_ **= 2 for @nums;

    is( $nums[0], 1, &#39;1 * 1 is 1&#39; );
    is( $nums[1], 4, &#39;2 * 2 is 4&#39; );

    ...

    is( $nums[9], 100, &#39;10 * 10 is 100&#39; );</code></pre>

<p>Создание псевдонимов также работает с блочным стилем цикла <code>for</code>:</p>

<pre><code>    for my $num (@nums)
    {
        $num **= 2;
    }</code></pre>

<p>&hellip;как и в итерациях с переменной-топиком:</p>

<pre><code>    for (@nums)
    {
        $_ **= 2;
    }</code></pre>

<p>Однако, вы не можете использовать псевдонимы для изменения значения <em>констант</em>:</p>

<pre><code>    for (qw( Huex Dewex Louid ))
    {
        $_++;
        say;
    }</code></pre>

<p>Вместо этого Perl выбросит исключение о модификации значения, предназначенного только для чтения.</p>

<p>Иногда вы можете увидеть использование цикла <code>for</code> с единственной скалярной переменной, для создания псевдонима этой переменной в <code>$_</code>:</p>

<pre><code>    for ($user_input)
    {
        s/\A\s+//;      # &#x443;&#x434;&#x430;&#x43B;&#x438;&#x442;&#x44C; &#x432;&#x435;&#x434;&#x443;&#x449;&#x438;&#x435; &#x43F;&#x440;&#x43E;&#x431;&#x435;&#x43B;&#x44B;
        s/\s+\z//;      # &#x443;&#x434;&#x430;&#x43B;&#x438;&#x442;&#x44C; &#x437;&#x430;&#x432;&#x435;&#x440;&#x448;&#x430;&#x44E;&#x449;&#x438;&#x435; &#x43F;&#x440;&#x43E;&#x431;&#x435;&#x43B;&#x44B;

        $_ = quotemeta; # &#x44D;&#x43A;&#x440;&#x430;&#x43D;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x442;&#x44C; &#x441;&#x438;&#x43C;&#x432;&#x43E;&#x43B;&#x44B;, &#x43D;&#x435; &#x44F;&#x432;&#x43B;&#x44F;&#x44E;&#x449;&#x438;&#x435;&#x441;&#x44F; &#x441;&#x43B;&#x43E;&#x432;&#x430;&#x440;&#x43D;&#x44B;&#x43C;&#x438; &#x441;&#x438;&#x43C;&#x432;&#x43E;&#x43B;&#x430;&#x43C;&#x438;
    }</code></pre>

<h3>Итерации и область видимости</h3>

<p>   </p>

<p>Учёт области видимости итератора в случае переменной-топика создаёт общий источник путаницы. Рассмотрим функцию <code>topic_mangler()</code>, целенаправленно модифицирующую <code>$_</code>. Если код, итерирующий по списку, вызывает <code>topic_mangler()</code>, не защитив <code>$_</code>, весёлая отладка гарантированна:</p>

<pre><code>    for (@values)
    {
        topic_mangler();
    }

    sub topic_mangler
    {
        s/foo/bar/;
    }</code></pre>

<p>Если вам <em>приходится</em> использовать <code>$_</code> вместо именованной переменной, сделайте переменную-топик лексической с помощью объявления <code>my $_</code>:</p>

<pre><code>    sub topic_mangler
    {
        # &#x431;&#x44B;&#x43B;&#x43E; $_ = shift;
        <strong>my</strong> $_ = shift;

        s/foo/bar/;
        s/baz/quux/;

        return $_;
    }</code></pre>

<p>Использование именованной переменной итерации также предотвращает нежелательное создание псевдонима в <code>$_</code>.</p>

<h3>Цикл for в стиле C</h3>

<p></p>

<p>Цикл <code>for</code> в стиле C требует управления условиями итерации:</p>

<pre><code>    for (my $i = 0; $i &lt;= 10; $i += 2)
    {
        say &quot;$i * $i = &quot;, $i * $i;
    }</code></pre>

<p>Вы должны явно назначить значение итерационной переменной в конструкции цикла, так как этот цикл не выполняет ни создания псевдонима, ни присвоения переменной-топику. Хотя все переменные, объявленные в конструкции цикла, имеют лексическую область видимости в блоке цикла, переменные, объявленные снаружи конструкции цикла, не локализуются:</p>

<pre><code>    my $i = &#39;pig&#39;;

    for ($i = 0; $i &lt;= 10; $i += 2)
    {
        say &quot;$i * $i = &quot;, $i * $i;
    }

    isnt( $i, &#39;pig&#39;, &#39;$i overwritten with a number&#39; );</code></pre>

<p>Конструкция цикла может иметь три подвыражения. Первое подвыражение &mdash; секция инициализации &mdash; выполняется только один раз, перед выполнением тела цикла. Perl вычисляет второе подвыражение &mdash; условное сравнение &mdash; перед каждой итерацией тела цикла. Если оно возвращает истинное значение, выполняется итерация. Если оно возвращает ложное значение, итерация прекращается. Последнее подвыражение выполняется после каждой итерации тела цикла.</p>

<pre><code>    for (
        # &#x43F;&#x43E;&#x434;&#x432;&#x44B;&#x440;&#x430;&#x436;&#x435;&#x43D;&#x438;&#x435; &#x438;&#x43D;&#x438;&#x446;&#x438;&#x430;&#x43B;&#x438;&#x437;&#x430;&#x446;&#x438;&#x438; &#x446;&#x438;&#x43A;&#x43B;&#x430;
        say &#39;Initializing&#39;, my $i = 0;

        # &#x43F;&#x43E;&#x434;&#x432;&#x44B;&#x440;&#x430;&#x436;&#x435;&#x43D;&#x438;&#x435; &#x443;&#x441;&#x43B;&#x43E;&#x432;&#x43D;&#x43E;&#x433;&#x43E; &#x441;&#x440;&#x430;&#x432;&#x43D;&#x435;&#x43D;&#x438;&#x44F;
        say &quot;Iteration: $i&quot; and $i &lt; 10;

        # &#x43F;&#x43E;&#x434;&#x432;&#x44B;&#x440;&#x430;&#x436;&#x435;&#x43D;&#x438;&#x435; &#x437;&#x430;&#x432;&#x435;&#x440;&#x448;&#x435;&#x43D;&#x438;&#x44F; &#x438;&#x442;&#x435;&#x440;&#x430;&#x446;&#x438;&#x438;
        say &#39;Incrementing &#39; . $i++
    )
    {
        say &quot;$i * $i = &quot;, $i * $i;
    }</code></pre>

<p>Обратите внимание на отсутствие точки с запятой после последнего подвыражения, а также на использование оператора запятой и низкоприоритетного <code>and</code>; этот синтаксис на удивление привередлив. По возможности, предпочтите использование цикла в стиле <code>foreach</code>, а не <code>for</code>.</p>

<p>Все три подвыражения необязательны. Бесконечный цикл <code>for</code> может выглядеть так:</p>

<pre><code>    for (;;) { ... }</code></pre>

<h3>While и Until</h3>

<p></p>

<p>Цикл <em>while</em> продолжается до тех пор, пока условие цикла не вернёт ложное булево значение. Идиоматический бесконечный цикл выглядит так:</p>

<pre><code>    while (1) { ... }</code></pre>

<p>В отличие от итерации в цикле стиля <code>foreach</code>, условие цикла <code>while</code> само по себе не имеет побочных эффектов. То есть, если <code>@values</code> содержит один или несколько элементов, этот код тоже будет бесконечным циклом:</p>

<pre><code>    while (@values)
    {
        say $values[0];
    }</code></pre>

<p></p>

<p>Чтобы предотвратить подобный бесконечный цикл <code>while</code>, используйте <em>деструктивное изменение</em> массива <code>@values</code>, модифицируя массив на каждой итерации цикла:</p>

<pre><code>    while (@values)
    {
        my $value = shift @values;
        say $value;
    }</code></pre>

<p>Модификация <code>@values</code> внутри условия <code>while</code> тоже работает, но имеет ряд тонкостей, связанных с истинностью каждого значения.</p>

<pre><code>    while (my $value = shift @values)
    {
        say $value;
    }</code></pre>

<p>Этот цикл прекратится, как только он достигнет элемента, являющегося ложным значением, а не обязательно, когда весь массив будет израсходован. Это может быть ожидаемым поведением, но часто удивляет новичков.</p>

<p></p>

<p>Цикл <em>until</em> меняет на противоположный смысл проверки цикла <code>while</code>. Итерация продолжается, пока условное выражение цикла возвращает ложное значение:</p>

<pre><code>    until ($finished_running)
    {
        ...
    }</code></pre>

<p>Каноническое использование цикла <code>while</code> &mdash; итерация по входным данным из дескриптора файла:</p>

<pre><code>    use autodie;

    open my $fh, &#39;&lt;&#39;, $file;

    while (&lt;$fh&gt;)
    {
        ...
    }</code></pre>

<p>Perl 5 интерпретирует этот цикл <code>while</code> как если бы вы написали:</p>

<pre><code>    while (defined($_ = &lt;$fh&gt;))
    {
        ...
    }</code></pre>

<p>Без явного <code>defined</code>, любая строка, прочитанная из дескриптора файла, которая в скалярном контексте даёт ложное значение &mdash; пустая строка, или строка, содержащая один только символ <code>0</code> &mdash; завершит цикл. Оператор <code>readline</code> (<code><></code>) возвращает неопределённое значение только когда достигает конца файла.</p>

<p></p>

<p>Используйте встроенную функцию <code>chomp</code> для удаления символов конца строки из каждой строчки. Многие новички забывают это делать.</p>

<p>И <code>while</code>, и <code>until</code> имеют постфиксные формы, такие как бесконечный цикл <code>1 while 1;</code>. Любое одиночное выражение годится для постфиксной формы <code>while</code> или <code>until</code>, включая классический пример &laquo;Hello, world!&raquo; из 8-битных компьютеров ранних 1980-ых:</p>

<pre><code>    print &quot;Hello, world!  &quot; while 1;</code></pre>

<p>Бесконечные циклы более полезны, чем кажется на первый взгляд, особенно для петель событий в программах с графическим интерфейсом, интерпретаторах или сетевых серверах:</p>

<pre><code>    $server-&gt;dispatch_results() until $should_shutdown;</code></pre>

<p></p>

<p>Используйте блок <code>do</code>, чтобы сгруппировать несколько выражений воедино:</p>

<pre><code>    do
    {
        say &#39;What is your name?&#39;;
        my $name = &lt;&gt;;
        chomp $name;
        say &quot;Hello, $name!&quot; if $name;
    } until (eof);</code></pre>

<p>Блок <code>do</code> воспринимается парсером как единое выражение, которое может содержать несколько других выражений. В отличие от блочной формы цикла <code>while</code>, блок <code>do</code> с постфиксным <code>while</code> или <code>until</code> выполнит своё тело хотя бы раз. Эта конструкция менее распространена, чем другие формы циклов, но не менее действенна.</p>

<h3>Циклы внутри циклов</h3>

<p></p>

<p>Вы можете вкладывать циклы друг в друга:</p>

<pre><code>    for my $suit (@suits)
    {
        for my $values (@card_values) { ... }
    }</code></pre>

<p>Когда вы это делаете, объявляйте именованные итерационные переменные! В противном случае вероятность возникновения путаницы с переменной-топиком и её областью видимости слишком высока.</p>

<p>Распространённая ошибка при вложении циклов <code>foreach</code> и <code>while</code> заключается в том, что легко израсходовать дескриптор файла в цикле <code>while</code>:</p>

<pre><code>    use autodie;

    open my $fh, &#39;&lt;&#39;, $some_file;

    for my $prefix (@prefixes)
    {
        # &#x41D;&#x415; &#x418;&#x421;&#x41F;&#x41E;&#x41B;&#x42C;&#x417;&#x423;&#x419;&#x422;&#x415;; &#x441; &#x431;&#x43E;&#x43B;&#x44C;&#x448;&#x43E;&#x439; &#x432;&#x435;&#x440;&#x43E;&#x44F;&#x442;&#x43D;&#x43E;&#x441;&#x442;&#x44C;&#x44E; &#x43E;&#x448;&#x438;&#x431;&#x43E;&#x447;&#x43D;&#x44B;&#x439; &#x43A;&#x43E;&#x434;
        while (&lt;$fh&gt;)
        {
            say $prefix, $_;
        }
    }</code></pre>

<p>Открытие дескриптора файла снаружи цикла <code>for</code> сохраняет позицию в файле между итерациями цикла <code>for</code>. На его второй итерации циклу <code>while</code> будет нечего читать, и он не будет выполнен. Чтобы разрешить эту проблему, переоткрывайте файл внутри цикла <code>for</code> (просто для понимания, но не всегда хорошее использование системных ресурсов), считайте весь файл в память (что может не сработать, если файл большой) или сбрасывайте дескриптор файла назад к началу файла на каждой итерации с помощью функции <code>seek</code> (опция, которую зачастую упускают):</p>

<pre><code>    use autodie;

    open my $fh, &#39;&lt;&#39;, $some_file;

    for my $prefix (@prefixes)
    {
        while (&lt;$fh&gt;)
        {
            say $prefix, $_;
        }

        seek $fh, 0, 0;
    }</code></pre>

<h3>Контроль циклов</h3>

<p></p>

<p>Иногда вам нужно разорвать цикл раньше, чем условия итерации будут исчерпаны. Стандартные механизмы управления Perl 5 &mdash; исключения и <code>return</code> &mdash; работают, но кроме того вы можете использовать операторы <em>контроля цикла</em>.</p>

<p></p>

<p>Оператор <em>next</em> перезапускает цикл со следующей его итерации. Используйте его, если вы сделали всё, что нужно, в текущей итерации. Для цикла по строкам в файле с пропуском любой строки, начинающейся с символа комментария <code>#</code>, напишите:</p>

<pre><code>    while (&lt;$fh&gt;)
    {
        <strong>next</strong> if /\A#/;
        ...
    }</code></pre>

<p>Сравните использование <code>next</code> с альтернативой: заворачивание оставшейся части тела блока в <code>if</code>. Представьте, что произойдёт, если у вас есть несколько условий, которые могут вызвать пропуск строки. Модификатры контроля цикла с постфиксными условиями могут сделать ваш код намного более читабельным.</p>

<p></p>

<p>Оператор <em>last</em> немедленно завершает цикл. Чтобы закончить обработку файла, как только вы достигли признака завершения, напишите:</p>

<pre><code>    while (&lt;$fh&gt;)
    {
        next if /\A#/;
        <strong>last</strong> if /\A__END__/
        ...
    }</code></pre>

<p></p>

<p>Оператор <em>redo</em> перезапускает текущую итерацию без повторного вычисления условия. Это может быть полезно в тех немногих случаях, когда вы хотите сразу же изменить прочитанную строку, а затем начать обработку с начала, не затирая её следующей строкой. Так можно реализовать простой парсер файла, который объединяет строки, завершающиеся обратным слешем:</p>

<pre><code>    while (my $line = &lt;$fh&gt;)
    {
        chomp $line;

        # &#x43F;&#x43E;&#x438;&#x441;&#x43A; &#x43E;&#x431;&#x440;&#x430;&#x442;&#x43D;&#x43E;&#x433;&#x43E; &#x441;&#x43B;&#x435;&#x448;&#x430; &#x432; &#x43A;&#x43E;&#x43D;&#x446;&#x435; &#x441;&#x442;&#x440;&#x43E;&#x43A;&#x438;
        if ($line =~ s{\\$}{})
        {
            $line .= &lt;$fh&gt;;
            chomp $line;
            redo;
        }

        ...
    }</code></pre>

<p></p>

<p>Использование операторов контроля цикла во вложенных списках может сбивать с толку. Если вы не можете избежать вложенных циклов &mdash; выделив внутренние циклы в именованные функции &mdash; используйте <em>метку цикла</em> для прояснения:</p>

<pre><code>    LINE:
    while (&lt;$fh&gt;)
    {
        chomp;

        PREFIX:
        for my $prefix (@prefixes)
        {
            next LINE unless $prefix;
            say &quot;$prefix: $_&quot;;
            # &#x437;&#x434;&#x435;&#x441;&#x44C; &#x43F;&#x43E;&#x434;&#x440;&#x430;&#x437;&#x443;&#x43C;&#x435;&#x432;&#x430;&#x435;&#x442;&#x441;&#x44F; next PREFIX
        }
    }</code></pre>

<h3>Continue</h3>

<p></p>

<p>Конструкция <code>continue</code> ведёт себя как третье подвыражение цикла <code>for</code>; Perl выполняет её блок перед следующей итерацией цикла, как при нормальном повторении цикла, так и при преждевременном повторе итерации с помощью <code>next</code> (footnote: Эквивалент <code>continue</code> языка C в Perl &mdash; это <code>next</code>.). Вы можете использовать её с циклами <code>while</code>, <code>until</code>, <code>when</code> или <code>for</code>. Примеры употребления <continue> редки, но она полезна, если вам нужна гарантия того, что нечто произойдёт на каждой итерации цикла, независимо от того, как заканчивается итерация:</p>

<pre><code>    while ($i &lt; 10 )
    {
        next unless $i % 2;
        say $i;
    }
    continue
    {
        say &#39;Continuing...&#39;;
        $i++;
    }</code></pre>

<p>Имейте ввиду, что блок <code>continue</code> <em>не</em> выполняется, когда поток управления выходит из цикла вследствие срабатывания <code>last</code> или <code>redo</code>.</p>

<h3>given/when</h3>

<p><a name="given_when"></p>

<p></p>

<p>Конструкция <code>given</code> &mdash; новая возможность Perl 5.10. Она присваивает значение выражения переменной-топику и предваряет блок:</p>

<pre><code>    given ($name) { ... }</code></pre>

<p>В отличие от <code>for</code>, она не итерирует по агрегатной переменной. Она вычисляет своё выражение в скалярном контексте и всегда осуществляет присваивание переменной-топику:</p>

<pre><code>    given (my $username = find_user())
    {
        is( $username, $_, &#39;topic auto-assignment&#39; );
    }</code></pre>

<p><code>given</code> также локализует переменную-топик:</p>

<pre><code>    given (&#39;mouse&#39;)
    {
        say;
        mouse_to_man( $_ );
        say;
    }

    sub mouse_to_man { s/mouse/man/ }</code></pre>

<p> </p>

<p><code>given</code> наиболее полезна при использовании совместно с <code>when</code> (<a href="chapter_06.html#smart_match">Умное сопоставление</a>). <code>given</code> <em>топикализирует</em> значение внутри блока, так что несколько инструкций <code>when</code> могут проверять соответствие топика выражениям, используя семантику <em>умного сопоставления</em>. Так можно написать игру &laquo;камень, ножницы, бумага&raquo;.</p>

<pre><code>    my @options  = ( \&amp;rock, \&amp;paper, \&amp;scissors );
    my $confused = &quot;I don&#39;t understand your move.&quot;;

    do
    {
        say &quot;Rock, Paper, Scissors!  Pick one: &quot;;
        chomp( my $user = &lt;STDIN&gt; );
        my $computer_match = $options[ rand @options ];
        $computer_match-&gt;( lc( $user ) );
    } until (eof);

    sub rock
    {
        print &quot;I chose rock.  &quot;;

        given (shift)
        {
            when (/paper/)    { say &#39;You win!&#39; };
            when (/rock/)     { say &#39;We tie!&#39;  };
            when (/scissors/) { say &#39;I win!&#39;   };
            default           { say $confused  };
        }
    }

    sub paper
    {
        print &quot;I chose paper.  &quot;;

        given (shift)
        {
            when (/paper/)    { say &#39;We tie!&#39;  };
            when (/rock/)     { say &#39;I win!&#39;   };
            when (/scissors/) { say &#39;You win!&#39; };
            default           { say $confused  };
        }
    }

    sub scissors
    {
        print &quot;I chose scissors.  &quot;;

        given (shift)
        {
            when (/paper/)    { say &#39;I win!&#39;   };
            when (/rock/)     { say &#39;You win!&#39; };
            when (/scissors/) { say &#39;We tie!&#39;  };
            default           { say $confused  };
        }
    }</code></pre>

<p>Perl выполняет правило <code>default</code>, если ни одно из других условий не подошло.</p>

<p></p>

<p>CPAN-модуль <code>MooseX::MultiMethods</code> предоставляет другую технику для упрощения этого кода.</p>

<h3>Хвостовые вызовы</h3>

<p><a name="tailcalls"> </p>

<p><em>Хвостовой вызов</em> происходит, когда последнее выражение в функции &mdash; вызов другой функции: возвращаемое значение внутренней функции будет возвращаемым значением внешней функции:</p>

<pre><code>    sub log_and_greet_person
    {
        my $name = shift;
        log( &quot;Greeting $name&quot; );

        return greet_person( $name );
    }</code></pre>

<p>Возврат из <code>green_person()</code> напрямую в код, вызывающий <code>log_and_greet_person()</code>, более эффективен, чем возврат <em>в</em> <code>log_and_greet_person()</code> и сразу же возврат <em>из</em> <code>log_and_greet_person()</code>. Возврат напрямую <em>из</em> <code>greet_person()</code> в код, вызывающий <code>log_and_greet_person()</code> &mdash; <em>оптимизация хвостового вызова</em>.</p>

<p>Код с тяжёлой рекурсией (<a href="chapter_05.html#recursion">Рекурсия</a>), особенно взаимнорекурсивный код, может потреблять много памяти. Хвостовые вызовы уменьшают количество памяти, требуемое для внутренней организации потока управления, и делают дорогие алгоритмы легко обрабатываемыми. К сожалению, Perl 5 не выполняет эту автоматизацию автоматически; вы должны сделать это сами, если необходимо.</p>

<p></p>

<p>Встроенный оператор <code>goto</code> имеет форму, которая вызывает функцию, как если бы текущая функция никогда не была вызвана, по существу, обнуляя управление ресурсами для вызова новой функции. Уродливый синтаксис смущает людей, на слуху у которых &laquo;никогда не используйте <code>goto</code>&raquo;, но это работает:</p>

<pre><code>    sub log_and_greet_person
    {
        <strong>my ($name) = @_;</strong>
        log( &quot;Greeting $name&quot; );

        <strong>goto &amp;greet_person</strong>;
    }</code></pre>

<p>Этот пример имеет две важных особенности. Во-первых, <code>goto &function_name</code> или <code>goto &$function_reference</code> требует использования сигила функции (<code>&</code>), чтобы парсер знал, что нужно выполнить хвостовой вызов вместо перехода к метке. Во-вторых, эта форма вызова функции неявно передаёт содержимое <code>@_</code> в вызываемую функцию. Вы можете модифицировать <code>@_</code> для изменения передаваемых аргументов.</p>

<p>Эта техника относительно редка; она наиболее полезна, когда вы хотите вмешаться в поток управления, чтобы убраться с пути других функций, проверяющих <code>caller</code> (например, если вы реализуете специальное логирование или какую-нибудь возможность отладки), или когда используете алгоритм, требующий большого количества рекурсии.</p>

<h2>Скаляры</h2>

<p><a name="scalars"></p>

<p>  </p>

<p>Основной тип данных Perl 5 &mdash; это <em>скаляр</em>, одиночное, отдельное значение. Значение может быть строкой, целым числом, значением с плавающей точкой, дескриптором файла или ссылкой &mdash; но это всегда одиночное значение. Скаляры могут быть лексическими переменными, переменными пакета или глобальными (<a href="chapter_10.html#globals">Глобальные переменные</a>) переменными. Вы можете объявлять только лексические переменные и переменные пакетов. Имена скалярных переменных должны соответствовать стандартным правилам именования переменных (<a href="chapter_03.html#names">Имена</a>). Скалярные переменные всегда начинаются с сигила (<a href="chapter_03.html#sigils">Сигилы переменных</a>) в виде знака доллара (<code>$</code>).</p>

<p>Скалярные значения и скалярный контекст имеют глубокую связь; присваивание скаляру создаёт скалярный контекст. Использование скалярного сигила с агрегатной переменной налагает скалярный контекст для доступа к единственному элементу хеша или массива.</p>

<h3>Скаляры и типы</h3>

<p>Скалярная переменная может содержать любой тип скалярного значения без специальной конвертации или приведения, и тип значения, сохранённого в переменной, может меняться:</p>

<pre><code>    my $value;
    $value = 123.456;
    $value = 77;
    $value = &quot;I am Chuck&#39;s big toe.&quot;;
    $value = Store::IceCream-&gt;new();</code></pre>

<p>Хотя этот код <em>допустим</em>, изменение типа данных, сохраняемых в скаляре, &mdash; признак беспорядка.</p>

<p>Эта гибкость типов часто приводит к приведению типа значения (<a href="chapter_03.html#coercion">Приведение типов</a>). Например, вы можете обращаться с содержимым скаляра как со строкой, даже если вы явно не назначали ему строку:</p>

<pre><code>    my $zip_code       = 97006;
    my $city_state_zip = &#39;Beaverton, Oregon&#39; . &#39; &#39; . $zip_code;</code></pre>

<p>Также вы можете производить математические операции над строками:</p>

<pre><code>    my $call_sign = &#39;KBMIU&#39;;

    # &#x43E;&#x431;&#x43D;&#x43E;&#x432;&#x438;&#x442;&#x44C; &#x437;&#x43D;&#x430;&#x43A; &#x438; &#x432;&#x435;&#x440;&#x43D;&#x443;&#x442;&#x44C; &#x43D;&#x43E;&#x432;&#x43E;&#x435; &#x437;&#x43D;&#x430;&#x447;&#x435;&#x43D;&#x438;&#x435;
    my $next_sign = ++$call_sign;

    # &#x432;&#x435;&#x440;&#x43D;&#x443;&#x442;&#x44C; &#x441;&#x442;&#x430;&#x440;&#x43E;&#x435; &#x437;&#x43D;&#x430;&#x447;&#x435;&#x43D;&#x438;&#x435;, <em>&#x437;&#x430;&#x442;&#x435;&#x43C;</em> &#x43E;&#x431;&#x43D;&#x43E;&#x432;&#x438;&#x442;&#x44C; &#x437;&#x43D;&#x430;&#x43A;
    my $curr_sign = $call_sign++;

    # &#x43D;&#x43E; <em>&#x43D;&#x435; &#x440;&#x430;&#x431;&#x43E;&#x442;&#x430;&#x435;&#x442;</em> &#x432; &#x442;&#x430;&#x43A;&#x43E;&#x43C; &#x432;&#x438;&#x434;&#x435;:
    my $new_sign  = $call_sign + 1;</code></pre>

<p></p>

<p>Это магическое поведение инкремента строки не имеет соответствующего магического поведения декремента. Вы не сможете получить предыдущее значение строки, написав <code>$call_sign--</code>.</p>

<p>Эта операция инкремента строки превращает <code>a</code> в <code>b</code> и <code>z</code> в <code>aa</code>, учитывая набор символов и регистр. В то время как <code>ZZ9</code> становится <code>AAA0</code>, <code>ZZ09</code> становится <code>ZZ10</code> &mdash; числа проворачиваются до тех пор, пока есть большие значащие цифры для инкремента, как на автомобильном одометре.</p>

<p> </p>

<p>Вычисление ссылки (<a href="chapter_03.html#references">Ссылки</a>) в строковом контексте возвращает строку. Вычисление ссылки в числовом контексте возвращает число. Ни одна из этих операций не модифицирует ссылку, но вы не сможете восстановить ссылку из любого из результатов:</p>

<pre><code>    my $authors     = [qw( Pratchett Vinge Conway )];
    my $stringy_ref = &#39;&#39; . $authors;
    my $numeric_ref =  0 + $authors;</code></pre>

<p><code>$authors</code> &mdash; всё ещё пригодная к употреблению ссылка, но <code>$stringy_ref</code> &mdash; строка, не имеющая никакой связи со ссылкой, и <code>$numeric_ref</code> &mdash; число, также не имеющее никакой связи со ссылкой.</p>

<p>  </p>

<p>Чтобы обеспечить возможность преобразования без потери данных, скаляры Perl 5 могут содержать и числовой, и строковый компоненты. Внутренняя структура данных, представляющая скаляр в Perl 5, имеет числовой слот и строковый слот. Доступ к строке в числовом контексте производит скаляр и со строковым, и с числовым значениями. Функция <code>dualvar()</code> базового модуля <code>Scalar::Util</code> позволяет вам манипулировать обоими значениями напрямую в одном скаляре.</p>

<p>       </p>

<p>Скаляры не имеют отдельного слота для булевых значений. В булевом контексте пустая строка (<code>''</code>) и <code>'0'</code> &mdash; ложны. Все остальные строки &mdash; истинны. В булевом контексте числа, равные нулю (<code>0</code>, <code>0.0</code> и <code>0e0</code>), ложны. Все остальные числа &mdash; истинны.</p>

<p>Обратите внимание, что <em>строки</em> <code>'0.0'</code> и <code>'0e0'</code> истинны; это одно из мест, где Perl 5 делает различие между тем, что выглядит как число, и что на самом деле число.</p>

<p></p>

<p>Ещё одно значение всегда ложно: <code>undef</code>. Это значение неинициализированных переменных, кроме того, оно может быть и самостоятельным значением.</p>

<h2>Массивы</h2>

<p><a name="arrays"></p>

<p>  </p>

<p><em>Массивы</em> в Perl 5 &mdash; это структуры данных <em>первого класса</em> &mdash; язык поддерживает их как встроенный тип данных &mdash; которые хранят ноль или больше скаляров. Вы можете получить доступ к отдельным элементам массива по целочисленным индексам, а также можете по желанию добавлять или удалять элементы. Сигил <code>@</code> обозначает массив. Объявить массив можно так:</p>

<pre><code>    my @items;</code></pre>

<h3>Элементы массива</h3>

<p>  </p>

<p><em>Доступ</em> к отдельному элементу массива в Perl 5 требует использования скалярного сигила. <code>$cats[0]</code> &mdash; однозначное использование массива <code>@cats</code>, потому что постфиксные (<a href="chapter_04.html#fixity">Фиксность</a>) квадратные скобки (<code>[]</code>) всегда означают доступ к массиву по индексу.</p>

<p>Первый элемент массива имеет индекс ноль:</p>

<pre><code>    # @cats &#x441;&#x43E;&#x434;&#x435;&#x440;&#x436;&#x438;&#x442; &#x441;&#x43F;&#x438;&#x441;&#x43E;&#x43A; &#x43E;&#x431;&#x44A;&#x435;&#x43A;&#x442;&#x43E;&#x432; Cat
    my $first_cat = $cats[0];</code></pre>

<p>Последний индекс массива зависит от количества элементов в нём. Массив в скалярном контексте (в скалярном присваивании, строковой конкатенации, сложении или булевом контексте) возвращает количество элементов в массиве:</p>

<pre><code>    # &#x441;&#x43A;&#x430;&#x43B;&#x44F;&#x440;&#x43D;&#x43E;&#x435; &#x43F;&#x440;&#x438;&#x441;&#x432;&#x430;&#x438;&#x432;&#x430;&#x43D;&#x438;&#x435;
    my $num_cats = @cats;

    # &#x441;&#x442;&#x440;&#x43E;&#x43A;&#x43E;&#x432;&#x430;&#x44F; &#x43A;&#x43E;&#x43D;&#x43A;&#x430;&#x442;&#x435;&#x43D;&#x430;&#x446;&#x438;&#x44F;
    say &#39;I have &#39; . @cats . &#39; cats!&#39;;

    # &#x441;&#x43B;&#x43E;&#x436;&#x435;&#x43D;&#x438;&#x435;
    my $num_animals = @cats + @dogs + @fish;

    # &#x431;&#x443;&#x43B;&#x435;&#x432; &#x43A;&#x43E;&#x43D;&#x442;&#x435;&#x43A;&#x441;&#x442;
    say &#39;Yep, a cat owner!&#39; if @cats;</code></pre>

<p> </p>

<p>Чтобы получить <em>индекс</em> последнего элемента массива, вычтите единицу из количества элементов в массиве (помните, что индексация массива начинается с 0) или испольуйте неуклюжий синтаксис <code>$#cats</code>:</p>

<pre><code>    my $first_index = 0;
    my $last_index  = @cats - 1;
    # or
    # my $last_index = $#cats;

    say   &quot;My first cat has an index of $first_index, &quot;
        . &quot;and my last cat has an index of $last_index.&quot;</code></pre>

<p>Когда индекс менее важен, чем позиция элемента, используйте взамен отрицательные индексы. Последний элемент массива доступен по индексу <code>-1</code>. Второй с конца элемент доступен по индексу <code>-2</code> и т. д.:</p>

<pre><code>    my $last_cat           = $cats[-1];
    my $second_to_last_cat = $cats[-2];</code></pre>

<p><code>$#</code> имеет другое применение: изменение размера массива путём <em>присваивания</em> ему. Помните, что массивы в Perl 5 могут изменяться. Они расширяются или сокращаются по необходимости. Если вы сжимаете массив, Perl отбросит значения, не помещающиеся в массив с изменённым размером. Если вы расширяете массив, Perl заполнит добавленные позиции значением <code>undef</code>.</p>

<h3>Присваивание массивам</h3>

<p>Присваивайте отдельной позиции в массиве напрямую, используя индекс:</p>

<pre><code>    my @cats;
    $cats[3] = &#39;Jack&#39;;
    $cats[2] = &#39;Tuxedo&#39;;
    $cats[0] = &#39;Daisy&#39;;
    $cats[1] = &#39;Petunia&#39;;
    $cats[4] = &#39;Brad&#39;;
    $cats[5] = &#39;Choco&#39;;</code></pre>

<p>Если вы присвоите индексу, выходящему за пределы текущего размера массива, Perl расширит массив для соответсвия новому размеру и заполнит все промежуточные позиции значением <code>undef</code>. После первого присвоения массив будет содержать <code>undef</code> в позициях 0, 1 и 2, и <code>Jack</code> в позиции 3.</p>

<p>Для сокращения присваивания, инициализируйте массив из списка:</p>

<pre><code>    my @cats = ( &#39;Daisy&#39;, &#39;Petunia&#39;, &#39;Tuxedo&#39;, ... );</code></pre>

<p>&hellip;но помните, что эти скобки <em>не</em> создают список. Без скобок произошло бы присваивание <code>Daisy</code> первому и единственному элементу массива, ввиду приоритета операторов (<a href="chapter_04.html#precedence">Приоритет</a>).</p>

<p>Любое выражение, возвращающее список в списочном контексте, может быть присвоено массиву:</p>

<pre><code>    my @cats     = get_cat_list();
    my @timeinfo = localtime();
    my @nums     = 1 .. 10;</code></pre>

<p>Присваивание скалярному элементу массива налагает скалярный контекст, тогда как присваивание всему массиву целиком налагает списочный контекст.</p>

<p>Чтобы очистить массив, присвойте ему пустой список:</p>

<pre><code>    my @dates = ( 1969, 2001, 2010, 2051, 1787 );
    ...
    @dates    = ();</code></pre>

<p><code>my @items = ();</code> &mdash; более длинная и зашумлённая версия <code>my @items</code>, потому что свежеобъявленные массивы создаются пустыми.</p>

<h3>Операции над массивами</h3>

<p>Иногда массив удобнее использовать как упорядоченную, изменяемую коллекцию элементов, чем соответствие индексов значениям. Perl 5 предоставляет несколько операций для манипулирования элементами массива без использования индексов:</p>

<p>   </p>

<p>Операторы <code>push</code> и <code>pop</code> добавляют и удаляют элементы из конца массива соответственно:</p>

<pre><code>    my @meals;

    # &#x447;&#x442;&#x43E; &#x435;&#x441;&#x442;&#x44C; &#x441;&#x44A;&#x435;&#x434;&#x43E;&#x431;&#x43D;&#x43E;&#x433;&#x43E;?
    push @meals, qw( hamburgers pizza lasagna turnip );

    # &hellip;&#x43D;&#x43E; &#x432;&#x430;&#x448; &#x43F;&#x43B;&#x435;&#x43C;&#x44F;&#x43D;&#x43D;&#x438;&#x43A; &#x442;&#x435;&#x440;&#x43F;&#x435;&#x442;&#x44C; &#x43D;&#x435; &#x43C;&#x43E;&#x436;&#x435;&#x442; &#x43E;&#x432;&#x43E;&#x449;&#x438;
    pop @meals;</code></pre>

<p>Вы можете добавить в массив список значений с помощью <code>push</code>, но с помощью <code>pop</code> можете удалить только один за раз. <code>push</code> возвращает новое количество элементов в массиве. <code>pop</code> возвращает удалённый элемент.</p>

<p>Поскольку <code>push</code> оперирует списками, вы легко можете добавить элементы одного или нескольких массивов в другой:</p>

<pre><code>    push @meals, @breakfast, @lunch, @dinner;</code></pre>

<p>   </p>

<p>Аналогично, <code>unshift</code> и <code>shift</code> добавляют элементы или удаляют элемент из начала массива соответственно:</p>

<pre><code>    # &#x440;&#x430;&#x441;&#x448;&#x438;&#x440;&#x438;&#x442;&#x44C; &#x43D;&#x430;&#x448;&#x438; &#x43A;&#x443;&#x43B;&#x438;&#x43D;&#x430;&#x440;&#x43D;&#x44B;&#x435; &#x433;&#x43E;&#x440;&#x438;&#x437;&#x43E;&#x43D;&#x442;&#x44B;
    unshift @meals, qw( tofu spanakopita taquitos );

    # &#x43F;&#x435;&#x440;&#x435;&#x441;&#x43C;&#x43E;&#x442;&#x440;&#x438;&#x43C; &#x432;&#x441;&#x44E; &#x44D;&#x442;&#x443; &#x438;&#x434;&#x435;&#x44E; &#x441; &#x441;&#x43E;&#x435;&#x439;
    shift @meals;</code></pre>

<p><code>unshift</code> вставляет список элементов в начало массива и возвращает новое количество элементов в массиве. <code>shift</code> удаляет и возвращает первый элемент массива.</p>

<p>Немногие программы используют возвращаемые значения <code>push</code> и <code>unshift</code>.</p>

<p> </p>

<p>Оператор <code>splice</code> удаляет и заменяет элементы в массиве в соответствии с заданным смещением, длинной вырезаемого списка и списком для замены. И замена, и удаление &mdash; опциональны; вы можете опустить любое из этих поведений. Описание <code>splice</code> в <code>perlfunc</code> демонстрирует его равноценность с <code>push</code>, <code>pop</code>, <code>shift</code> и <code>unshift</code>. Одно из возможных применений &mdash; удаление двух элементов из массива:</p>

<pre><code>    my ($winner, $runnerup) = splice @finalists, 0, 2;

    # &#x438;&#x43B;&#x438;
    my $winner              = shift @finalists;
    my $runnerup            = shift @finalists;</code></pre>

<p> </p>

<p>До Perl 5.12 итерация по массиву с использованием индекса требовала цикла в стиле C. Начиная с Perl 5.12, <code>each</code> может итерировать по массиву по индексу и значению:</p>

<pre><code>    while (my ($index, $value) = each @bookshelf)
    {
        say &quot;#$index: $value&quot;;
        ...
    }</code></pre>

<h3>Срезы массивов</h3>

<p><a name="array_slices"></p>

<p>   </p>

<p><em>Срез массива</em> позволяет вам получить доступ к элементам массива в списочном контексте. В отличие от скалярного доступа к элементу массива, эта операция принимает список из ноля или более индексов и использует сигил массива (<code>@</code>):</p>

<pre><code>    my @youngest_cats = @cats[-1, -2];
    my @oldest_cats   = @cats[0 .. 2];
    my @selected_cats = @cats[ @indexes ];</code></pre>

<p>Срезы массивов удобны для присваивания:</p>

<pre><code>    @users[ @replace_indices ] = @replace_users;</code></pre>

<p>Срез может содержать ноль или более элементов &mdash; включая один:</p>

<pre><code>    # &#x43E;&#x434;&#x43D;&#x43E;&#x44D;&#x43B;&#x435;&#x43C;&#x435;&#x43D;&#x442;&#x43D;&#x44B;&#x439; &#x441;&#x440;&#x435;&#x437; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432;&#x430;; <em>&#x441;&#x43F;&#x438;&#x441;&#x43E;&#x447;&#x43D;&#x44B;&#x439;</em> &#x43A;&#x43E;&#x43D;&#x442;&#x435;&#x43A;&#x441;&#x442;
    @cats[-1] = get_more_cats();

    # &#x434;&#x43E;&#x441;&#x442;&#x443;&#x43F; &#x43A; &#x43E;&#x434;&#x43D;&#x43E;&#x43C;&#x443; &#x44D;&#x43B;&#x435;&#x43C;&#x435;&#x43D;&#x442;&#x443; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432;&#x430;; <em>&#x441;&#x43A;&#x430;&#x43B;&#x44F;&#x440;&#x43D;&#x44B;&#x439;</em> &#x43A;&#x43E;&#x43D;&#x442;&#x435;&#x43A;&#x441;&#x442;
    $cats[-1] = get_more_cats();</code></pre>

<p>Единственное синтаксическое различие между срезом массива из одного элемента и скалярным доступом к элементу массива &mdash; предшествующий сигил. <em>Семантическая</em> разница намного больше: срез массива всегда налагает списочный контекст. Срез массива, используемый в скалярном контексте, вызовет предупреждение:</p>

<pre><code>    Scalar value @cats[1] better written as $cats[1]...</code></pre>

<p>Срез массива налагает списочный контекст на выражение, используемое в качестве его индекса:</p>

<pre><code>    # &#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x44F; &#x432;&#x44B;&#x437;&#x44B;&#x432;&#x430;&#x435;&#x442;&#x441;&#x44F; &#x432; &#x441;&#x43F;&#x438;&#x441;&#x43E;&#x447;&#x43D;&#x43E;&#x43C; &#x43A;&#x43E;&#x43D;&#x442;&#x435;&#x43A;&#x441;&#x442;&#x435;
    my @hungry_cats = @cats[ get_cat_indices() ];</code></pre>

<h3>Массивы и контекст</h3>

<p></p>

<p>В списочном контексте массивы разглаживаются в списки. Если вы передадите несколько массивов нормальной функции в Perl 5, они разгладятся в единый список:</p>

<pre><code>    my @cats = qw( Daisy Petunia Tuxedo Brad Jack );
    my @dogs = qw( Rodney Lucky );

    take_pets_to_vet( @cats, @dogs );

    sub take_pets_to_vet
    {
        # &#x413;&#x41B;&#x42E;&#x427;&#x41D;&#x41E;: &#x43D;&#x435; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x442;&#x44C;!
        my (@cats, @dogs) = @_;
        ...
    }</code></pre>

<p>Внутри функции <code>@_</code> будет содержать семь элементов, не два, потому что списочное присваивание массивам обладает <em>жадностью</em>. Массив поглотит столько элементов из списка, сколько возможно. После присваивания <code>@cats</code> будет содержать <em>все</em> аргументы, переданные в функцию. <code>@dogs</code> будет пустым.</p>

<p>Это разглаживающиее поведение иногда ставит в тупик новичков, которые пытаются создать вложенные массивы в Perl 5:</p>

<pre><code>    # &#x441;&#x43E;&#x437;&#x434;&#x430;&#x451;&#x442; &#x43E;&#x434;&#x438;&#x43D; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432;, &#x43D;&#x435; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432;&#x43E;&#x432;
    my @numbers = (  1 .. 10,
                  ( 11 .. 20,
                  ( 21 .. 30 ) ) );</code></pre>

<p>&hellip;но этот код, в сущности, то же самое, что и:</p>

<pre><code>    # &#x441;&#x43E;&#x437;&#x434;&#x430;&#x451;&#x442; &#x43E;&#x434;&#x438;&#x43D; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432;, &#x43D;&#x435; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432;&#x43E;&#x432;
    my @numbers = 1 .. 30;</code></pre>

<p>&hellip;потому что скобки всего лишь группируют выражения. Они не <em>создают</em> списки в этой ситуации. Чтобы избежать этого разглаживающего поведения, используйте ссылки на массивы (<a href="chapter_03.html#array_references">Ссылки на массивы</a>).</p>

<h3>Интерполяция массивов</h3>

<p>   </p>

<p>Массивы интерполируются в строках как списки всех приведённых в строковый вид элементов, разделённых текущим значением магической глобальной переменной <code>$"</code>. Значение по умолчанию этой переменной &mdash; один пробел. Её мнемоника в <em>English.pm</em> &mdash; <code>$LIST_SEPARATOR</code>. Поэтому получаем следующее:</p>

<pre><code>    my @alphabet = &#39;a&#39; .. &#39;z&#39;;
    say &quot;[@alphabet]&quot;;
    <strong>[a b c d e f g h i j k l m</strong>
     <strong>n o p q r s t u v w x y z]</strong></code></pre>

<p>Локализуйте <code>$"</code> своим разделителем чтобы облегчить отладку (footnote: Благодарность за эту технику уходит Марку Джейсону Доминусу (Mark Jason Dominus).):</p>

<pre><code>    # &#x442;&#x430;&#x43A; &#x447;&#x442;&#x43E; &#x442;&#x430;&#x43C; &#x432; &#x44D;&#x442;&#x43E;&#x43C; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432;&#x435;?
    local $&quot; = &#39;)(&#39;;
    say &quot;(@sweet_treats)&quot;;
    <strong>(pie)(cake)(doughnuts)(cookies)(raisin bread)</strong></code></pre>

<h2>Хеши</h2>

<p><a name="hashes"></p>

<p></p>

<p><em>Хеш</em> &mdash; структура данных первого класса в Perl, которая ассоциирует строковые ключи со скалярными значениями. Так же как имя переменной соотносится с местом хранения, так и ключ в хеше ссылается на значение. Воспринимайте хеш как телефонную книгу: используйте имена ваших друзей для поиска их номеров. В других языках хеши называются <em>таблицами</em>, <em>ассоциативными массивами</em>, <em>словарями</em> или <em>картами</em>.</p>

<p>Хеши имеют два важных свойства: они хранят один скаляр на уникальный ключ, и они не имеют определённой сортировки ключей.</p>

<h3>Объявление хешей</h3>

<p><a name="declaring_hashes"></p>

<p>  </p>

<p>Хеши используют сигил <code>%</code>. Объявляются хеши так:</p>

<pre><code>    my %favorite_flavors;</code></pre>

<p>Хеши создаются пустыми. Вы можете написать <code>my %favorite_flavors = ()</code>, но это излишне.</p>

<p> </p>

<p>Хеши используют скалярный сигил <code>$</code> для доступа к отдельным элементам и фигурные скобки <code>{ }</code> для доступа по ключам:</p>

<pre><code>    my %favorite_flavors;
    $favorite_flavors{Gabi}    = &#39;Raspberry chocolate&#39;;
    $favorite_flavors{Annette} = &#39;French vanilla&#39;;</code></pre>

<p>Присваивание хешу списка ключей и значений в одном выражении:</p>

<pre><code>    my %favorite_flavors = (
        &#39;Gabi&#39;,    &#39;Raspberry chocolate&#39;,
        &#39;Annette&#39;, &#39;French vanilla&#39;,
    );</code></pre>

<p> </p>

<p>Если вы присвоите нечётное количество элементов хешу, то получите предупреждение. Идиоматический Perl часто использует оператор <em>толстая запятая</em> (<code>=></code>) для установки соответствия значений ключам, так как это делает разбиение на пары более заметным визуально:</p>

<pre><code>    my %favorite_flavors = (
        Gabi    <strong>=&gt;</strong> &#39;Mint chocolate chip&#39;,
        Annette <strong>=&gt;</strong> &#39;French vanilla&#39;,
    );</code></pre>

<p>Оператор толстая запятая ведёт себя как обычная запятая, но кроме того он автоматически заключает в кавычки предшествующее голое слово (<a href="chapter_11.html#barewords">Голые слова</a>). Прагма <code>strict</code> не будет предупреждать о таком голом слове &mdash; и если у вас есть функция с таким же именем, как ключ хеша, толстая запятая <em>не</em> будет вызывать функцию:</p>

<pre><code>    sub name { &#39;Leonardo&#39; }

    my %address =
    (
        name =&gt; &#39;1123 Fib Place&#39;,
    );</code></pre>

<p>Ключом хеша будет <code>name</code>, а не <code>Leonardo</code>. Чтобы вызвать функцию, сделайте её вызов явным:</p>

<pre><code>    my %address =
    (
        <strong>name()</strong> =&gt; &#39;1123 Fib Place&#39;,
    );</code></pre>

<p>Для очистки хеша присвойте ему пустой список (footnote: Иногда вам может встретиться <code>undef %hash</code>.):</p>

<pre><code>    %favorite_flavors = ();</code></pre>

<h3>Индексация хеша</h3>

<p></p>

<p>Доступ к отдельному значению хеша осуществляется с помощью операции индексации. Используйте ключ (<em>доступ по ключу</em>) для получения значения из хеша:</p>

<pre><code>    my $address = $addresses{$name};</code></pre>

<p>В этом примере <code>$name</code> содержит строку, которая также является ключом хеша. Как и при доступе к отдельному элементу массива, сигил хеша изменился с <code>%</code> на <code>$</code> для обозначения доступа по ключу к скалярному значению.</p>

<p>Вы можете использовать строковые литералы как ключи хеша. Perl автоматически заключит голые слова в кавычки в соответствии с теми же правилами, что и толстые запятые:</p>

<pre><code>    # &#x430;&#x432;&#x442;&#x43E;&#x43C;&#x430;&#x442;&#x438;&#x447;&#x435;&#x441;&#x43A;&#x43E;&#x435; &#x437;&#x430;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x438;&#x435; &#x432; &#x43A;&#x430;&#x432;&#x44B;&#x447;&#x43A;&#x438;
    my $address = $addresses{Victor};

    # &#x442;&#x440;&#x435;&#x431;&#x443;&#x435;&#x442; &#x437;&#x430;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x438;&#x44F; &#x432; &#x43A;&#x430;&#x432;&#x44B;&#x447;&#x43A;&#x438;; &#x43D;&#x435; &#x434;&#x43E;&#x43F;&#x443;&#x441;&#x442;&#x438;&#x43C;&#x43E;&#x435; &#x433;&#x43E;&#x43B;&#x43E;&#x435; &#x441;&#x43B;&#x43E;&#x432;&#x43E;
    my $address = $addresses{<strong>&#39;</strong>Sue-Linn<strong>&#39;</strong>};

    # &#x432;&#x44B;&#x437;&#x43E;&#x432; &#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x438; &#x442;&#x440;&#x435;&#x431;&#x443;&#x435;&#x442; &#x443;&#x441;&#x442;&#x440;&#x430;&#x43D;&#x435;&#x43D;&#x438;&#x44F; &#x43D;&#x435;&#x43E;&#x434;&#x43D;&#x43E;&#x437;&#x43D;&#x430;&#x447;&#x43D;&#x43E;&#x441;&#x442;&#x438;
    my $address = $addresses{get_name<strong>()</strong>};</code></pre>

<p>Новички зачастую всегда заключают в кавычки строковые литералы, являющиеся ключами хеша, но опытные разработчики опускают кавычки везде, где возможно. В этом смысле, наличие кавычек в ключах хеша указывает на намерение сделать что-то другое.</p>

<p>Даже на встроенные функции Perl 5 распространяется автоматическое заключение в кавычки:</p>

<pre><code>    my %addresses =
    (
        Leonardo =&gt; &#39;1123 Fib Place&#39;,
        Utako    =&gt; &#39;Cantor Hotel, Room 1&#39;,
    );

    sub get_address_from_name
    {
        return $addresses{<strong>+</strong>shift};
    }</code></pre>

<p>Унарный плюс (<a href="chapter_10.html#unary_coercions">Унарное приведение типа</a>) превращает то, на что как на голое слово (<code>shift</code>) должны распространяться правила автоматического заключения в кавычки, в выражение. Как из этого следует, вы можете использовать произвольное выражение &mdash; не только вызов функции &mdash; как ключ хеша:</p>

<pre><code>    # &#x445;&#x43E;&#x442;&#x44F; &#x43D;&#x435; &#x441;&#x442;&#x43E;&#x438;&#x442; &#x44D;&#x442;&#x43E;&#x433;&#x43E; <em>&#x434;&#x435;&#x43B;&#x430;&#x442;&#x44C;</em> &#x43D;&#x430; &#x441;&#x430;&#x43C;&#x43E;&#x43C; &#x434;&#x435;&#x43B;&#x435;
    my $address = $addresses{reverse &#39;odranoeL&#39;};

    # &#x438;&#x43D;&#x442;&#x435;&#x440;&#x43F;&#x43E;&#x43B;&#x44F;&#x446;&#x438;&#x44F; &#x434;&#x43E;&#x43F;&#x443;&#x441;&#x442;&#x438;&#x43C;&#x430;
    my $address = $addresses{&quot;$first_name $last_name&quot;};

    # &#x43A;&#x430;&#x43A; &#x438; &#x432;&#x44B;&#x437;&#x43E;&#x432;&#x44B; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x43E;&#x432;
    my $address = $addresses{ $user-&gt;name() };</code></pre>

<p>Ключи хешей могут быть только строками. Всё, что вычисляется в строку, является допустимым ключом хеша. Perl пойдёт так далеко, что приведёт (<a href="chapter_03.html#coercion">Приведение типов</a>) любую не-строку в строку, так что если вы используете объект как ключ хеша, вы получите строковую версию этого объекта вместо самого объекта:</p>

<pre><code>    for my $isbn (@isbns)
    {
        my $book = Book-&gt;fetch_by_isbn( $isbn );

        # &#x432;&#x440;&#x44F;&#x434; &#x43B;&#x438; &#x441;&#x434;&#x435;&#x43B;&#x430;&#x435;&#x442; &#x438;&#x43C;&#x435;&#x43D;&#x43D;&#x43E; &#x442;&#x43E;, &#x447;&#x435;&#x433;&#x43E; &#x432;&#x44B; &#x445;&#x43E;&#x442;&#x438;&#x442;&#x435;
        $books{$book} = $book-&gt;price;
    }</code></pre>

<h3>Существование ключа хеша</h3>

<p> </p>

<p>Оператор <code>exists</code> возвращает булево значение, указывающее, содержит ли хеш указанный ключ:</p>

<pre><code>    my %addresses =
    (
        Leonardo =&gt; &#39;1123 Fib Place&#39;,
        Utako    =&gt; &#39;Cantor Hotel, Room 1&#39;,
    );

    say &quot;Have Leonardo&#39;s address&quot;
        if exists $addresses{Leonardo};
    say &quot;Have Warnie&#39;s address&quot;
        if exists $addresses{Warnie};</code></pre>

<p>Использование <code>exists</code> вместо прямого доступа к ключу хеша позволяет избежать двух проблем. Во-первых, оно не проверяет булеву природу <em>значения</em> хеша; ключ хеша может существовать и иметь значение, даже если это значение является ложью (включая <code>undef</code>):</p>

<pre><code>    my  %false_key_value = ( 0 =&gt; &#39;&#39; );
    ok( %false_key_value,
         &#39;hash containing false key &amp; value
          should evaluate to a true value&#39; );</code></pre>

<p>Во-вторых, <code>exists</code> избегает автовивификации (<a href="chapter_03.html#autovivification">Автовивификация</a>) во вложенных структурах данных (<a href="chapter_03.html#nested_data_structures">Вложенные структуры данных</a>).</p>

<p></p>

<p>Если ключ хеша существует, его значением может быть <code>undef</code>. Проверьте это с помощью <code>defined</code>:</p>

<pre><code>    $addresses{Leibniz} = undef;

    say &quot;Gottfried lives at $addresses{Leibniz}&quot;
        if exists  $addresses{Leibniz}
        &amp;&amp; defined $addresses{Leibniz};</code></pre>

<h3>Доступ к ключам и значениям хеша</h3>

<p> </p>

<p>Хеши &mdash; агрегатные переменные, но их парная природа даёт намного больше возможностей для итераций: по ключам хеша, по значениям хеша, или по парам ключей и значений. Оператор <code>keys</code> возвращает список ключей хеша:</p>

<pre><code>    for my $addressee (keys %addresses)
    {
        say &quot;Found an address for $addressee!&quot;;
    }</code></pre>

<p> </p>

<p>Оператор <code>values</code> возвращает список значений хеша:</p>

<pre><code>    for my $address (values %addresses)
    {
        say &quot;Someone lives at $address&quot;;
    }</code></pre>

<p> </p>

<p>Оператор <code>each</code> возвращает список двухэлементных списков из ключа и значения:</p>

<pre><code>    while (my ($addressee, $address) = each %addresses)
    {
        say &quot;$addressee lives at $address&quot;;
    }</code></pre>

<p>В отличие от массивов, в этих списках нет очевидной сортировки. Сортировка зависит от внутренней реализации хеша, конкретной используемой вами версии Perl, размера хеша и элемента случайности. Несмотря на это, порядок элементов хеша согласован для <code>keys</code>, <code>values</code> и <code>each</code>. Модификация хеша может изменять этот порядок, но вы можете на него полагаться, если хеш остаётся тем же самым.</p>

<p>Каждый хеш имеет тольк <em>один</em> итератор для оператора <code>each</code>. Вы не можете надёжно итерировать по хешу с помощью <code>each</code> более одного раза; если вы начнёте новую итерацию, когда другая ещё не завершена, предыдущая преждевременно закончится, а последующая начнётся с середины хеша. Во время таких итераций остерегайтесь вызывать какие-либо функции, которые сами могут итерировать по хешу посредством <code>each</code>.</p>

<p>На практике такое случается редко, но если вам это нужно, сбросить итератор хеша можно с помощью <code>keys</code> или <code>values</code> в пустом контексте:</p>

<pre><code>    # &#x441;&#x431;&#x440;&#x43E;&#x441; &#x438;&#x442;&#x435;&#x440;&#x430;&#x442;&#x43E;&#x440;&#x430; &#x445;&#x435;&#x448;&#x430;
    keys %addresses;

    while (my ($addressee, $address) = each %addresses)
    {
        ...
    }</code></pre>

<h3>Срезы хешей</h3>

<p> </p>

<p><em>Срез хеша</em> &mdash; это список ключей и значений хеша, индексированных в одной операции. Так можно инициализировать несколько элементов хеша сразу:</p>

<pre><code>    # %cats &#x443;&#x436;&#x435; &#x441;&#x43E;&#x434;&#x435;&#x440;&#x436;&#x438;&#x442; &#x44D;&#x43B;&#x435;&#x43C;&#x435;&#x43D;&#x442;&#x44B;
    @cats{qw( Jack Brad Mars Grumpy )} = (1) x 4;</code></pre>

<p>Это эквивалентно следующей инициализации:</p>

<pre><code>    my %cats = map { $_ =&gt; 1 }
               qw( Jack Brad Mars Grumpy );</code></pre>

<p>&hellip;за исключением того, что инициализация среза хеша не <em>заменяет</em> существующее содержимое хеша.</p>

<p> </p>

<p>Срезы хеша также позволяют вам получить несколько значений из хеша в одной операции. Как и в случае срезов массива, сигил хеша изменяется для обозначения списочного контекста. Использование фигурных скобок указывает на доступ по ключу и делает хеш однозначным:</p>

<pre><code>    my @buyer_addresses = @addresses{ @buyers };</code></pre>

<p>Срезы хешей облегчают слияние двух хешей:</p>

<pre><code>    my %addresses        = ( ... );
    my %canada_addresses = ( ... );

    @addresses{ keys   %canada_addresses }
              = values %canada_addresses;</code></pre>

<p>Это эквивалентно ручному циклу по содержимому <code>%canada_addresses</code>, но намного короче.</p>

<p>Что если один и тот же ключ имеет место в обоих хешах? Подход со срезом хеша всегда <em>перезаписывает</em> существующие пары ключ/значение в <code>%addresses</code>. Если вам нужно другое поведение, больше подойдут циклы.</p>

<h3>Пустой хеш</h3>

<p>Пустой хеш не содержит ни ключей, ни значений. Он даёт ложное значение в булевом контексте. Хеш, содержащий хотя бы одну пару ключ/значение, в булевом контексте даёт истинное значение, даже если все ключи, или все значения, или и то и другое, сами по себе в булевом контексте являются ложными значениями.</p>

<pre><code>    use Test::More;

    my %empty;
    ok( ! %empty, &#39;empty hash should evaluate false&#39; );

    my %false_key = ( 0 =&gt; &#39;true value&#39; );
    ok( %false_key, &#39;hash containing false key
                     should evaluate to true&#39; );

    my %false_value = ( &#39;true key&#39; =&gt; 0 );
    ok( %false_value, &#39;hash containing false value
                       should evaluate to true&#39; );

    done_testing();</code></pre>

<p>В скалярном контексте хеш возвращает строку, представляющую соотношение полных корзин в хеше &mdash; внутренние детали реализации хешей, которые вы смело можете игнорировать.</p>

<p>В списочном контексте хеш возвращает список пар ключ/значение, подобный тому, что вы получаете от оператора <code>each</code>. Однако вы <em>не можете</em> итерировать по этому списку так же, как итерируете по списку, выдаваемому <code>each</code>, иначе цикл никогда не прервётся:</p>

<pre><code>    # &#x431;&#x435;&#x441;&#x43A;&#x43E;&#x43D;&#x435;&#x447;&#x43D;&#x44B;&#x439; &#x446;&#x438;&#x43A;&#x43B; &#x434;&#x43B;&#x44F; &#x43D;&#x435;&#x43F;&#x443;&#x441;&#x442;&#x44B;&#x445; &#x445;&#x435;&#x448;&#x435;&#x439;
    while (my ($key, $value) = %hash)
    {
        ...
    }</code></pre>

<p>Вы <em>можете</em> осуществлять цикл по ключам и значениям с помощью цикла <code>for</code>, но переменная-итератор будет получать ключ на одной итерации и его значение на следующей, потому что Perl разгладит хеш в один список перемежающихся ключей и значений.</p>

<h3>Идиомы с хешами</h3>

<p></p>

<p>Поскольку каждый ключ в хеше встречается только один раз, присваивание того же самого ключа хешу несколько раз сохраняет только самый последний ключ. Используйте это для нахождения уникальных элементов списка:</p>

<pre><code>    my %uniq;
    undef @uniq{ @items };
    my @uniques = keys %uniq;</code></pre>

<p>Использование <code>undef</code> со срезом хеша устанавливает значения хеша в <code>undef</code>. Эта идиома &mdash; самый дешёвый способ выполнить операции установки значения с хешем.</p>

<p></p>

<p>Хеши также полезны для подсчёта элементов, таких как IP-адреса в лог-файле:</p>

<pre><code>    my %ip_addresses;

    while (my $line = &lt;$logfile&gt;)
    {
        my ($ip, $resource) = analyze_line( $line );
        $ip_addresses{$ip}++;
        ...
    }</code></pre>

<p>Начальное значение значений хеша &mdash; <code>undef</code>. Оператор постфиксного инкремента (<code>++</code>) воспринимает его как ноль. Модификация значения инкрементирует существующее значения для этого ключа. Если значения для этого ключа не существует, Perl создаёт значение (<code>undef</code>) и немедленно инкрементирует его до единицы, так как преобразование <code>undef</code> в число даёт значение 0.</p>

<p> </p>

<p>Эта стратегия обеспечивает полезный механизм кеширования для сохранения результата дорогих операций с небольшим оверхедом:</p>

<pre><code>    {
        my %user_cache;

        sub fetch_user
        {
            my $id = shift;
            $user_cache{$id} //= create_user($id);
            return $user_cache{$id};
        }
    }</code></pre>

<p>   </p>

<p>Этот <em>орочий манёвр</em> (footnote: Or-cache, orcish, если вы любите игру слов.) возвращает значение из хеша, если оно существует. В противном случае, он вычисляет, кеширует и возвращает значение. Оператор определено-или-присвоить (<code>//=</code>) вычисляет свой левый операнд. Если этот операнд не определён, оператор присваивает левому значению значение своего правого операнда. Другими словами, если в хеше нет значения для заданного ключа, эта функция вызовет <code>create_user()</code> с этим ключом и обновит хеш.</p>

<p>Операторы определено-или и определено-или-присвоить были представлены в Per 5.10. До 5.10 большая часть кода использовала оператор или-присвоить (<code>||=</code>) для этой цели. К сожалению, некоторые валидные значения дают ложное значение в булевом контексте, так что вычисление <em>определённости</em> значений почти всегда более правильно. Этот ленивый орочий манёвр проверяет определённость кешированного значения, не истинность.</p>

<p></p>

<p>Если ваша функция принимает несколько аргументов, используйте захватывающий хеш (<a href="chapter_05.html#parameter_slurping">Проглатывание</a>) для сбора пар ключ/значение в один хеш как именованных аргументов функции:</p>

<pre><code>    sub make_sundae
    {
        my %parameters = @_;
        ...
    }

    make_sundae( flavor  =&gt; &#39;Lemon Burst&#39;,
                 topping =&gt; &#39;cookie bits&#39; );</code></pre>

<p>Этот подход позволяет вам устанавливать значения по умолчанию:</p>

<pre><code>    sub make_sundae
    {
        my %parameters           = @_;
        <strong>$parameters{flavor}    //= &#39;Vanilla&#39;;</strong>
        <strong>$parameters{topping}   //= &#39;fudge&#39;;</strong>
        <strong>$parameters{sprinkles} //= 100;</strong>
        ...
    }</code></pre>

<p>&hellip;или включать их в инициализацию хеша, так как последующее присваивание перезаписывает предыдущие:</p>

<pre><code>    sub make_sundae
    {
        my %parameters =
        (
            <strong>flavor    =&gt; &#39;Vanilla&#39;,</strong>
            <strong>topping   =&gt; &#39;fudge&#39;,</strong>
            <strong>sprinkles =&gt; 100,</strong>
            @_,
        );
        ...
    }</code></pre>

<h3>Блокировка хешей</h3>

<p><a name="locked_hashes"></p>

<p></p>

<p>Так как ключи хешей &mdash; голые слова, они мало защищены от опечаток по сравнению с защитой имён функций и переменных, предлагаемой прагмой <code>strict</code>. Редко используемый базовый модуль <code>Hash::Util</code> предоставляет механизмы для улучшения этой ситуации.</p>

<p>Чтобы не дать кому-либо случайно добавить ключ хеша, который вы не намеревались (в случае опечатки или из ненадёжного пользовательского ввода), используйте функцию <code>lock_keys()</code> чтобы ограничить хеш его текущим набором ключей. Любая попытка добавить новый ключ в хеш выбросит исключение. Эта слабая мера безопасности годится только для предотвращения случайностей; кто угодно может использовать функцию <code>unlock_keys()</code> чтобы удалить эту защиту.</p>

<p>Аналогично вы можете заблокировать или разблокировать существующее значение для заданного ключа хеша (<code>lock_value()</code> и <code>unlock_value()</code>) и сделать весь хеш доступным только для чтения или лишить его этого свойства с помощью <code>lock_hash()</code> и <code>unlock_hash()</code>.</p>

<h2>Приведение типов</h2>

<p><a name="coercion"></p>

<p>  </p>

<p>Переменная в Perl может содержать в разное время значения разных типов &mdash; строки, целые и рациональные числа и т. д. Вместо присоединения информации о типе к переменным, Perl полагается на контекст, устанавливаемый операторами (<a href="chapter_01.html#value_contexts">Числовой, строковый и булев контекст</a>) для понимания того, что делать со значениями. По своему дизайну, Perl пытается делать то, что вы имеете ввиду (footnote: Это называется <em>DWIM</em>, <em>do what i mean</em> (<em>делай то, что я имею ввиду</em>), или <em>DWIM-ность</em>.), хотя вы должны чётко выражать свои намерения. Если вы обращаетесь с переменной, содержащей число, как со строкой, Perl сделает всё, что сможет, для <em>приведения типа</em> этого числа к строке.</p>

<h3>Булево приведение типов</h3>

<p><a name="boolean_coercion">  </p>

<p>Булево приведение типов происходит, когда вы проверяете <em>истинность</em> значения, как, например, в условиях <code>if</code> или <code>while</code>. Числовой 0, <undef>, пустая строка и строка <code>'0'</code> являются ложными значениями. Все остальные значения &mdash; включая строки, которые могут быть <em>численно</em> равными нулю (такие как <code>'0.0'</code>, <code>'0e'</code> и <code>'0 but true'</code>), &mdash; являются ложными.</p>

<p>Если скаляр имет <em>оба</em> компонента (<a href="chapter_03.html#dualvars">Двойные переменные</a>), и строковый, и числовой, Perl 5 предпочтёт проверить на булеву истину строковый компонент. <code>'0 but true'</code> численно вычисляется в ноль, но это не пустая строка, поэтому в булевом контексте она вычисляется в истинное значение.</p>

<h3>Строковое приведение типов</h3>

<p> </p>

<p>Строковое приведение типов происходит при использовании строковых операторов, таких как сравнение (<code>eq</code> и <code>cmp</code>), конкатенация, <code>split</code>, <code>substr</code> и регулярные выражения, а также при использовании значения как ключа хеша. Неопределённое значение преобразуется в пустую строку, выдавая предупреждение &laquo;use of uninitialized value&raquo;. Числа <em>преобразуются</em> в строки, содержащие их значения, то есть значение <code>10</code> преобразуется в строку <code>10</code>. Вы можете даже разделить число на отдельные цифры с помощью <code>split</code>:</p>

<pre><code>    my @digits = split &#39;&#39;, 1234567890;</code></pre>

<h3>Числовое приведение типов</h3>

<p><a name="numeric_coercion">  </p>

<p>Числовое приведение типов происходит при использовании операторов числового сравнения (таких как <code>==</code> и <code><=></code>), при выполнении математических операций и при использовании значения как индекса массива или списка. Неопределённое значение <em>преобразуется</em> в ноль и выдаёт предупреждение &laquo;use of uninitialized value&raquo;. Строки, которые не начинаются с числовой части, тоже преобразуются в ноль и выдают предупреждение &laquo;Argument isn't numeric&raquo;. Строки, начинающиеся с символов, разрешённых в числовых литералах, преобразуются в эти значения, не выдавая предупреждений, то есть <code>10 leptons leaping</code> преобразуется в <code>10</code>, а <code>6.022e23 moles marauding</code> &mdash; в <code>6.022e23</code>.</p>

<p> </p>

<p>Базовый модуль <code>Scalar::Util</code> содержит функцию <code>looks_like_number()</code>, которая использует те же правила разбора, что и грамматика Perl 5, для выделения числа из строки.</p>

<p>Строки <code>Inf</code> и <code>Infinity</code> обозначают бесконечное значение и ведут себя как числа. Строка <code>NaN</code> обозначает понятие &laquo;не число&raquo;. Их преобразование в числа не выдаёт предупреждения &laquo;Argument isn't numeric&raquo;.</p>

<h3>Ссылочное преобразование типов</h3>

<p> </p>

<p>Использование операции разыменования ссылки на значении, не являющемся ссылкой, превращает его <em>в</em> ссылку. Этот процесс автовивификации (<a href="chapter_03.html#autovivification">Автовивификация</a>) удобен при манипулировании вложенными структурами данных (<a href="chapter_03.html#nested_data_structures">Вложенные структуры данных</a>):</p>

<pre><code>    my %users;

    $users{Brad}{id} = 228;
    $users{Jack}{id} = 229;</code></pre>

<p>Хотя хеш не содержал значений для ключей <code>Brad</code> и <code>Jack</code>, Perl создаёт для них ссылки на хеши и присваивает каждому пару ключ/значение с ключом <code>id</code>.</p>

<h3>Кешированное преобразование типов</h3>

<p><a name="cached_coercions"></p>

<p></p>

<p>Внутреннее представление значений в Perl 5 хранит и строковое, и числовое значения. Преобразование числа в строку не <em>заменяет</em> числовое значение. Вместо этого оно <em>присоединяет</em> преобразованное в строку значение, так что представление будет содержать <em>оба</em> компонента. Аналогично, преобразование строки в число заполняет числовой компонент, оставляя строковый компонент нетронутым.</p>

<p>Некоторые операции в Perl предпочитают использование одного из компонентов другому &mdash; булева проверка, например, предпочитает строки. Если значение имеет кешированное представление в форме, которую вы не ожидаете, расчёт на неявную конвертацию может привести к неожиданным результатам. Вам почти никогда не нужно будет явно указывать, что вы ожидаете (footnote: Автор может припомнить два таких случая за более чем десятилетие программирования на Perl 5), но знание того, что это кеширование происходит, может однажды помочь вам диагностировать странную ситуацию.</p>

<h3>Двойные переменные</h3>

<p><a name="dualvars"></p>

<p>   </p>

<p>Многокомпонентная природа переменных Perl доступна пользователям в виде <em>двойных переменных</em>. Базовый модуль <code>Scalar::Util</code> предоставляет функцию <code>dualvar()</code>, которая позволяет вам обойти приведение типов Perl и манипулировать строковым и числовым компонентами значения по отдельности:</p>

<pre><code>    use Scalar::Util &#39;dualvar&#39;;
    my $false_name = dualvar 0, &#39;Sparkles &amp; Blue&#39;;

    say &#39;Boolean true!&#39;  if        !! $false_name;
    say &#39;Numeric false!&#39; unless  0  + $false_name;
    say &#39;String true!&#39;   if     &#39;&#39;  . $false_name;</code></pre>

<h2>Пакеты</h2>

<p><a name="packages">  </p>

<p><em>Пространство имён</em> в Perl объединяет и инкапсулирует разные именованные сущности в одной именованной категории, как ваша фамилия или название бренда. В отличие от имён в реальном мире, пространство имён не подразумевает никаких непосредственных взаимосвязей между сущностями. Такие взаимосвязи могут существовать, но не обязаны.</p>

<p><em>Пакет</em> в Perl 5 &mdash; это набор кода в едином пространстве имён. Имеется тонкое различие: пакет представляет собой исходный код, а пространство имён &mdash; сущность, создаваемую, когда Perl парсит этот код.</p>

<p></p>

<p>Встроенная директива <code>package</code> объявляет пакет и пространство имён:</p>

<pre><code>    package MyCode;

    our @boxes;

    sub add_box { ... }</code></pre>

<p></p>

<p>Все глобальные переменные, которые объявляются или на которые ссылаются после объявления пакета, ссылаются на символы в пространстве имён <code>MyCode</code>. Вы можете ссылаться на переменную <code>@boxes</code> из пространства имён <code>main</code> только по её <em>полностью определённому</em> имени <code>@MyCode::boxes</code>. Полностью определённое имя включает полное имя пакета, так что вы можете вызвать функцию <code>add_box()</code> только как <code>MyCode::add_box()</code>.</p>

<p></p>

<p>Область видимости пакета продолжается до следующего объявления <code>package</code> или до конца файла, что будет достигнуто раньше. Perl 5.14 усовершенствовал <code>package</code>, так что теперь вы можете добавить блок, который явно очертит область видимости объявления:</p>

<pre><code>    package Pinball::Wizard
    {
        our $VERSION = 1969;
    }</code></pre>

<p>Пакет по умолчанию &mdash; <code>main</code>. Без объявления пакета, текущим пакетом будет <code>main</code>. Это правило распространяется на однострочники, автономные программы и даже файлы <em>.pm</em>.</p>

<p> </p>

<p>Кроме имени пакет имеет версию и три неявных метода, <code>import()</code> (<a href="chapter_05.html#importing">Импорт</a>), <code>unimport()</code> и <code>VERSION()</code>. <code>VERSION()</code> возвращает номер версии пакета. Этот номер представляет собой последовательность чисел, содержащуюся в глобальной переменной пакета с именем <code>$VERSION</code>. По примерному соглашению, версии имеют тенденцию быть последовательностью целых чисел, разделённых точками, как в <code>1.23</code> или <code>1.1.10</code>, где каждый сегмент &mdash; целое число.</p>

<p></p>

<p>Perl 5.12 представил новый синтаксис, предназначенный для упрощения номеров версий, как документировано в <code>perldoc version::Internals</code>. Эти более строгие номера версий должны начинаться с символа <code>v</code> и иметь как минимум три целочисленных компонента, разделённых точками:</p>

<pre><code>    package MyCode v1.2.1;</code></pre>

<p>В Perl 5.14 опциональная блочная форма объявления <code>package</code> выглядит так:</p>

<pre><code>    package Pinball::Wizard v1969.3.7
    {
        ...
    }</code></pre>

<p>В 5.10 и раньше, самым простым способом объявить версию пакета следующий:</p>

<pre><code>    package MyCode;

    our $VERSION = 1.21;</code></pre>

<p> </p>

<p>Каждый пакет наследует метод <code>VERSION()</code> от базового класса <code>UNIVERSAL</code>. Вы можете переопределить <code>VERSION()</code>, хотя есть не так много причин это делать. Этот метод возвращает значение <code>$VERSION</code>:</p>

<pre><code>    my $version = Some::Plugin-&gt;VERSION();</code></pre>

<p>Если вы укажете номер версии в качестве аргумента, этот метод выбросит исключение, если версия модуля меньше указанного аргумента:</p>

<pre><code>    # &#x442;&#x440;&#x435;&#x431;&#x443;&#x435;&#x442; &#x43A;&#x430;&#x43A; &#x43C;&#x438;&#x43D;&#x438;&#x43C;&#x443;&#x43C; 2.1
    Some::Plugin-&gt;VERSION( 2.1 );

    die &quot;Your plugin $version is too old&quot;
        unless $version &gt; 2;</code></pre>

<h3>Пакеты и пространства имён</h3>

<p> </p>

<p>Каждое объявление <code>package</code> создаёт новое пространство имён, если необходимо, и заставляет парсер разместить все глобальные символы следующего затем пакета (глобальные переменные и функции) в этом пространстве имён.</p>

<p></p>

<p>В Perl <em>открытые пространства имён</em>. Вы можете добавлять функции или переменные в это пространство имён в любом месте, как с помощью нового объявления пакета:</p>

<pre><code>    package Pack
    {
        sub first_sub { ... }
    }

    Pack::first_sub();

    package Pack
    {
        sub second_sub { ... }
    }

    Pack::second_sub();</code></pre>

<p>&hellip;так и с помощью указания полностью определённых имён функций в местах объявления:</p>

<pre><code>    # &#x43F;&#x43E;&#x434;&#x440;&#x430;&#x437;&#x443;&#x43C;&#x435;&#x432;&#x430;&#x435;&#x442;&#x441;&#x44F;
    package main;

    sub Pack::third_sub { ... }</code></pre>

<p>Вы можете делать добавления в пакет в любой точке во время компиляции или выполнения, независимо от текущего файла, хотя сборка пакета из нескольких отдельных объявлений может сделать код трудным для исследования.</p>

<p></p>

<p>Пространства имён могут иметь столь много уровней, сколько требует ваша организационная схема, хотя пространства имён &mdash; не иерархические. Единственная взаимосвязь между пакетами &mdash; семантическая, не техническая. Многие проекты и бизнесы создают свои собственные пространства имён верхнего уровня. Это уменьшает вероятность глобальных конфликтов и помогает организовать код на диске. Например:</p>

<ul>

<li><code>StrangeMonkey</code> &mdash; имя проекта</li>

<li><code>StrangeMonkey::UI</code> содержит код верхнего уровня для пользовательского интерфейса</li>

<li><code>StrangeMonkey::Persistence</code> содержит код верхнего уровня для управления данными</li>

<li><code>StrangeMonkey::Test</code> содержит код верхнего уровня для тестирования проекта</li>

</ul>

<p>&hellip;и т. д.</p>

<h2>Ссылки</h2>

<p><a name="references"></p>

<p>Perl обычно делает то, чего вы ожидаете, даже если это требует проницательности. Посмотрите, что происходит, когда вы передаёте значения в функции:</p>

<pre><code>    sub reverse_greeting
    {
        my $name = reverse shift;
        return &quot;Hello, $name!&quot;;
    }

    my $name = &#39;Chuck&#39;;
    say reverse_greeting( $name );
    say $name;</code></pre>

<p>Снаружи функции <code>$name</code> содержит значение <code>Chuck</code>, несмотря на то, что значение, переданное в функцию, переворачивается в <code>kcuhC</code>. Вероятно, этого вы и ожидаете. Значение <code>$name</code> снаружи функции отдельно от значения <code>$name</code> внутри функции. Изменение одного не оказывает эффекта на другое.</p>

<p>Рассмотрим альтернативу. Если бы вам было необходимо делать копии каждого значения прежде чем что-либо могло бы изменить их независимо от вас, вам пришлось бы писать большое количество дополнительного защитного кода.</p>

<p>Однако иногда удобно модифицировать значения прямо на месте. Если вы хотите передать хеш, полный данных, в функцию, для изменения его, создание и возврат нового хеша для каждого изменения может быть хлопотным (уж не говоря о том, что неэффективным).</p>

<p></p>

<p>Perl 5 предоставляет механизм, позволяющий ссылаться на значение, не делая его копии. Любые изменения, сделанные с этой <em>ссылкой</em>, сразу же обновят значение, так что <em>все</em> ссылки на это значение смогут получить новое значение. Ссылка в Perl 5 &mdash; скалярный тип данных первого класса, который ссылается на другой тип данных первого класса.</p>

<h3>Ссылки на скаляры</h3>

<p><a name="scalar_references"></p>

<p> </p>

<p> </p>

<p>Оператор взятия ссылки &mdash; обратный слеш (<code>\</code>). В скалярном контексте он создаёт одиночную ссылку, ссылающуюся на другое значение. В списочном контексте он создаёт список ссылок. Чтобы взять ссылку от <code>$name</code>:</p>

<pre><code>    my $name     = &#39;Larry&#39;;
    my $name_ref = <strong>\</strong>$name;</code></pre>

<p> </p>

<p>Вы должны <em>разыменовать</em> ссылку, чтобы получить значение, на которое она ссылается. Разыменовывание требует добавления дополнительного сигила для каждого уровня разыменовывания:</p>

<pre><code>    sub reverse_in_place
    {
        my $name_ref = shift;
        <strong>$$name_ref</strong>   = reverse <strong>$$name_ref</strong>;
    }

    my $name = &#39;Blabby&#39;;
    reverse_in_place( <strong>\</strong>$name );
    say $name;</code></pre>

<p>Двойной скалярный сигил (<code>$$</code>) разыменовывает ссылку на скаляр.</p>

<p> </p>

<p>Находящиеся в <code>@_</code> параметры ведут себя как <em>псевдонимы</em> переменных вызывающего кода (footnote: Вспомните, что цикл <code>for</code> имеет аналогичное поведение в плане создания псевдонимов.), так что вы можете изменять их на месте:</p>

<pre><code>    sub reverse_value_in_place
    {
        $_[0] = reverse $_[0];
    }

    my $name = &#39;allizocohC&#39;;
    reverse_value_in_place( $name );
    say $name;</code></pre>

<p>В большинстве случаев вы не захотите модифицировать значения таким способом &mdash; вызывающий код, например, редко этого ожидает. Присваивание параметров лексическим переменным внутри ваших функций избавляет от такого поведения.</p>

<p>Модификация значения на месте или возврат ссылки на скаляр может сэкономить память. Так как Perl копирует значения при присваивании, у вас может оказаться несколько копий большой строки. В случае передачи ссылок Perl будет копировать только ссылки &mdash; гораздо более дешёвая операция.</p>

<p>Сложные ссылки могут потребовать использования блока в фигурных скобках для разрешения неоднозначности частей выражения. Вы можете всегда использовать такой синтаксис, хотя иногда он проясняет, а иногда затеняет:</p>

<pre><code>    sub reverse_in_place
    {
        my $name_ref   = shift;
        <strong>${ $name_ref }</strong> = reverse <strong>${ $name_ref }</strong>;
    }</code></pre>

<p>Если вы забудете разыменовать ссылку на скаляр, Perl, вероятно, выполнит приведение типа ссылки. Строковое значение будет иметь вид <code>SCALAR(0x93339e8)</code>, а числовое будет содержать часть <code>0x93339e8</code>. В этом значении зашифрован тип ссылки (в данном случае <code>SCALAR</code>) и положение ссылки в памяти.</p>

<p>Perl не предоставляет доступа к ячейкам памяти. Адрес ссылки &mdash; это значение, используемое как идентификатор. В отличие от указателей в таких языках как C, вы не можете модифицировать адрес или обращаться с ним как с адресом в памяти. Эти адреса лишь <em>в большинстве случаев</em> уникальны, так как Perl может повторно использовать ячейки после освобождения неиспользуемой памяти.</p>

<h3>Ссылки на массивы</h3>

<p><a name="array_references"></p>

<p> </p>

<p><em>Ссылки на массивы</em> полезны в нескольких ситуациях:</p>

<ul>

<li>Для передачи и возвращения массивов из функций без разглаживания</li>

<li>Для создания многомерных структур данных</li>

<li>Чтобы избежать ненужного копирования массива</li>

<li>Для сохранения анонимных структур данных</li>

</ul>

<p>Используйте оператор взятия ссылки для создания ссылки на объявленный массив:</p>

<pre><code>    my @cards     = qw( K Q J 10 9 8 7 6 5 4 3 2 A );
    my $cards_ref = <strong>\</strong>@cards;</code></pre>

<p>Любые изменения, сделанные через <code>$cards_ref</code>, будут изменять и <code>@cards</code>, и наоборот. Вы можете получить доступ ко всему массиву целиком с помощью сигила <code>@</code>, например, чтобы разгладить массив или сосчитать его элементы:</p>

<pre><code>    my $card_count = <strong>@$cards_ref</strong>;
    my @card_copy  = <strong>@$cards_ref</strong>;</code></pre>

<p> </p>

<p>Доступ к отдельным элементам осуществляется с помощью разыменовывающей стрелки (<code>-></code>):</p>

<pre><code>    my $first_card = <strong>$cards_ref-&gt;[0]</strong>;
    my $last_card  = <strong>$cards_ref-&gt;[-1]</strong>;</code></pre>

<p>Стрелка необходима, чтобы различать скаляр <code>$cards_ref</code> и массив <code>@cards_ref</code>. Обратите внимание на использование скалярного сигила (<a href="chapter_03.html#sigils">Сигилы переменных</a>) для доступа к единственному элементу.</p>

<p>Альтернативный синтаксис добавляет ещё один скалярный сигил к ссылке на массив. Короче, хотя и уродливее, написать <code>my $first_card = <strong>$$cards_ref[0]</strong>;</code>.</p>

<p>Используйте разыменовывающий синтаксис с фигурными скобками для получения среза (<a href="chapter_03.html#array_slices">Срезы массивов</a>) по ссылке на массив:</p>

<pre><code>    my @high_cards = <strong>@{ $cards_ref }</strong>[0 .. 2, -1];</code></pre>

<p>Вы <em>можете</em> опустить фигурные скобки, но их группировка часто улучшает читабельность.</p>

<p> </p>

<p>Для создания анонимного массива &mdash; без использования объявленного массива &mdash; окружите список значений квадратными скобками:</p>

<pre><code>    my $suits_ref = [qw( Monkeys Robots Dinos Cheese )];</code></pre>

<p>Эта ссылка на массив ведёт себя так же, как ссылки на именованные массивы, за исключением того, что скобки анонимного массива <em>всегда</em> создают новую ссылку. Ссылка, взятая на именованный массив, всегда ссылается на <em>тот же самый</em> массив с учётом области видимости. Например:</p>

<pre><code>    my @meals      = qw( soup sandwiches pizza );
    my $sunday_ref = \@meals;
    my $monday_ref = \@meals;

    push @meals, &#39;ice cream sundae&#39;;</code></pre>

<p>&hellip;и <code>$sunday_ref</code>, и <code>$monday_ref</code> теперь содержат десерт, тогда как в следующем случае:</p>

<pre><code>    my @meals      = qw( soup sandwiches pizza );
    my $sunday_ref = [ @meals ];
    my $monday_ref = [ @meals ];

    push @meals, &#39;berry pie&#39;;</code></pre>

<p>&hellip;ни <code>$sunday_ref</code>, ни <code>$monday_ref</code> не содержат десерт. В квадратных скобках, использованных для создания анонимного массива, списочный контекст разглаживает массив <code>@meals</code> в список, не связанный с <code>@meals</code>.</p>

<h3>Ссылки на хеши</h3>

<p><a name="hash_references"></p>

<p> </p>

<p>Используйте оператор взятия ссылки на именованном хеше для создания <em>ссылки на хеш</em>:</p>

<pre><code>    my %colors = (
        black  =&gt; &#39;negro&#39;,
        blue   =&gt; &#39;azul&#39;,
        gold   =&gt; &#39;dorado&#39;,
        red    =&gt; &#39;rojo&#39;,
        yellow =&gt; &#39;amarillo&#39;,
        purple =&gt; &#39;morado&#39;,
    );

    my $colors_ref = <strong>\%</strong>colors;</code></pre>

<p>Доступ к ключам или значениям хеша можно получить, предварив ссылку сигилом хеша (<code>%</code>):</p>

<pre><code>    my @english_colors = keys   <strong>%$colors_ref</strong>;
    my @spanish_colors = values <strong>%$colors_ref</strong>;</code></pre>

<p>Доступ к отдельным значениям хеша (для сохранения, удаления, проверки существования или получения) осуществляется с использованием разыменовывающей стрелки или двойных сигилов:</p>

<pre><code>    sub translate_to_spanish
    {
        my $color = shift;
        return <strong>$colors_ref-&gt;{$color}</strong>;
        # &#x438;&#x43B;&#x438; return <strong>$$colors_ref{$color}</strong>;
    }</code></pre>

<p>Используйте сигил массива (<code>@</code>) и устраняющие неоднозначность скобки для получения среза по ссылке на хеш:</p>

<pre><code>    my @colors  = qw( red blue green );
    my @colores = <strong>@{ $colors_ref }{@colors}</strong>;</code></pre>

<p>Создание анонимного хеша с помощью фигурных скобок:</p>

<pre><code>    my $food_ref = <strong>{</strong>
        &#39;birthday cake&#39; =&gt; &#39;la torta de cumplea&ntilde;os&#39;,
        candy           =&gt; &#39;dulces&#39;,
        cupcake         =&gt; &#39;bizcochito&#39;,
        &#39;ice cream&#39;     =&gt; &#39;helado&#39;,
    <strong>}</strong>;</code></pre>

<p>Как и анонимные массивы, анонимные хеши создают новый анонимный хеш при каждом выполнении.</p>

<p>Распространённая ошибка новичков &mdash; присваивание анонимного хеша стандартному хешу &mdash; выдаёт предупреждение о нечётном количестве элементов в хеше. Используйте круглые скобки для именованного хеша и фигурные скобки для анонимного хеша.</p>

<h3>Автоматическое разыменование</h3>

<p><a name="automatic_dereferencing"></p>

<p></p>

<p>Начиная с Perl 5.14, Perl может автоматически разыменовать некоторые ссылки от вашего имени. Имея ссылку на массив в <code>$arrayref</code>, вы можете написать:</p>

<pre><code>    push $arrayref, qw( list of values );</code></pre>

<p>Имея выражение, возвращающее ссылку на массив, вы можете сделать то же самое:</p>

<pre><code>    push $houses{$location}[$closets], \@new_shoes;</code></pre>

<p>       </p>

<p>То же относится и к операторам работы с массивами <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code>, <code>keys</code>, <code>values</code>, и <code>each</code>, а также к операторам работы с хешами <code>keys</code>, <code>values</code> и <code>each</code>.</p>

<p>Если предоставленная ссылка имеет несоответствующий тип &mdash; если она не разыменовывается должным образом &mdash; Perl выбросит исключение. Хотя это выглядит более опасным, чем явное разыменовывание ссылок напрямую, фактически, это то же самое поведение:</p>

<pre><code>    my $ref = sub { ... };

    # &#x432;&#x44B;&#x431;&#x440;&#x43E;&#x441;&#x438;&#x442; &#x438;&#x441;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x438;&#x435;
    push  $ref, qw( list of values );

    # &#x442;&#x43E;&#x436;&#x435; &#x432;&#x44B;&#x431;&#x440;&#x43E;&#x441;&#x438;&#x442; &#x438;&#x441;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x438;&#x435;
    push @$ref, qw( list of values );</code></pre>

<h3>Ссылки на функции</h3>

<p><a name="function_references"></p>

<p>  </p>

<p>Perl 5 поддерживает <em>функции первого класса</em>, поскольку функция &mdash; такой же тип данных, как массив или хеш. Это наиболее очевидно в случае <em>ссылок на функции</em> и даёт много продвинутых возможностей (<a href="chapter_05.html#closures">Замыкания</a>). Ссылка на функцию создаётся посредством использования оператора взятия ссылки на имени функции:</p>

<pre><code>    sub bake_cake { say &#39;Baking a wonderful cake!&#39; };

    my $cake_ref = <strong>\&amp;</strong>bake_cake;</code></pre>

<p>  </p>

<p>Без <em>сигила функции</em> (<code>&</code>), вы получите ссылку на возвращаемое значение или значения функции.</p>

<p>Анонимная функция создаётся с помощью голого ключевого слова <code>sub</code>:</p>

<pre><code>    my $pie_ref = <strong>sub { say &#39;Making a delicious pie!&#39; }</strong>;</code></pre>

<p></p>

<p>Использование встроенной директивы С<sub> <em>без</em> имени компилирует функцию, как обычно, но не помещает её в текущее пространство имён. Единственный способ получить доступ к этой функции &mdash; по ссылке, возвращённой <code>sub</code>. Вызыв функции по ссылке осуществляется с помощью разыменовывающей стрелки:</p>

<pre><code>    $cake_ref-&gt;();
    $pie_ref-&gt;();</code></pre>

<p>Альтернативный синтаксис вызова для ссылок на функции использует сигил функции (<code>&</code>) вместо разыменовывающей стрелки. Избегайте этого синтаксиса; он имеет специфические последствия для парсинга и передачи аргументов.</p>

<p>Воспринимайте пустые круглые скобки как обозначение операции разыменовывающего вызова, так же как квадратные скобки указывают на поиск по индексу, а фигурные скобки служат для поиска в хеше. Передавайте аргументы в функцию с помощью круглых скобок:</p>

<pre><code>    $bake_something_ref-&gt;( &#39;cupcakes&#39; );</code></pre>

<p>Также вы можете использовать ссылки на функции как методы объектов (<a href="chapter_07.html#moose">Moose</a>). Это удобно, когда вы уже нашли метод (<a href="chapter_07.html#reflection">Рефлексия</a>):</p>

<pre><code>    my $clean = $robot_maid-&gt;can( &#39;cleanup&#39; );
    $robot_maid-&gt;$clean( $kitchen );</code></pre>

<h3>Ссылки на дескрипторы файлов</h3>

<p><a name="lexical_filehandles"></p>

<p>   </p>

<p>Когда вы используете <code>open</code> (и <code>opendir</code>) в форме с лексическими дескрипторами файлов, вы имеете дело со ссылками на дескрипторы файлов. Внутренне эти дескрипторы файлов &mdash; объекты <code>IO::File</code>. Вы можете напрямую вызывать их методы. Начиная с Perl 5.14 это можно делать так:</p>

<pre><code>    open my $out_fh, &#39;&gt;&#39;, &#39;output_file.txt&#39;;
    $out_fh-&gt;say( &#39;Have some text!&#39; );</code></pre>

<p>В 5.12 вы должны написать <code>use IO::File;</code> чтобы включить эту возможность, а в Perl 5.10 и раньше &mdash; <code>use IO::Handle;</code>. Даже более старый код может получать ссылки на тайпглобы:</p>

<pre><code>    local *FH;
    open FH, &quot;&gt; $file&quot; or die &quot;Can&#39;t write &#39;$file&#39;: $!&quot;;
    my $fh = <strong>\*FH</strong>;</code></pre>

<p>Эта идиома предшествует лексическим дескрипторам файлов (представленным в Perl 5.6.0 в марте 2000 года). Вы всё ещё можете использовать оператор взятия ссылки на тайпглобах для получения ссылок на дескрипторы файлов, глобальные для пакета, такие как <code>STDIN</code>, <code>STDOUT</code>, <code>STDERR</code> или <code>DATA</code> &mdash; но это всё в любом случае глобальные имена.</p>

<p>Использование лексических дескрипторов файлов по возможности предпочтительно. С преимуществами явного задания области видимости, лексические дескрипторы файлов позволяют вам управлять их сроком жизни благодаря возможностям Perl 5 по управлению памятью.</p>

<h3>Счётчики ссылок</h3>

<p><a name="reference_counts"> </p>

<p>Perl 5 использует технику управления памятью, известную как <em>подсчёт ссылок</em>. Каждое значение в Perl имеет присоединённый к нему счётчик. Perl увеличивает этот счётчик при каждом взятии ссылки на это значение, явном или неявном. Perl уменьшает этот счётчик каждый раз, когда ссылка исчезает. Когда счётчик достигает ноля, Perl может безопасно отправить это значение на переработку.</p>

<p></p>

<p>Как Perl узнаёт, когда можно безопасно освободить память, занимаемую переменной? Как Perl узнаёт, когда безопасно закрыть дескриптор файла, открытый во внутренней области видимости?</p>

<pre><code>    say &#39;file not open&#39;;

    {
        open my $fh, &#39;&gt;&#39;, &#39;inner_scope.txt&#39;;
        $fh-&gt;say( &#39;file open here&#39; );
    }

    say &#39;file closed here&#39;;</code></pre>

<p>Во внутреннем блоке в этом примере только один дескриптор <code>$fh</code>. (Несколько строк в исходном коде упоминают его, но ссылается на него только одна переменная: <code>$fh</code>.) <code>$fh</code> существует только в области видимости этого блока. Её значение никогда не покидает блок. Когда выполнение достигает конца блока, Perl перерабатывает переменную <code>$fh</code> и уменьшает счётчик ссылок содержащегося в ней дескриптора файла. Счётчик дескриптора достигает ноля, так что Perl перерабатывает его для освобождения памяти и неявно вызывает <code>close()</code>.</p>

<p>Вам не обязательно понимать детали того, как всё это работает. Вам нужно понимать только то, что ваши действия по взятию ссылок и их передаче влияют на то, как Perl управляет памятью (см. <a href="chapter_03.html#circular_references">Циклические ссылки</a>).</p>

<h3>Ссылки и функции</h3>

<p>При использовании ссылок как аргументов функции внимательно документируйте ваши намерения. Изменение значений ссылки изнутри функции может стать неожиданностью для вызывающего кода, который не ожидает, что кто-то ещё будет модифицировать его данные. Для изменения содержимого ссылки, не воздействуюя на саму ссылку, скопируйте её значение в новую переменную:</p>

<pre><code>    my @new_array = @{ $array_ref };
    my %new_hash  = %{ $hash_ref  };</code></pre>

<p> </p>

<p>Это необходимо лишь в немногих случаях, но явное клонирование помогает избежать неприятных сюрпризов для вызывающего кода. Если вы используете вложенные структуры данных или другие сложные ссылки, рассмотрите использование базового модуля <code>Storable</code> и его функции <code>dclone</code> (<em>deel cloning</em>, <em>глубокое клонирование</em>).</p>

<h2>Вложенные структуры данных</h2>

<p><a name="nested_data_structures">  </p>

<p>Агрегатные типы данных Perl &mdash; массивы и хеши &mdash; позволяют вам хранить скаляры, индексированные по целым числам или строковым ключам. Ссылки в Perl 5 позволяют получать доступ к агрегатным типам данных через специальные скаляры. Вложенные структуры данных в Perl, такие как массив массивов или хеш хешей, становятся возможными благодаря использованию ссылок.</p>

<p>Для объявления вложенной структуры данных используйте синтаксис объявления анонимной ссылки:</p>

<pre><code>    my @famous_triplets = (
        [qw( eenie miney moe   )],
        [qw( huey  dewey louie )],
        [qw( duck  duck  goose )],
    );

    my %meals = (
        breakfast =&gt; { entree =&gt; &#39;eggs&#39;,
                       side   =&gt; &#39;hash browns&#39; },
        lunch     =&gt; { entree =&gt; &#39;panini&#39;,
                       side   =&gt; &#39;apple&#39;         },
        dinner    =&gt; { entree =&gt; &#39;steak&#39;,
                       side   =&gt; &#39;avocado salad&#39; },
    );</code></pre>

<p>Perl позволяет, хотя и не требует, ставить завершающую запятую для облегчения последующего добавления элементов в список.</p>

<p>Для доступа к элементам вложенных структур данных используйте синтаксис ссылок Perl. Сигил обозначает количество данных, которое должно быть получено, а разыменовывающая стрелка указывает, что значение части структуры данных является ссылкой:</p>

<pre><code>    my $last_nephew = $famous_triplets[1]-&gt;[2];
    my $breaky_side = $meals{breakfast}-&gt;{side};</code></pre>

<p>Единственный способ создать многоуровневую структура данных &mdash; посредством ссылок, так что стрелка излишня. Вы можете опустить её для ясности, за исключением вызовов функций по ссылке:</p>

<pre><code>    my $nephew = $famous_triplets[1][2];
    my $meal   = $meals{breakfast}{side};
    $actions{financial}{buy_food}-&gt;( $nephew, $meal );</code></pre>

<p>Используйте устраняющий неоднозначность блок для доступа к компонентам вложенной структуры данных, как если бы они были массивами или хешами первого класса:</p>

<pre><code>    my $nephew_count   = @{ $famous_triplets[1] };
    my $dinner_courses = keys %{ $meals{dinner} };</code></pre>

<p>&mdash;или для получения среза вложенной структуры данных:</p>

<pre><code>    my ($entree, $side) = @{ $meals{breakfast} }
                           {qw( entree side )};</code></pre>

<p>Пробелы помогают, но не полностью устраняют зашумлённость этой конструкции. Используйте временные переменные для придания ясности:</p>

<pre><code>    my $meal_ref        = $meals{breakfast};
    my ($entree, $side) = @$meal_ref{qw( entree side )};</code></pre>

<p></p>

<p>&hellip;или используйте неявное создание псевдонимов в <code>$_</code> директивой <code>for</code>, чтобы избежать использования промежуточной ссылки:</p>

<pre><code>    my ($entree, $side) = @{ $_ }{qw( entree side )}
                          for $meals{breakfast};</code></pre>

<p><code>perldoc perldsc</code>, кулинарная книга структур данных, даёт обширные примеры того, как использовать разные структуры данных в Perl.</p>

<h3>Автовивификация</h3>

<p><a name="autovivification"> </p>

<p>Когда вы пытаетесь записать значение в компонент вложенной структуры данных, Perl по необходимости создаёт путь через структуру данных до пункта назначения:</p>

<pre><code>    my @aoaoaoa;
    $aoaoaoa[0][0][0][0] = &#39;nested deeply&#39;;</code></pre>

<p>После второй строки кода этот массив массивов массивов массивов содержит ссылку на массив в ссылке на массив в ссылке на массив в ссылке на массив. Каждая ссылка на массив содержит один элемент. Аналогично, обработка неопределённого значения так, как будто это ссылка на хеш во вложенной структуре данных, сделает его таковой:</p>

<pre><code>    my %hohoh;
    $hohoh{Robot}{Santa} = &#39;mostly harmful&#39;;</code></pre>

<p>  </p>

<p>Это полезное поведение называется <em>автовивификацией</em>. Оно уменьшает объём инициализирующего кода вложенной структуры данных, но не может определить разницу между честным намерением создать недостающие элементы во вложенной структуре данных и опечаткой. Прагма <code>autovivification</code> (<a href="chapter_08.html#pragmas">Прагмы</a>) из CPAN позволит вам отключить автовивификацию в лексической области видимости для определённых типов операций.</p>

<p>Вас может удивить применение преимуществ автовивификации параллельно установке ограничений с помощью <code>strict</code>. Это вопрос баланса. Будет ли более удобным получить ошибки, изменяющие поведение вашей программы, ценой отключения проверок на ошибки для хорошо инкапсулированных символьных ссылок? Будет ли более удобным позволить структурам данных расти вместо чёткого указания их размера и доступных ключей?</p>

<p>Ответы зависят от вашего проекта. В период начальной разработки позвольте себе свободу экспериментировать. Во время тестирования и развёртывания рассмотрите увеличение строгости для предотвращения нежелательных побочных эффектов. Благодаря лексической области видимости прагм <code>strict</code> и <code>autovivification</code> вы можете включить эти варианты поведения там, где это необходимо.</p>

<p>Вы <em>можете</em> проверять свои ожидания перед разыменованием каждого уровня сложной структуры данных, но результирующий код зачастую будет длинным и громоздким. Лучше избегать глубоко вложенных структур данных, пересмотрев свою модель данных в сторону лучшей инкапсуляции.</p>

<h3>Отладка вложенных структур данных</h3>

<p>Сложность разыменовывающего синтаксиса Perl 5, объединённая с потенциальной путаницей нескольких уровней ссылок, может сделать отладку вложенных структур данных сложной. Есть два хороших инструмента визуализации.</p>

<p></p>

<p>Базовый модуль <code>Data::Dumper</code> преобразует значения произвольной сложности в строки кода Perl 5:</p>

<pre><code>    use Data::Dumper;

    print Dumper( $my_complex_structure );</code></pre>

<p>Это удобно для определения того, что содержит структура данных, что вы должны получить, и что вы получили вместо этого. <code>Data::Dumper</code> может выводить объекты, так же как ссылки на функции (если вы установите <code>$Data::Dumper::Deparse</code> в истинное значение).</p>

<p>Хотя <code>Data::Dumper</code> &mdash; базовый модуль и выводит код на Perl 5, его вывод довольно многословен. Некоторые разработчики предпочитают использовать для отладки модули <code>YAML::XS</code> или <code>JSON</code>. Они не выдают код на Perl 5, но их вывод может быть гораздо проще для чтения и понимания.</p>

<h3>Циклические ссылки</h3>

<p><a name="circular_references"></p>

<p>  </p>

<p>Имеющаяся в Perl 5 система управления памятью с помощью подсчёта ссылок (<a href="chapter_03.html#reference_counts">Счётчики ссылок</a>) имеет один недостаток, заметный для пользовательского кода. Две ссылки, которые в конечном счёте указывают друг на друга, образуют <em>циклическую ссылку</em>, которую Perl не может уничтожить сам. Рассмотрим биологическую модель, где каждая сущность имеет двух родителей и ноль или больше детей:</p>

<pre><code>    my $alice  = { mother =&gt; &#39;&#39;,     father =&gt; &#39;&#39;      };
    my $robert = { mother =&gt; &#39;&#39;,     father =&gt; &#39;&#39;      };
    my $cianne = { mother =&gt; $alice, father =&gt; $robert };

    push @{ $alice-&gt;{children}  }, $cianne;
    push @{ $robert-&gt;{children} }, $cianne;</code></pre>

<p>И <code>$alice</code>, и <code>$robert</code> содержат ссылку на массив, которая содержит <code>$cianne</code>. Поскольку <code>$cianne</code> &mdash; ссылка на хеш, которая содержит <code>$alice</code> и <code>$robert</code>, Perl никогда не сможет уменьшить счётчик ссылок любого из этих трёх человек до нуля. Он не распознает, что эти циклические ссылки существуют, и не сможет управлять сроком жизни этих сущностей.</p>

<p>  </p>

<p>Или разбейте счётчик ссылок сами вручную (очистив детей <code>$alice</code> и <code>$robert</code> или родителей <code>$cianne</code>), или используйте <em>слабые ссылки</em>. Слабая ссылка &mdash; это ссылка, которая не увеличивает счётчик ссылок значения, на которое ссылается. Слабые ссылки доступны через базовый модуль <code>Scalar::Util</code>. Его функция <code>weaken()</code> предотвращает увеличение счётчика ссылок:</p>

<pre><code>    use Scalar::Util &#39;weaken&#39;;

    my $alice  = { mother =&gt; &#39;&#39;,     father =&gt; &#39;&#39;      };
    my $robert = { mother =&gt; &#39;&#39;,     father =&gt; &#39;&#39;      };
    my $cianne = { mother =&gt; $alice, father =&gt; $robert };

    push @{ $alice-&gt;{children}  }, $cianne;
    push @{ $robert-&gt;{children} }, $cianne;

    <strong>weaken( $cianne-&gt;{mother} );</strong>
    <strong>weaken( $cianne-&gt;{father} );</strong></code></pre>

<p>Теперь <code>$cianne</code> сохранит ссылки на <code>$alice</code> и <code>$robert</code>, но эти ссылки сами по себе не будут удерживать сборщик мусора Perl от разрушения этих структур данных. Большинство структур данных не требуют слабых ссылок, но когда они необходимы &mdash; они бесценны.</p>

<h3>Альтернативы вложенным структурам данных</h3>

<p>Хотя Perl способен обрабатывать структуры данных, вложенные так глубоко, как вы только можете представить, человеческая стоимость понимания этих структур данных и их взаимоотношений &mdash; не говоря о сложном синтаксисе &mdash; высока. После двух или трёх уровней вложенности, задумайтесь, не позволит ли вам моделирование разных компонентов вашей системы как классов и объектов (<a href="chapter_07.html#moose">Moose</a>) сделать код чище.</p>

</body></html>