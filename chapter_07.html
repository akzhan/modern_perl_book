<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="style.css" type="text/css"></head><body><h1>Объекты</h1>

<p>Программирование &mdash; управляющая деятельность. Чем больше программа, тем большим количеством деталей вам приходится управлять. Наша единственная надежда справиться с этой сложностью &mdash; использовать абстракцию (обращаться с похожими вещами похожим способом) и инкапсуляцию (групировать вместе связанные части).</p>

<p>   </p>

<p>Одних функций недостаточно для крупных задач. Существует несколько техник, группирующих функции в единицы связанного поведения. Одна из популярных техник &mdash; <em>объектное ориентирование</em> (ОО), или <em>объектно-ориентированное программирование</em> (ООП), где программы работают с <em>объектами</em> &mdash; обособленными, уникальными сущностями, обладающими собственной индивидуальностью.</p>

<h2>Moose</h2>

<p><a name="moose"></p>

<p></p>

<p>Стандартная объектная система Perl 5 гибка, но минималистична. Вы можете построить замечательные вещи на её основе, но она даёт лишь небольшую помощь в некоторых базовых задачах. <em>Moose</em> &mdash; это полноценная объектная система для Perl5 (footnote: См. <code>perldoc Moose::Manual</code> для подробной информации.). Она предоставляет более простой стандартный функционал и продвинутые возможности, заимствованные из таких языков как Smalltalk, Common Lisp и Perl 6. Код Moose работает совместно со стандартной объектной системой, и на данный момент является лучшим способом написания объектно-ориентированного кода в современном Perl 5.</p>

<h3>Классы</h3>

<p> </p>

<p>Объект в Moose &mdash; это конкретный экземпляр <em>класса</em>, который представляет собой шаблон, описывающий данные и поведение, характерные для объекта. Классы используют пакеты (<a href="chapter_03.html#packages">Пакеты</a>) для создания пространств имён:</p>

<pre><code>    package Cat
    {
        use Moose;
    }</code></pre>

<p></p>

<p>Этот класс <code>Cat</code> <em>выглядит</em> так, как будто ничего не делает, но это всё, что нужно Moose для создания класса. Объекты (или <em>экземпляры</em>) класса <code>Cat</code> создаются с помощью следующего синтаксиса:</p>

<pre><code>    my $brad = Cat-&gt;new();
    my $jack = Cat-&gt;new();</code></pre>

<p>Как стрелка разыменовывает ссылку, также она и вызвает метод объекта или класса.</p>

<h3>Методы</h3>

<p> </p>

<p><em>Метод</em> &mdash; это функция, ассоциированная с классом. Как функции принадлежат пространствам имён, также и методы принадлежат классам, с двумя отличиями. Во-первых, метод всегда оперирует <em>инвокантом</em>. Вызов <code>new()</code> на <code>Cat</code> в сущности отправляет классу <code>Cat</code> сообщение. Имя класса, <code>Cat</code>, будет инвокантом <code>new()</code>. Если вы вызываете метод на объекте, этот объект будет инвокантом:</p>

<pre><code>    my $choco = <strong>Cat</strong>-&gt;new();
    <strong>$choco</strong>-&gt;sleep_on_keyboard();</code></pre>

<p>   </p>

<p>Во-вторых, вызов метода всегда задействует стратегию <em>диспетчеризации</em>, когда объектная система выбирает соответствующий метод. Учитывая простоту <code>Cat</code>, стратегия диспетчеризации очевидна, но существенная часть мощи ОО происходит из этой идеи.</p>

<p>Внутри метода первым аргументом будет инвокант. Идиоматический Perl 5 использует <code>$self</code> как его имя. Предположим, что <Cat> может мяукать:</p>

<pre><code>    package Cat
    {
        use Moose;

        <strong>sub meow</strong>
        <strong>{</strong>
            <strong>my $self = shift;</strong>
            <strong>say &#39;Meow!&#39;;</strong>
        <strong>}</strong>
    }</code></pre>

<p>Теперь все экземпляры <code>Cat</code> могут разбудить вас с утра из-за того, что их ещё не покормили:</p>

<pre><code>    my $fuzzy_alarm = Cat-&gt;new();
    $fuzzy_alarm-&gt;meow() for 1 .. 3;</code></pre>

<p>     </p>

<p>Методы, пользующиеся доступом к данным инвоканта &mdash; это <em>методы экземпляра</em>, потому что для корректной работы они требуют присутствия соответствующего инвоканта. Методы (такие как <code>meow()</code>), не обращающиеся к данным экземпляра, &mdash; это <em>методы класса</em>. Вы можете вызывать методы класса на классах и методы классов и экземпляров на экземплярах, но нельзя вызывать методы экземпляра на классах.</p>

<p></p>

<p><em>Конструкторы</em>, которые <em>создают</em> экземпляры, очевидно являются методами класса. Moose предоставляет вам конструктор по умолчанию.</p>

<p>Методы класса &mdash; это, в сущности, глобальные функции в пространстве имён. Без доступа к данным экземпляра они имеют немного преимуществ над функциями в пространстве имён. Большая часть ОО кода должным образом использует методы экземпляров, так как у них есть доступ к данным экземпляра.</p>

<h3>Атрибуты</h3>

<p>    </p>

<p>Каждй объект в Perl 5 уникален. Объекты могут содержать приватные данные, ассоциированные с каждым уникальным объектом &mdash; это <em>атрибуты</em>, <em>данные экземпляра</em>, или <em>состояние</em> объекта. Определите атрибут, объявив его как часть класса:</p>

<pre><code>    package Cat
    {
        use Moose;

        <strong>has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;</strong>
    }</code></pre>

<p>Это читается как &laquo;Объекты <code>Cat</code> имеют атрибут <code>name</code>. Он доступен только для чтения и является строкой.&raquo;</p>

<p>Moose предоставляет функцию <code>has()</code>, которая объявляет атрибут. Первый аргумент, в данном случае <code>'name'</code>, это имя атрибута. Пара аргументов <code>is => 'ro'</code> объявляет, что этот атрибут доступен только для чтения (<code>r</code>ead <code>o</code>nly), так что вы не сможете его изменять после того, как установили. Наконец, пара <code>isa => 'Str'</code> объявляет, что значение этого атрибута может быть только строкой (<code>str</code>ing).</p>

<p> </p>

<p>Как результат использования <code>has</code> Moose создает метод-<em>аксессор</em> с именем <code>name()</code> и позволяет вам передавать параметр <code>name</code> в конструктор класса <code>Cat</code>:</p>

<pre><code>    for my $name (qw( Tuxie Petunia Daisy ))
    {
        my $cat = Cat-&gt;new( name =&gt; $name );
        say &quot;Created a cat for &quot;, $cat-&gt;name();
    }</code></pre>

<blockquote>

<p>Документация Moose использует круглые скобки для разделения имён атрибутов и их свойств:</p>

<pre><code>        has &#39;name&#39; =&gt; ( is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39; );</code></pre>

<p>Это равнозначно следующему:</p>

<pre><code>    has( &#39;name&#39;, &#39;is&#39;, &#39;ro&#39;, &#39;isa&#39;, &#39;Str&#39; );</code></pre>

<p>Подход Moose хорошо подходит для сложных объявлений:</p>

<pre><code>    has &#39;name&#39; =&gt; (
        is         =&gt; &#39;ro&#39;,
        isa        =&gt; &#39;Str&#39;,

        # &#x434;&#x43E;&#x43F;&#x43E;&#x43B;&#x43D;&#x438;&#x442;&#x435;&#x43B;&#x44C;&#x43D;&#x44B;&#x435; &#x43F;&#x430;&#x440;&#x430;&#x43C;&#x435;&#x442;&#x440;&#x44B; Moose; perldoc Moose
        init_arg   =&gt; undef,
        lazy_build =&gt; 1,
    );</code></pre>

<p>&hellip;тогда как в этой книге предпочтение отдано подходу с меньшим количеством пунктуации для простых объявлений. Выберите пунктуацию, которая даёт вам наибольшую понятность.</p>

</blockquote>

<p></p>

<p>Moose пожалуется, если вы передадите что-нибудь, не являющееся строкой. Атрибуты не <em>обязаны</em> иметь тип. В таком случае подойдёт что угодно:</p>

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        <strong>has &#39;age&#39;,  is =&gt; &#39;ro&#39;;</strong>
    }

    my $invalid = Cat-&gt;new( name =&gt; &#39;bizarre&#39;,
                            age  =&gt; &#39;purple&#39; );</code></pre>

<p>Указание типа позволяет Moose выполнить для вас некоторую валидацию данных. Иногда подобная строгость бесценна.</p>

<p>  </p>

<p>Если вы пометите атрибут как доступный для чтения <em>и</em> записи (с помощью <code>is => rw</code>), Moose создаст метод-<em>мутатор</em>, который может изменять значение этого атрибута:</p>

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;age&#39;,  is =&gt; &#39;ro&#39;, isa =&gt; &#39;Int&#39;;
        <strong>has &#39;diet&#39;, is =&gt; &#39;rw&#39;;</strong>
    }

    my $fat = Cat-&gt;new( name =&gt; &#39;Fatty&#39;,
                        age  =&gt; 8,
                        diet =&gt; &#39;Sea Treats&#39; );

    say $fat-&gt;name(), &#39; eats &#39;, $fat-&gt;diet();

    <strong>$fat-&gt;diet( &#39;Low Sodium Kitty Lo Mein&#39; );</strong>
    say $fat-&gt;name(), &#39; now eats &#39;, $fat-&gt;diet();</code></pre>

<p><code>ro</code>-аксессор, используемый как мутатор, выбросит исключение <code>Cannot assign a value to a read-only accessor at ...</code>.</p>

<p>Использование <code>ro</code> или <code>rw</code> &mdash; вопрос дизайна, удобства и чистоты. Moose не принуждает к какой-то определённой философии в этой области. Некоторые предлагают делать все данные экземпляра <code>ro</code>, чтобы необходимо было передавать данные экземпляра в конструктор (<a href="chapter_07.html#immutability">Неизменяемость</a>). В примере с <code>Cat</code> <code>age()</code> всё ещё может быть аксессором, но конструктор может принять <em>год</em> рождения кота и вычислить возраст сам, исходя из текущего года. Этот подход усиливает код валидации и гарантирует, что все создаваемые объекты будут иметь валидные данные.</p>

<p>Данные экземпляра начинают демонстрировать значение объектного-ориентированного подхода. Объект содержит связанные данные и может выполнять действия с этими данными. Класс только описывает эти данные и действия.</p>

<h3>Инкапсуляция</h3>

<p> </p>

<p>Moose позволяет вам объявить, <em>какими</em> атрибутами обладают экземпляры класса (у кота есть имя), а также атрибуты этих атрибутов (вы не можете изменить имя кота; вы можете его только читать). Moose сам решает, как <em>хранить</em> эти атрибуты. Вы можете изменить это, если захотите, но позволение Moose управлять вашим хранилищем поддерживает <em>инкапсуляцию</em>: скрытие внутренних деталей объекта от внешних пользователей этого объекта.</p>

<p>Рассмотрим изменение того, как <code>Cat</code> управляет своим возрастом. Вместо передачи значения возраста в конструктор, передадим год рождения кота и вычислим возраст при необходимости:</p>

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;,        is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;diet&#39;,        is =&gt; &#39;rw&#39;;
        <strong>has &#39;birth_year&#39;,  is =&gt; &#39;ro&#39;, isa =&gt; &#39;Int&#39;;</strong>

        <strong>sub age</strong>
        <strong>{</strong>
            <strong>my $self = shift;</strong>
            <strong>my $year = (localtime)[5] + 1900;</strong>

            <strong>return $year - $self-&gt;birth_year();</strong>
        <strong>}</strong>
    }</code></pre>

<p>Хотя синтаксис <em>создания</em> объектов <code>Cat</code> изменился, синтаксис <em>использования</em> объектов <code>Cat</code> остался прежним. Снаружи <code>Cat</code> <code>age()</code> ведёт себя так же, как и раньше. <em>Как</em> это работает внутренне &mdash; это забота класса <code>Cat</code>.</p>

<p>Сохраните поддержку старого синтаксиса <em>создания</em> объектов <code>Cat</code>, модифицировав генерируемый конструктор <code>Cat</code>, чтобы позволить передавать параметр <code>age</code>. На основе него вычислите <code>birth_year</code>. См. <code>perldoc Moose::Manual::Attributes</code>.</p>

<p></p>

<p>Вычисление возраста имеет другое преимущество. <em>Значение атрибута по умолчанию</em> будет вести себя правильно в случае, если кто-нибудь создат новый объект <code>Cat</code>, не передав год рождения:</p>

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;diet&#39;, is =&gt; &#39;rw&#39;, isa =&gt; &#39;Str&#39;;

        <strong>has &#39;birth_year&#39;,</strong>
            <strong>is      =&gt; &#39;ro&#39;,</strong>
            <strong>isa     =&gt; &#39;Int&#39;,</strong>
            <strong>default =&gt; sub { (localtime)[5] + 1900 };</strong>
    }</code></pre>

<p>Ключевое слово <code>default</code> у атрибута принимает ссылку на функцию (footnote: Вы можете использовать простое значение, такое как число или строка, напрямую, но для чего-либо более сложного используйте ссылку на функцию.), которая возвращает значение по умолчанию для этого атрибута при создании нового объекта. Если код, создающий объект, не передаст в конструктор значение для этого атрибута, объект получит значение по умолчанию:</p>

<pre><code>    my $kitten = Cat-&gt;new( name =&gt; &#39;Choco&#39; );</code></pre>

<p>&hellip;и этот котёнок будет иметь возраст <code>0</code> до следующего года.</p>

<h4>Полиморфизм</h4>

<p>Инкапсуляция полезна, но настоящие возможности объектного-ориентированного подхода намного шире. Хорошо спроектированная ОО-программа может управлять множеством типов данных. Когда хорошо спроектированные классы инкапсулируют конкретные детали объектов в соответствующих местах, происходит нечто любопытное: код зачастую становится <em>менее</em> конкретным.</p>

<p>Перемещение деталей того, что программа знает об отдельных объектах <code>Cat</code> (атрибуты), и того, что программа знает о том, что объекты <code>Cat</code> могут делать (методы) в класс <code>Cat</code> означает, что код, работающий с экземплярами <code>Cat</code>, может успешно игнорировать то, <em>как</em> <code>Cat</code> делает то, что он делает.</p>

<p>Рассмотрим функцию, выводяющую детали объекта:</p>

<pre><code>    sub show_vital_stats
    {
        my $object = shift;

        say &#39;My name is &#39;, $object-&gt;name();
        say &#39;I am &#39;,       $object-&gt;age();
        say &#39;I eat &#39;,      $object-&gt;diet();
    }</code></pre>

<p> </p>

<p>Очевидно (из контекста), что эта функцию работает, если вы передадите ей объект <code>Cat</code>. Фактически, она будет делать то, что нужно, для любого объекта, имеющего три соответствующих аксессора, независимо от того, <em>как</em> этот объект предоставляет эти аксессоры, и независимо от того, <em>что</em> это за объект: <code>Cat</code>, <code>Caterpillar</code> или <code>Catbird</code>. Функция имеет достаточно общий вид, чтобы любой объект, обеспечивающий этот интерфейс, был корректным параметром.</p>

<p> </p>

<p>Это свойство <em>полиморфизма</em> означает, что вы можете заменить объект одного класса объектом другого класса, если они предоставляют один и тот же внешний интерфейс.</p>

<p> </p>

<p>Некоторые языки и среды требуют установления формального отношения между двумя классами, прежде чем позволить программе заменять экземпляры одного экземплярами другого. Perl 5 предоставляет способы сделать эти проверки обязательными, но не требует их. Его стандартная ad-hoc-система позволяет вам обращаться с двумя любыми экземплярами, имеющими одинаково названные методы, как с вполне эквивалентными. Некоторые называют это <em>утиной типизацией</em>, утверждая, что любой объект, который может крякать (<code>quack()</code>), достаточно похож на утку, чтобы с ним можно было обращаться как с уткой.</p>

<p><code>show_vital_stats()</code> заботится о том, чтобы инвокант был валиден, только в смысле поддержки этих трёх методов, <code>name()</code>, <code>age()</code> и <code>diet()</code>, каждый из которых не имеет аргументов и возвращает нечто, что можно конкатенировать в строковом контексте. Вы можете иметь в своём коде сотню разных классов, не имеющих каких-либо очевидных взаимосвязей, но они будут работать с этим методом, если соответствуют этому ожидаемому поведению.</p>

<p>Подумайте, как вы могли бы обработать целый зоопарк животных без этой полиморфной функции? Выгода универсальности должна быть очевидна. Также, любые специфичные детали того, как рассчитать возраст оцелота или осьминога, могут принадлежать соответствующему классу &mdash; где они имеют наибольшее значение.</p>

<p>Конечно, одно лишь существование методов с именами <code>name()</code> или <code>age()</code> само по себе не определяет поведение объекта. Для объекта <code>Dog</code> <code>age()</code> может быть аксессором, с помощью которого вы можете узнать, что <code>$rodney</code> &mdash; 9 лет, а <code>$lucky</code> &mdash; 4 года. Объект <code>Cheese</code> может иметь метод <code>age()</code>, который позволяет вам контролировать, как долго хранить <code>$cheddar</code> чтобы его вкус заострился. <code>age()</code> может быть аксессором в одном классе, но не в другом:</p>

<pre><code>    # &#x441;&#x43A;&#x43E;&#x43B;&#x44C;&#x43A;&#x43E; &#x43B;&#x435;&#x442; &#x43A;&#x43E;&#x442;&#x443;?
    my $years = $zeppie-&gt;age();

    # &#x445;&#x440;&#x430;&#x43D;&#x438;&#x442;&#x44C; &#x441;&#x44B;&#x440; &#x43D;&#x430; &#x441;&#x43A;&#x43B;&#x430;&#x434;&#x435; &#x448;&#x435;&#x441;&#x442;&#x44C; &#x43C;&#x435;&#x441;&#x44F;&#x446;&#x435;&#x432;
    $cheese-&gt;age();</code></pre>

<p>Иногда полезно знать, <em>что</em> делает объект, и что это <em>означает</em>.</p>

<h3>Роли</h3>

<p><a name="roles"> </p>

<p><em>Роль</em> &mdash; это именованная совокупность поведений и состояний (footnote: Смотрите дизайн-документы Perl 6 на тему ролей по адресу http://feather.perl6.nl/syn/S14.html и исследуйте трейты Smalltalk на странице http://scg.unibe.ch/research/traits для получения глубоких подробностей.). Тогда как класс организует поведения и состояние в шаблон для создания объектов, роль организует именованную коллекцию поведений и состояния. Вы можете создать экземпляр класса, но не роли. Роль &mdash; это что-то, что делает класс.</p>

<p>Если у нас есть <code>Animal</code>, имеющий возраст, и <code>Cheese</code>, имеющий возраст, разница между ними может быть в том, что <code>Animal</code> выполняет роль <code>LivingBeing</code>, тогда как <code>Cheese</code> выполняет роль <code>Storable</code>:</p>

<pre><code>    package LivingBeing
    {
        use Moose::Role;

        requires qw( name age diet );
    }</code></pre>

<p>Всё, что имеет эту роль, должно предоставлять методы <code>name()</code>, <code>age()</code> и <code>diet()</code>. Класс <code>Cat</code> может явно обозначить, что он имеет эту роль:</p>

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;diet&#39;, is =&gt; &#39;rw&#39;, isa =&gt; &#39;Str&#39;;

        has &#39;birth_year&#39;,
            is      =&gt; &#39;ro&#39;,
            isa     =&gt; &#39;Int&#39;,
            default =&gt; sub { (localtime)[5] + 1900 };

        <strong>with &#39;LivingBeing&#39;;</strong>

        sub age { ... }
    }</code></pre>

<p></p>

<p>Строчка <code>with</code> заставляет Moose <em>скомпоновать</em> роль <code>LivingBeing</code> в класс <code>Cat</code>. Компоновка гарантирует, что все атрибуты и методы роли являются частью класса. <code>LivingBeing</code> требует от любого компонуемого класса предоставлять методы с названиями <code>name()</code>, <code>age()</code> и <code>diet()</code>. <code>Cat</code> удовлетворяет этим ограничениям. Если <code>LivingBeing</code> была бы скомпонована в класс, который не предоставляет эти методы, Moose бы выбросил исключение.</p>

<p>Ключевое слово <code>with</code>, используемое для применение роли к классу, должно находиться <em>после</em> объявлений атрибутов, чтобы компоновка могла распознать все сгенерированные методы-аксессоры.</p>

<p>Теперь все экземпляры <code>Cat</code> будут возвращать истинное значение, если их запросить, предоставляют ли они роль <code>LivingBeing</code>. А объекты <code>Cheese</code> &mdash; не будут:</p>

<pre><code>    say &#39;Alive!&#39; if $fluffy-&gt;DOES(&#39;LivingBeing&#39;);
    say &#39;Moldy!&#39; if $cheese-&gt;DOES(&#39;LivingBeing&#39;);</code></pre>

<p>Эта техника проектирования отделяет <em>возможности</em> классов и объектов от <em>реализации</em> этих классов и объектов. Поведение вычисления года рождения класса <code>Cat</code> само по себе тоже может быть ролью:</p>

<pre><code>    package CalculateAge::From::BirthYear
    {
        use Moose::Role;

        has &#39;birth_year&#39;,
            is      =&gt; &#39;ro&#39;,
            isa     =&gt; &#39;Int&#39;,
            default =&gt; sub { (localtime)[5] + 1900 };

        sub age
        {
            my $self = shift;
            my $year = (localtime)[5] + 1900;

            return $year - $self-&gt;birth_year();
        }
    }</code></pre>

<p>Выделение этой роли из <code>Cat</code> делает полезное поведение доступным для других классов. Теперь <code>Cat</code> может компоновать обе роли:</p>

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;diet&#39;, is =&gt; &#39;rw&#39;;

        <strong>with &#39;LivingBeing&#39;,</strong>
             <strong>&#39;CalculateAge::From::BirthYear&#39;;</strong>
    }</code></pre>

<p>Обратите внимание, как метод <code>age()</code> из <code>CalculateAge::From::BirthYear</code> удовлетворяет требование роли <code>LivingBeing</code>. Также заметьте, что любая провера того, что <code>Cat</code> выполняет роль <code>LivingBeing</code>, возвращает истинное значение. Выделение <code>age()</code> в роль изменило только детали того, <em>как</em> <code>Cat</code> вычисляет возраст. Это всё ещё <code>LivingBeing</code>. <code>Cat</code> может выбрать, имплементировать ли свой собственный возраст или получить его откуда-то ещё. Всё что имеет значение &mdash; это то, что он предоставляет <code>age()</code>, который удовлетворяет ограничениям <code>LivingBeing</code>.</p>

<p> </p>

<p>Как полиморфизм означает, что вы можете работать с разными объектами, имеющими одно и то же поведение, одним и тем же способом, так и этот <em>алломорфизм</em> означает, что объект может реализовывать одно и то же поведение разными способами.</p>

<p>Глубокий алломорфизм может уменьшить размер ваших классов и увеличить количество кода, разделяемого между ними. Он также позволяет вам именовать специфичные и обособленные поведения &mdash; очень полезно для проверки возможностей вместо реализаций.</p>

<p>  </p>

<p>Для сравнения ролей с другими техниками проектирования, такими как примеси, множественное наследование и манкипатчинг (monkeypatching) см. http://www.modernperlbooks.com/mt/2009/04/the-why-of-perl-roles.html.</p>

<h4>Роли и DOES()</h4>

<p> </p>

<p>Если вы компонуете роль в класс, класс и его экземпляры будут возвращать истинное значение если вы вызовете на них <code>DOES()</code>:</p>

<pre><code>    say &#39;This Cat is alive!&#39;
        if $kitten-&gt;DOES( &#39;LivingBeing&#39; );</code></pre>

<h3>Наследование</h3>

<p><a name="inheritance"></p>

<p>  </p>

<p>Объектная система Perl 5 поддерживает <em>наследование</em>, которое устанавливает связи между двумя классами, так, что один уточняет другой. Дочерний класс ведёт себя так же, как его родитель &mdash; он имеет то же самое количество и типы атрибутов, и может использовать те же самые методы. Он может иметь дополнительные данные и поведение, но вы можете использовать любой экземпляр дочернего класса там, где код ожидает его родителя. В некотором смысле, подкласс предоставляет роль, предполагаемую существованием его родительского класса.</p>

<p>Должны ли вы использовать роли или наследование? Роли предоставляют безопасность времени компоновки, лучшую проверку типов, лучшее разбиение кода и более тонкий контроль над именами и поведениями, но наследование более привычно опытным разработчикам на других языках. Используйте наследование в случае, если один класс на самом деле <em>расширяет</em> другой. Используйте роль, если класс требует дополнительного поведения, и если вы можете дать этому поведению осмысленное имя.</p>

<p>Рассмотрите класс <code>LightSource</code>, который предоставляет два публичных атрибута (<code>enabled</code> и <code>candle_power</code>) и два метода (<code>light</code> и <code>extinguish</code>):</p>

<pre><code>    package LightSource
    {
        use Moose;

        has &#39;candle_power&#39;, is      =&gt; &#39;ro&#39;,
                            isa     =&gt; &#39;Int&#39;,
                            default =&gt; 1;

        has &#39;enabled&#39;, is      =&gt; &#39;ro&#39;,
                       isa     =&gt; &#39;Bool&#39;,
                       default =&gt; 0,
                       writer  =&gt; &#39;_set_enabled&#39;;

        sub light
        {
            my $self = shift;
            $self-&gt;_set_enabled(1);
        }

        sub extinguish
        {
            my $self = shift;
            $self-&gt;_set_enabled(0);
        }
    }</code></pre>

<p>(Заметьте, что опция <code>writer</code> атрибута <code>enabled</code> создаёт приватный аксессор, используемый в классе для установки значения.)</p>

<h4>Наследование и атрибуты</h4>

<p>Подкласс <code>LightSource</code> может определить супер-свечу, дающую в сто раз больше света:</p>

<pre><code>    package SuperCandle
    {
        use Moose;

        <strong>extends &#39;LightSource&#39;</strong>;

        has &#39;<strong>+</strong>candle_power&#39;, default =&gt; 100;
    }</code></pre>

<p></p>

<p><code>extends</code> принимает список имён классов для использования их в качестве родителей текущего класса. Если бы это была единственная строка в этом классе, объекты <code>SuperCandle</code> вели бы себя в точности так же, как объекты <code>LightSource</code>. Они имели бы оба атрибута, <code>candle_power</code> и <code>enabled</code>, так же как и методы <code>light()</code> и <code>extinguish()</code>.</p>

<p><code>+</code> в начале имени атрибута (как у <code>candle_power</code>) указывает, что текущий класс делает с этим атрибутом что-то особенное. Здесь супер-свеча переопределяет значение по умолчанию источника света, так что любой новый созданный объект <code>SuperCandle</code> будет иметь световое значение в 100 свечей.</p>

<p>Когда вы вызываете <code>light()</code> или <code>extinguish()</code> на объекте <code>SuperCandle</code>, Perl будет искать методы в классе <code>SuperCandle</code>, а затем в каждом из его родителей. В данном случае, эти методы находятся в классе <code>LightSource</code>.</p>

<p></p>

<p>Наследование атрибутов работает аналогично (см. <code>perldoc Class::MOP</code>).</p>

<h4>Порядок диспетчеризации методов</h4>

<p>      </p>

<p><em>Порядок диспетчеризации методов</em> (<em>или порядок разрешения методов</em>, <em>method resolution order</em>, или <em>MRO</em>) очевиден для классов, имеющих одного родителя. Искать в классе объекта, затем в его родителе, и так далее, до тех пор, пока метод не будет найден или родители не закончатся. Классы, наследующие от нескольких родителей (<em>множественное наследование</em>) &mdash; <code>Hovercraft</code> расширяет и <code>Boat</code>, и <code>Car</code> &mdash; требуют более хитрой диспетчеризации. Суждение о множественном наследовании сложно. По возможности избегайте множественного наследования.</p>

<p>Perl 5 использует стратегию разрешения методов поиском в глубину. Он ищет класс родителя, названного <em>первым</em>, и всех родителей этого родителя рекурсивно, прежде чем искать в классах следующих родителей. Прагма <code>mro</code> (<a href="chapter_08.html#pragmas">Прагмы</a>) предоставляет альтернативные стратегии, включая стратегию C3 MRO, которая ищет в непосредственных родителях заданного класса, прежде чем искать в их родителях.</p>

<p>См. <code>perldoc mro</code> для дальнейших деталей.</p>

<h4>Наследование и методы</h4>

<p> </p>

<p>Как и с атрибутами, подклассы могут переопределять методы. Представьте свет, который вы не можете потушить:</p>

<pre><code>    package Glowstick
    {
        use Moose;

        extends &#39;LightSource&#39;;

        sub extinguish {}
    }</code></pre>

<p>Вызов <code>extinguish()</code> на светящейся палочке не будет делать ничего, несмотря на то, что метод из <code>LightSource</code> что-то делает. Диспетчеризация методов найдёт метод подкласса. Вы, возможно, не имели намерения так делать. Если имели, используйте функцию Moose <code>override</code> чтобы ясно выразить своё намерение.</p>

<p>Внутри переопределённого метода функция Moose <code>super()</code> позволит вам вызвать переопределённый метод:</p>

<pre><code>    package LightSource::Cranky
    {
        use Carp &#39;carp&#39;;
        use Moose;

        extends &#39;LightSource&#39;;

        <strong>override</strong> light =&gt; sub
        {
            my $self = shift;

            carp &quot;Can&#39;t light a lit light source!&quot;
                if $self-&gt;enabled;

            <strong>super()</strong>;
        };

        <strong>override</strong> extinguish =&gt; sub
        {
            my $self = shift;

            carp &quot;Can&#39;t extinguish unlit light source!&quot;
                unless $self-&gt;enabled;

            <strong>super()</strong>;
        };
    }</code></pre>

<p>Этот подкласс добавляет предупреждение при попытке зажечь или потушить источник света, который уже находится в нужном состоянии. Функция <code>super()</code> отправляет к реализации текущего метода в ближайшем родителе, согласно стандартному порядку разрешения методов Perl 5.</p>

<p>Модификаторы методов Moose могут делать похожие вещи &mdash; и больше. Смотрите <code>perldoc Moose::Manual::MethodModifiers</code>.</p>

<h4>Наследование и isa()</h4>

<p> </p>

<p>Метод <code>isa()</code> в Perl возвращает истину, если его инвокант является названным классом или расширяет его. Этот инвокант может быть именем класса или экземпляром объекта.</p>

<pre><code>    say &#39;Looks like a LightSource&#39;
        if $sconce-&gt;isa( &#39;LightSource&#39; );

    say &#39;Hominidae do not glow&#39;
        unless $chimpy-&gt;isa( &#39;LightSource&#39; );</code></pre>

<h3>Moose и Perl 5 ООП</h3>

<p></p>

<p>Moose предоставляет много возможностей помимо стандартного ООП Perl 5. Хотя вы <em>можете</em> построить всё, что вы получаете с Moose, сами (<a href="chapter_07.html#blessed_references">Благословлённые ссылки</a>), или смастерить это из нескольких CPAN-дистрибутивов, Moose стоит использования. Это логически связанное целое, с хорошей документацией. Многие важные проекты успешно его используют. Он имеет зрелое и внимательное сообщество разработчиков.</p>

<p>    </p>

<p>Moose позаботится о конструкторах, деструкторах, аксессорах и инкапсуляции. Вам придётся объявить, чего вы хотите, но то, что вы получите, будет безопасным и простым в использовании. Объекты Moose могут расширять и работать с объектами стандартной системы Perl 5.</p>

<p>Moose также даёт возможность <em>метапрограммирования</em> &mdash; манипулирования вашими объектами через сам Moose. Если вы когда-нибудь интересовались, какие методы доступны в классе или объекте, или какие атрибуты объект поддерживает, эта информация доступна:</p>

<pre><code>    my $metaclass = Monkey::Pants-&gt;meta();

    say &#39;Monkey::Pants instances have the attributes:&#39;;

    say $_-&gt;name for $metaclass-&gt;get_all_attributes;

    say &#39;Monkey::Pants instances support the methods:&#39;;

    say $_-&gt;fully_qualified_name
        for $metaclass-&gt;get_all_methods;</code></pre>

<p>Вы даже можете увидеть, какие классы расширяют заданный класс:</p>

<pre><code>    my $metaclass = Monkey-&gt;meta();

    say &#39;Monkey is the superclass of:&#39;;

    say $_ for $metaclass-&gt;subclasses;</code></pre>

<p>Смотрите <code>perldoc Class::MOP::Class</code> для большей информации об операциях с метаклассами и <code>perldoc Class::MOP</code> для информации о метапрограммировании Moose.</p>

<p>Moose и его <em>протокол метаобъектов</em> (<em>meta-object protocol</em>, или MOP) даёт возможность лучшего синтаксиса для объявления и работы с классами и объектами в Perl 5. Это корректный код на Perl 5:</p>

<pre><code>    use MooseX::Declare;

    <strong>role</strong> LivingBeing { requires qw( name age diet ) }

    <strong>role</strong> CalculateAge::From::BirthYear
    {
        has &#39;birth_year&#39;,
            is      =&gt; &#39;ro&#39;,
            isa     =&gt; &#39;Int&#39;,
            default =&gt; sub { (localtime)[5] + 1900 };

        <strong>method</strong> age
        {
            return (localtime)[5] + 1900
                                  - $self-&gt;birth_year();
        }
    }

    <strong>class Cat with LivingBeing</strong>
              <strong>with CalculateAge::From::BirthYear</strong>
    {
        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;diet&#39;, is =&gt; &#39;rw&#39;;
    }</code></pre>

<p> </p>

<p>CPAN-дистрибутив <code>MooseX::Declare</code> использует <code>Devel::Declare</code> для добавления нового Moose-специфичного синтаксиса. Ключевые слова <em>class</em>, <em>role</em> и <em>method</em> уменьшают количество текста, необходимого для написания хорошего объектно-ориентированного кода на Perl 5. Обратите особое внимание на декларативную природу этого примера, а также на отсутствие <code>my $self = shift;</code> в <code>age()</code>.</p>

<p>Хотя Moose и не является частью ядра Perl 5, его популярность гарантирует его доступность в дистрибутивах многих ОС. Дистрибутивы Perl 5, такие как Strawberry Perl и ActivePerl, тоже его включают. Несмотря на то, что Moose &mdash; CPAN-модуль, а не базовая библиотека, его чистота и простота делают его неотъемлемой частью современного Perl-программирования.</p>

<p></p>

<p>Moose &mdash; не маленькая библиотека, но мощная. CPAN-модуль <code>Any::Moose</code> помогает уменьшить стоимость возможностей, которые вы не используете.</p>

<h2>Благословлённые ссылки</h2>

<p><a name="blessed_references"></p>

<p>Базовая система объектов Perl 5 сознательно минималистична. Она включает всего три правила:</p>

<ul>

<li>Класс &mdash; это пакет.</li>

<li>Метод &mdash; это функция.</li>

<li>(Благословлённая) ссылка &mdash; это объект.</li>

</ul>

<p>Основываясь на этих трёх правилах, вы можете построить что угодно, но это всё, что вы получаете по умолчанию. Этот минимализм для больших проектов может быть непрактичен &mdash; особенно неловки и ограниченны возможности увеличения абстракции посредством метапрограммирования (<a href="chapter_09.html#code_generation">Кодогенерация</a>). Moose (<a href="chapter_07.html#moose">Moose</a>) &mdash; более подходящий выбор для современных программ, размер которых больше чем несколько сотен строк кода, хотя большое количество унаследованного кода всё ещё использует стандартное ООП Perl 5.</p>

<p> </p>

<p>Последняя часть стандартного ООП Perl 5 &mdash; благословлённая ссылка. Встроенная функция bless ассоциирует имя класса со ссылкой. Эта ссылка становится корректным инвокантом, и Perl будет выполнять на ней диспетчеризацию методов, используя ассоциированный класс.</p>

<p>  </p>

<p>Конструктор &mdash; это метод, создающий и благословляющий ссылку. По соглашению конструкторы имеют имя <code>new()</code>, но это не обязательно. Кроме того, конструкторы почти всегда являются <em>методами класса</em>.</p>

<p><code>bless</code> принимает два аргумента, ссылку и имя класса. Она возвращает ссылку. Ссылка может быть пустой. Класс ещё не обязательно должен существовать. Вы даже можете использовать <code>bless</code> за пределами конструктора или класса (хотя все программы, кроме самых простых, должны использовать настоящие конструкторы). Канонический конструктор выглядит так:</p>

<pre><code>    sub new
    {
        my $class = shift;
        bless {}, $class;
    }</code></pre>

<p>По замыслу, этот конструктор получает имя класса как инвокант метода. Но вы можете и захардкодить имя класса, потеряв при этом в гибкости. Параметрический конструктор даёт возможность повторного использования посредством наследования, делегирования или экспорта.</p>

<p></p>

<p>Используемый тип ссылки имеет значение только для того, как объект хранит свои <em>данные экземпляра</em>. Он не оказывает никакого другого влияния на результирующий объект. Ссылки на хеши наиболее распространены, но благословить можно любой тип ссылки:</p>

<pre><code>    my $array_obj  = bless [], $class;
    my $scalar_obj = bless \$scalar, $class;
    my $sub_obj    = bless \&amp;some_sub, $class;</code></pre>

<p>Классы Moose определяют атрибуты объекта декларативно, но стандартное ООП Perl 5 недостаточно формально. Класс, представляющий игроков в баскетбол, и хранящий номер футболки и позицию, может использовать такой конструктор:</p>

<pre><code>    package Player
    {
        sub new
        {
            my ($class, %attrs) = @_;
            bless \%attrs, $class;
        }
    }</code></pre>

<p>&hellip;и создавать игроков так:</p>

<pre><code>    my $joel  = Player-&gt;new( number  =&gt; 10,
                            position =&gt; &#39;center&#39; );

    my $dante = Player-&gt;new( number   =&gt; 33,
                             position =&gt; &#39;forward&#39; );</code></pre>

<p>Методы класса могут обращаться к атрибутам объекта напрямую как к элементам хеша:</p>

<pre><code>    sub format
    {
        my $self = shift;
        return &#39;#&#39;       . $self-&gt;{number}
             . &#39; plays &#39; . $self-&gt;{position};
    }</code></pre>

<p>&hellip;но так же это может делать и любой другой код, так что любое изменение внутреннего представления объекта может сломать другой код. Методы-аксессоры безопаснее:</p>

<pre><code>    sub number   { return shift-&gt;{number}   }
    sub position { return shift-&gt;{position} }</code></pre>

<p>&hellip;и вот вы уже начинаете вручную писать то, что Moose даёт вам бесплатно. Мало того, Moose поощряет использовать аксессоры вместо прямого доступа, скрывая код генерации аксессоров. Прощайте, соблазны.</p>

<h3>Поиск методов и наследование</h3>

<p> </p>

<p>При наличии благословлённой ссылки, вызов метода осуществляется следующим образом:</p>

<pre><code>    my $number = $joel-&gt;number();</code></pre>

<p>&hellip;ищет имя класса, ассоциированного с благословлённой ссылкой <code>$joel</code> &mdash; в данном случае <code>Player</code>. Затем Perl ищет функцию (footnote: Вспомните, что Perl 5 не делает различия между функциями в пространстве имён и методами.) с именем <code>number()</code> в классе <code>Player</code>. Если такой функции не существует и если <code>Player</code> расширяет другой класс, Perl ищет в родительском классе (и так далее и так далее), до тех пор, пока не найдёт <code>number()</code>. Если Perl находит <code>number()</code>, он вызывает этот метод с <code>$joel</code> в качестве инвоканта.</p>

<p></p>

<p>CPAN-модуль <code>namespace::autoclean</code> может помочь избежать непреднамеренных коллизий между импортируемыми функциями и методами.</p>

<p> </p>

<p>Moose предоставляет <code>extends</code> для отслеживания связей наследования, Perl 5 же использует глобальную переменную пакета с именем <code>@ISA</code>. Диспетчер методов ищет в <code>@ISA</code> каждого класса имена его родительских классов. Если <code>InjuredPlayer</code> расширяет <code>Player</code>, вы можете написать так:</p>

<pre><code>    package InjuredPlayer
    {
        @InjuredPlayer::ISA = &#39;Player&#39;;
    }</code></pre>

<p> </p>

<p>Прагма <code>parent</code> (<a href="chapter_08.html#pragmas">Прагмы</a>) чище (footnote: Старый код может использовать прагму <code>base</code>, но <code>parent</code> заменила <code>base</code> в Perl 5.10.):</p>

<pre><code>    package InjuredPlayer
    {
        use parent &#39;Player&#39;;
    }</code></pre>

<p>Moose имеет собственную метамодель, сохраняющую расширенную информацию о наследовании; это обеспечивает дополнительные возможности.</p>

<p> </p>

<p>Вы можете наследовать от нескольких родительских классов:</p>

<pre><code>    package InjuredPlayer;
    {
        use parent qw( Player Hospital::Patient );
    }</code></pre>

<p>&hellip;хотя есть предостережения против множественного наследования и сложности диспетчеризации методов. Рассмотрите использование в качестве замены ролей (<a href="chapter_07.html#roles">Роли</a>) или модификаторов методов Moose.</p>

<h3>AUTOLOAD</h3>

<p>  </p>

<p>Если в классе инвоканта или в любом из его суперклассов нет подходящего метода, дальше Perl 5 будет искать функцию <code>AUTOLOAD()</code> (<a href="chapter_05.html#autoload">AUTOLOAD</a>) в каждом классе в соответствии с выбранным порядком разрешения методов. Perl вызовет любую найденную функцию <code>AUTOLOAD()</code>, чтобы она предоставила или отклонила желаемый метод.</p>

<p><code>AUTOLOAD()</code> делает множественное наследование гораздо более сложным для понимания.</p>

<h3>Перегрузка методов и SUPER</h3>

<p>Как и в Moose, в стандартном ООП Perl 5 вы можете перегружать методы. В отличие от Moose, стандартный Perl 5 не предоставляет механизмов для указания вашего <em>намерения</em> переопределить родительский метод. Хуже того, любая функция, которую вы предварительно определили, определили или импортировали в дочерний класс, может перегрузить метод родительского класса, если имеет то же самое имя. Даже если вы забыли использовать предоставляемую Moose систему перегрузки с <code>override</code>, она по крайней мере существует. Стандартное ООП Perl 5 не предлагает такой защиты.</p>

<p></p>

<p>Чтобы перегрузить метод в дочернем классе, объявите метод с тем же именем, что и метод в родительском классе. Внутри перегруженного метода можно вызвать родительский метод с помощь подсказки диспетчера <code>SUPER::</code>:</p>

<pre><code>    sub overridden
    {
        my $self = shift;
        warn &#39;Called overridden() in child!&#39;;
        return $self-&gt;SUPER::overridden( @_ );
    }</code></pre>

<p>Префикс <code>SUPER::</code> у имени метода указывает диспетчеру методов перейти к перегруженному методу с соответствующим именем. Вы можете указать собственные аргументы для перегруженного метода, но большая часть кода использует <code>@_</code>. Не забудьте удалить вызывающую сущность с помощью <code>shift</code>, если вы так делаете.</p>

<p></p>

<p><code>SUPER::</code> имеет сбивающий с толку недостаток: он диспетчеризует к родителю пакета, в который был <em>скомпилирован</em> перегруженный метод. Если вы импортировали этот метод из другого пакета, Perl с удовольствием направит к <em>неверному</em> родителю. Потребность в обратной совместимости привела к сохранению этой неудачной функции. Модуль <code>SUPER</code> из CPAN предлагает обходной путь. В Moose <code>super()</code> не страдает от такого недостатка.</p>

<h3>Стратегии обращения с благословлёнными ссылками</h3>

<p>Если благословлённые ссылки выглядят минималистичными, коварными и сбивающими с толку, такие они и есть. Moose &mdash; огромное улучшение. Используйте его везде, где возможно. Если же вам придётся поддерживать код, использующий благословлённые ссылки, или вы ещё не смогли убедить свою команду полностью перейти на Moose, вы можете обойти некоторые проблемы благословлённых ссылок с помощью дисциплины.</p>

<p></p>

<ul>

<li>Повсеместно используйте методы-аксессоры, даже в методах вашего класса. Рассмотрите использование модуля наподобие <code>Class::Accessor</code>, чтобы избежать повторяющегося кода.</li>

<li>По возможности избегайте использования <code>AUTOLOAD()</code>. Если вам <em>необходимо</em> его использовать, используйте предварительные объявления ваших функций (<a href="chapter_05.html#functions">Объявление функций</a>), чтобы помочь Perl понять, какая функция <code>AUTOLOAD</code> предоставляет реализацию метода.</li>

<li>Исходите из предположения, что кому-нибудь, где-нибудь рано или поздно потребуется унаследовать от ваших классов (или делегировать, или переопределить интерфейс). Упростите эту задачу, не предполагая понимания внутренних деталей вашего кода, используя двухаргументную форму <code>bless</code>, и разбивая ваши классы на наименьшие возможные самостоятельные единицы кода.</li>

<li>Не смешивайте функции и методы в одном классе.</li>

<li>Используйте один файл <em>.pm</em> для каждого класса, если только класс не является маленьким, самодостаточным вспомогательным инструментом, используемым в одном месте.</li>

</ul>

<h2>Рефлексия</h2>

<p><a name="reflection"></p>

<p> </p>

<p><em>Рефлексия</em> (или <em>интроспекция</em>) &mdash; это процесс получения от программы информации о ней самой во время её выполнения. Работая с кодом как с данными, вы можете управлять кодом так же, как вы управляете данными. На этом принципе основана кодогенерация (<a href="chapter_09.html#code_generation">Кодогенерация</a>).</p>

<p></p>

<p><code>Class::MOP</code> из Moose (<a href="chapter_09.html#class_mop">Class::MOP</a>) упрощает многие задачи рефлексии для объектных систем. Если вы используете Moose, его система метапрограммирования поможет вам. Если нет, несколько других идиом стандартного Perl 5 помогут вам инспектировать и манипулировать запущенными программами.</p>

<h3>Проверка того, что модуль загружен</h3>

<p></p>

<p>Если вы знаете имя модуля, вы можете проверить, считает ли Perl, что этот модуль загружен, заглянув в хеш <code>%INC</code>. Когда Perl 5 загружает код с помощью <code>use</code> или <code>require</code>, он сохраняет запись в <code>%INC</code>, где ключ &mdash; файловый путь загружаемого модуля, а значение &mdash; полный путь к модулю на диске. Другими словами, загрузка <code>Modern::Perl</code> фактически делает следующее:</p>

<pre><code>    $INC{&#39;Modern/Perl.pm&#39;} =
        &#39;.../lib/site_perl/5.12.1/Modern/Perl.pm&#39;;</code></pre>

<p>Точный путь будет различаться в зависимости от вашей инсталляции. Чтобы проверить, что Perl успешно загрузил модуль, преобразуйте имя модуля в каноническую файловую форму и проверьте существование этого ключа в <code>%INC</code>:</p>

<pre><code>    sub module_loaded
    {
        (my $modname = shift) =~ s!::!/!g;
        return exists $INC{ $modname . &#39;.pm&#39; };
    }</code></pre>

<p>  </p>

<p>Как и с <code>@INC</code>, любой код в любом месте может манипулировать <code>%INC</code>. Некоторые модули (такие как <code>Test::MockObject</code> или <code>Test::MockModule</code>) манипулируют <code>%INC</code> с благими намерениями. В зависимости от уровня вашей паранойи, вы можете сами проверять путь и ожидаемое содержимое пакета.</p>

<p></p>

<p>Функция <code>is_class_loaded()</code> CPAN-модуля <code>Class::Load</code> инкапсулирует эту проверку <code>%INC</code>.</p>

<h3>Проверка существования пакета</h3>

<p>Чтобы проверить существование пакета в вашей программе &mdash; того, что какой-то код где-то выполнил директиву <code>package</code> с заданным именем &mdash; проверьте, что пакет наследует от <code>UNIVERSAL</code>. Всё, что расширяет <code>UNIVERSAL</code>, должно так или иначе предоставлять метод <code>can()</code>. Если такого пакета не существует, Perl выбросит исключение о некорректной вызывающей сущности, так что оберните этот вызов в блок <code>eval</code>:</p>

<pre><code>    say &quot;$pkg exists&quot; if eval { $pkg-&gt;can( &#39;can&#39; ) };</code></pre>

<p>Альтернативный подход &mdash; копание в таблице символов Perl.</p>

<h3>Проверка существования класса</h3>

<p>Так как Perl 5 не делает строгих различий между пакетами и классами, лучшее, что вы можете сделать без Moose &mdash; проверить существование пакета ожидаемого имени класса. Вы <em>можете</em> проверить с помощью <code>can()</code>, что этот пакет предоставляет <code>new()</code>, но нет никаких гарантий, что найденный <code>new()</code> будет методом или конструктором.</p>

<h3>Проверка номера версии модуля</h3>

<p>Модули не обязаны предоставлять номера версий, но каждый пакет наследует метод <code>VERSION()</code> от универсального родительского класса <code>UNIVERSAL</code> (<a href="chapter_09.html#universal">Пакет UNIVERSAL</a>):</p>

<pre><code>    my $mod_ver = $module-&gt;VERSION();</code></pre>

<p><code>VERSION()</code> возвращает номер версии заданного модуля, если он определён. В противном случае он возвращает <code>undef</code>. Если модуль не существует, метод тоже вернёт <code>undef</code>.</p>

<h3>Проверка существования функции</h3>

<p>Чтобы проверить, существует ли функция в пакете, вызовите <code>can()</code> как метод класса на имени пакета:</p>

<pre><code>    say &quot;$func() exists&quot; if $pkg-&gt;can( $func );</code></pre>

<p>Perl выбросит исключение, если <code>$pkg</code> не является допустимым инвокантом; оберните вызов метода в блок <code>eval</code> если у вас есть какие-либо сомнения в его валидности. Имейте ввиду, что функция, реализованная в терминах <code>AUTOLOAD()</code> (<a href="chapter_05.html#autoload">AUTOLOAD</a>), может давать неправильный ответ, если в пакете функции нет корректного предварительного объявления функции или корректной перегрузки <code>can()</code>. Это ошибка в другом пакете.</p>

<p>Используйте эту технику для определения того, импортировал ли <code>import()</code> модуля функцию в текущее пространство имён:</p>

<pre><code>    say &quot;$func() imported!&quot; if __PACKAGE__-&gt;can( $func );</code></pre>

<p>Как и в случае проверки существования пакета, вы <em>можете</em> сами покопаться в таблице символов, если у вас есть для этого достаточно терпения.</p>

<h3>Проверка существования метода</h3>

<p>Нет надёжного способа для рефлексии определить разницу между функцией и методом.</p>

<h3>Копание в таблице символов</h3>

<p> </p>

<p>Таблица символов Perl 5 &mdash; это специальный тип хеша, где ключи &mdash; это имена глобальных символов пакета, а значения &mdash; тайпглобы (typeglob). <em>Тайпглоб</em> &mdash; это внутренняя структура данных, которая может содержать любой из или все типы &mdash; скаляр, массив, хеш, дескриптор файла и функцию.</p>

<p>Обратиться к символьной таблице как к хешу можно добавив двойное двоеточие к имени пакета. Например, символьная таблица пакета <code>MonkeyGrinder</code> доступна как <code>%MonkeyGrinder::</code>.</p>

<p>Вы <em>можете</em> проверить существование конкретных имён символов в таблице символов с помощью оператора <code>exists</code> (или манипулировать таблицей символов для <em>добавления</em> или <em>удаления</em> символов, если хотите). Однако имейте ввиду, что определённые изменения в ядре Perl 5 модифицировали детали того, что хранят тайпглобы, когда и как.</p>

<p></p>

<p>Загляните в секцию &laquo;Symbol Tables&raquo; в <code>perldoc perlmod</code> для получения подробностей, а затем отдайте предпочтение другим техникам рефлексии, описанным в этом разделе. Если вам действительно нужно манипулировать таблицами символов и тайпглобами, рассмотрите использование вместо этого CPAN-модуля <code>Package::Stash</code>.</p>

<h2>Продвинутое ОО в Perl</h2>

<p><a name="advanced_oo"></p>

<p>Создание и использование объектов в Perl 5 с Moose (<a href="chapter_07.html#moose">Moose</a>) просто. <em>Проектирование</em> хороших программ &mdash; нет. Вы должны выдерживать баланс между проектированием слишком много и слишком мало. Только практический опыт может помочь вам понять наиболее важные техники проектирования, но несколько принципов могут указать вам направление.</p>

<h3>Предпочитайте компоновку наследованию</h3>

<p> </p>

<p>Новички в ОО-проектировании зачастую чрезмерно применяют наследование для повторного использования кода и применения полиморфизма. Результат этого &mdash; глубокая иерархия классов с ответственностями, разбросанными по неверным местам. Поддержка этого кода тяжела &mdash; кто знает, где добавить или отредактировать поведение? Что случится, если код в одном месте конфликтует с кодом, объявленным где-то ещё?</p>

<p> </p>

<p>Наследование &mdash; лишь один из многих инструментов. <code>Car</code> может расширять <code>Vehicle::Wheeled</code> (<em>отношение is-a</em>, <em>является</em>), но лучше, если <code>Car</code> будет <em>содержать</em> несколько объектов <code>Wheel</code> в качестве атрибутов экземпляра (<em>отношение has-a</em>, <em>имеет</em>).</p>

<p>Разбиение сложных классов на меньшие, специализированные сущности (будь то классы или роли), улучшает инкапсуляцию и уменьшает возможность того, что какой-либо класс или роль слишком разрастётся. Меньшие, более простые и лучше инкапсулированные сущности проще для понимания и поддержки.</p>

<h3>Принцип единственной ответственности</h3>

<p></p>

<p>Когда вы проектируете вашу объектную систему, обдумайте ответственности каждой сущности. Например, объект <code>Employee</code> может представлять индивидуальную информацию об имени человека, контактную информацию и другие личные данные, а объект <code>Job</code> может представлять рабочие обязанности. Разделение этих сущностей по их ответственностям позволяет классу <code>Employee</code> принимать во внимание только проблему управления информацией, касающейся того, кто человек есть, а классу <code>Job</code> &mdash; представлять, что человек делает. (Например, два сотрудника <code>Employee</code> могут иметь договорённость по разделению одной работы <code>Job</code>.)</p>

<p>Если каждый класс имеет единственную ответственность, вы улучшаете инкапсуляцию свойственных классу данных и поведения и уменьшаете связанность между классами.</p>

<h3>Не повторяйтесь</h3>

<p></p>

<p>Сложность и дублирование затрудняют разработку и поддержку. Принцип DRY (Don't Repeat Yourself, Не повторяйтесь) &mdash; напоминание о необходимости находить и устранять дублирование внутри системы. Дублирование существует в данных, так же, как и в коде. Вместо повторения конфигурационной информации, пользовательских данных и других артефактов внутри вашей системы, создаёте единое, каноническое представление этой информации, из которого вы сможете генерировать другие артефакты.</p>

<p>Этот принцип помогает уменьшить вероятность того, что важные части вашей системы могут потерять синхронизированность, а также помогает найти оптимальное представление системы и её данных.</p>

<h3>Принцип замещения Лисков</h3>

<p></p>

<p>Принцип замещения Лисков предполагает, что вы должны иметь возможность поставить специализацию класса или роли на место оригинала, не нарушив API оригинала. Другими словами, объект должен быть настолько же или более общим в отношении того, что он ожидает, и как минимум так же конкретен в отношении того, что он производит.</p>

<p>Представьте два класса, <code>Dessert</code> и его дочерний класс <code>PecanPie</code>. Если классы следуют принципу замещения Лисков, вы можете заменить в наборе тестов каждое использование объектов <code>Dessert</code> объектами <code>PecanPie</code>, и все тесты должны пройти (footnote: См. &laquo;IS-STRICTLY-EQUIVALENT-TO-<a href="#raquo">link</a> Рэга Брейтуейта (Reg Braithwaite) для дальнейших подробностей, http://weblog.raganwald.com/2008/04/is-strictly-equivalent-to.html.).</p>

<h3>Подтипы и приведение типов</h3>

<p><a name="subtypes"> <a name="coercions">   </p>

<p>Moose позволяет вам объявить и использовать типы, а также расширять их с помощью подтипов, для формирования ещё более специализированного описания того, что представляют собой ваши данные и как они себя ведут. Эти аннотации типов помогают проверить, что данные, с которыми вы собираетесь работать в конкретных функциях и методах, соответствующи, и даже указать механизмы преобразования данных одного типа в данные другого типа.</p>

<p> </p>

<p>См. <code>Moose::Util::TypeConstraints</code> и <code>MooseX::Types</code> для дальнейшей информации.</p>

<h3>Неизменяемость</h3>

<p><a name="immutability"></p>

<p></p>

<p>Новички в ООП зачастую обращаются с объектами так, как будто они пачка записей, использующих методы для получения и установки внутренних значений. Эта простая техника ведёт к неприятному соблазну распространить обязанности объекта по всей системе.</p>

<p>В случае хорошо спроектированного объекта, вы говорите ему, что делать, но не как это делать. Как правило большого пальца, если обнаружили, что обращаетесь к данным экземпляра объекта (даже с помощью методов-аксессоров), у вас, возможно, слишком много доступа к внутренностям объекта.</p>

<p>Один из подходов, предотвращающих такое поведение &mdash; считать объект неизменяемым. Передайте нужные данные в их конструкторы, а затем запретите любые модификации этой информации из-за пределов класса. Не делайте видимыми методы изменения данных экземпляра. Сконструированные таким образом объекты всегда корректны с момента своего создания и не могут стать некорректными в результате внешних манипуляций. Для достижения этого требуется огромная дисциплина, но получающиеся в результате системы надёжны, легко тестируются и поддерживаются.</p>

<p>Некоторые варианты проектирования заходят так далеко, что запрещают изменение данных экземпляра <em>внутри</em> самого класса, хотя этого достичь гораздо труднее.</p>

</body></html>