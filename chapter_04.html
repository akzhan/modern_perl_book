<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="style.css" type="text/css"></head><body><h1>Операторы</h1>

<p><a name="operators">  </p>

<p>Некоторые называют Perl &laquo;оператор-ориентированным языком&raquo;. Чтобы понять программу на Perl, вы должны понять как её операторы взаимодействуют со своими операндами.</p>

<p><em>Оператор</em> в Perl &mdash; это набор из одного или более символов, используемый как часть синтаксиса языка. Каждый оператор оперирует нолём или более <em>операндов</em>. Воспринимайте операторы как особый вид функций, понимаемых парсером, а их операторы &mdash; как аргументы.</p>

<h2>Свойства операторов</h2>

<p><a name="operator_characteristics"> </p>

<p>Каждый оператор обладает несколькими важными свойствами, определяющими его поведение: количество операндов, которыми он оперирует, его отношения с другими операторами и его синтаксические возможности.</p>

<p><code>perldoc perlop</code> и <code>perldoc perlsyn</code> предоставляют обширную информацию об операторах Perl, но документация подразумевает, что вы уже знакомы с некоторыми деталями того, как они работают. Основные понятия компьютерных наук могут выглядеть внушительно, но когда вы проберётесь через их названия, они довольно очевидны. Неявно вы их уже понимаете.</p>

<h3>Приоритет</h3>

<p><a name="precedence"> </p>

<p><em>Приоритет</em> оператора определяет, когда Perl должен вычислить его в выражении. Порядок вычисления следует от наивысших приоритетов к наинизшим. Так как приоритет умножения выше, чем приоритет сложения, результатом вычисления <code>7 + 7 * 10</code> будет <code>77</code>, а не <code>140</code>.</p>

<p>Чтобы заставить какие-либо операторы вычисляться раньше других, сгруппируйте их подвыражения в круглые скобки. В выражении <code>(7 + 7) * 10</code> группировка сложения в одно целое приводит к тому, что оно вычисляется раньше умножения. Результатом будет <code>140</code>.</p>

<p><code>perldoc perlop</code> содержит таблицу приоритетов. Прочитайте её, поймите, но не утруждайте себя запоминанием (почти никто этого не делает). Лучше сохраняйте свои выражения простыми и добавляйте скобки для прояснения своего замысла.</p>

<p>В случае, если два оператора имеют одинаковый приоритет, ситуацию разрешают другие факторы, такие как ассоциативность (<a href="chapter_04.html#associativity">Ассоциативность</a>) и фиксность (<a href="chapter_04.html#fixity">Фиксность</a>).</p>

<h3>Ассоциативность</h3>

<p><a name="associativity">     </p>

<p><em>Ассоциативность</em> оператора определяет, вычисляется он слева направо или справа налево. Сложение левоассоциативно, поэтому <code>2 + 3 + 4</code> сначала вычисляет <code>2 + 3</code>, а затем добавляет к результату <code>4</code>. Возведение в степень правоассоциативно, поэтому <code>2 ** 3 ** 4</code> вычисляет сначала <code>3 ** 4</code>, а затем возводит <code>2</code> в 81-ую степень.</p>

<p>Стоит запомнить приоритет и ассоциативность распространённых математических операторов, но, опять-таки, простота вам поможет. Используйте скобки для прояснения своего замысла.</p>

<blockquote>

<p>  </p>

<p>Базовый модуль <code>B:Deparse</code> &mdash; бесценный отладочный инструмент. Выполните <code>perl -MO=Deparse,-p</code> с фрагментом кода чтобы уведить в точности как Perl обрабатывает приоритет и ассоциативность операторов. Флаг <code>-p</code> добавляет дополнительные групирующие скобки, которые часто проясняют порядок вычисления.</p>

<p>Имейте ввиду, что оптимизатор Perl упростит математические операции как описано в предыдущих примерах; вместо этого используйте переменные, как в <code>$x ** $y ** $z</code>.</p>

</blockquote>

<h3>Арность</h3>

<p><a name="arity"></p>

<p>      </p>

<p><em>Арность</em> оператора &mdash; это количество операндов, которыми он оперирует. <em>Нольарный</em> оператор имеет ноль операндов. <em>Унарный</em> оператор имеет один оператор. <em>Бинарный</em> оператор имеет два операнда. <em>Тернарный</em> оператор имеет три операнда. Оператор <em>списочной арности</em> оперирует списком операндов. Документация и примеры использования оператора должны сделать его арность ясной.</p>

<p>Например, арифметические операторы &mdash; бинарные, и обычно левоассоциативные. <code>2 + 3 - 4</code> сначала вычисляет <code>2 + 3</code>; сложение и вычитание имеют одинаковый приоритет, но они левоассоциативные и бинарные, поэтому правильный порядок вычисления применяет самый левый оператор (<code>+</code>) к двум самым левым операндам (<code>2</code> и <code>3</code>), а затем применяет правый оператор (<code>-</code>) к результату первой операции и правому операнду (<code>4</code>).</p>

<p>Новичков в Perl часто сбивает с толку взаимодействие между операторами списочной арности &mdash; особенно вызовами функций &mdash; и вложенными выражениями. Хотя скобки обычно помогают, опасайтесь запутанности парсинга выражения:</p>

<pre><code>    # &#x432;&#x435;&#x440;&#x43E;&#x44F;&#x442;&#x43D;&#x43E; &#x43E;&#x448;&#x438;&#x431;&#x43E;&#x447;&#x43D;&#x44B;&#x439; &#x43A;&#x43E;&#x434;
    say ( 1 + 2 + 3 ) * 4;</code></pre>

<p>&hellip;которое выводит значение <code>6</code> и (вероятно) в целом возвращает <code>4</code> (возвращаемое значение <code>say</code>, умноженное на <code>4</code>). Парсер Perl успешно интерпретирует скобки как постциркумфиксные (<a href="chapter_04.html#fixity">Фиксность</a>) операторы, обозначающие аргументы <code>say</code>, а не циркумфиксные скобки, группирующие выражение для изменения приоритета.</p>

<h3>Фиксность</h3>

<p><a name="fixity">            </p>

<p><em>Фиксность</em> оператора &mdash; это его расположение по отношению к своим операндам:</p>

<p>           </p>

<ul>

<li><em>Инфиксные</em> операторы располагаются между своими операндами. Большинство математических операторов &mdash; инфиксные операторы, такие как оператор умножения в <code>$length * $width</code>.</li>

<p>       </p>

<li><em>Префиксные</em> операторы предшествуют своим операндам. <em>Постфиксные</em> операторы следуют за операндами. Эти операторы склонны быть унарными, как математическое отрицание (<code>-$x</code>), булево отрицание (<code>!$y</code>) и постфиксный инкремент (<code>$z++</code>).</li>

<p>      </p>

<li><em>Циркумфиксные</em> операторы окружают свои операнды, как конструктор анонимного хеша (<code>{ ... }</code>) и операторы заключения в кавычки (<code>qq[ ... ]</code>).</li>

<p>  </p>

<li><em>Постциркумфиксные</em> операторы следуют за одними операндами и окружают другие, как в доступе к элементам хеша или массива (<code>$hash{$x}</code> и <code>$array[$y]</code>).</li>

</ul>

<h2>Типы операторов</h2>

<p><a name="operator_types"></p>

<p>Оперторы Perl предоставляют контекст значения (<a href="chapter_01.html#value_contexts">Числовой, строковый и булев контекст</a>) своим операндам. Чтобы выбрать подходящий оператор, нужно понимание значения предоставляемых вами операндов, а так же значения, которое вы ожидаете получить.</p>

<h3>Числовые операторы</h3>

<p><a name="numeric_operators"></p>

<p>                           </p>

<p>Числовые операторы налагают числовой контекст на свои операнды. Эти операторы &mdash; стандартные арифметические операторы, такие как сложение (<code>+</code>), вычитание (<code>-</code>), умножение (<code>*</code>), деление (<code>/</code>), возведение в степень (<code>**</code>), остаток от деления (<code>%</code>), их вариации (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>**=</code> и <code>%=</code>), а также постфиксный и префиксный автодекремент (<code>--</code>).</p>

<p>Оператор автоинкремента имеет специальное строковое поведение (<a href="chapter_04.html#auto_increment_operator">Специальные операторы</a>).</p>

<p>      </p>

<p>      </p>

<p>Некоторые операторы сравнения налагают числовой контекст на свои операнды. Это числовое равенство (<code>==</code>), числовое неравенство (<code>!=</code>), больше чем (<code>&gt;</code>), меньше чем (<code>&lt;</code>), больше или равно (<code>&gt;=</code>), меньше или равно (<code>&lt;=</code>) и оператор сравнения (<code>&lt;=&gt;</code>).</p>

<h3>Строковые операторы</h3>

<p>       </p>

<p>Строковые операторы налагают строковый контекст на свои операнды. Это положительная и отрицательная привязка регулярных выражений (<code>=~</code> and <code>!~</code> соответственно) и конкатенация (<code>.</code>).</p>

<p>             </p>

<p>Некоторые операторы сравнения налагают строковый контекст на свои операнды. Это строковое равенство (<code>eq</code>), строковое неравенство (<code>ne</code>), больше чем (<code>gt</code>), меньше чем (<code>lt</code>), больше или равно (<code>ge</code>), меньше или равно (<code>le</code>) и оператор строкового сравнения (<code>cmp</code>).</p>

<h3>Логические операторы</h3>

<p>                     </p>

<p>Логические операторы налагают булев контекст на свои операнды. Это операторы <code>&&</code>, <code>and</code>, <code>||</code> и <code>or</code>. Все они инфиксные и проявляют поведение <em>короткого замыкания</em> (<a href="chapter_03.html#short_circuiting">Короткое замыкание</a>). Словесные варианты имеют более низкий приоритет, чем их пунктуационные формы.</p>

<p>Оператор определено-или, <code>//</code>, проверяет <em>определённость</em> своего операнда. В отличие от <code>||</code>, который проверяет <em>истинность</em> своего операнда, <code>//</code> возвращает истинное значение даже если его операнд вычисляется в числовой ноль или пустую строку. Это особенно полезно для установки параметров по умолчанию:</p>

<pre><code>    sub name_pet
    {
        my $name = shift // &#39;Fluffy&#39;;
        ...
    }</code></pre>

<p></p>

<p>Тернарный условный оператор (<code>?:</code>) принимает три операнда. Он вычисляет первый операнд в булевом контексте и возвращает второй операнд, если первый &mdash; истина, или третий &mdash; в противном случае:</p>

<pre><code>    my $truthiness = $value ? &#39;true&#39; : &#39;false&#39;;</code></pre>

<p>Префиксные операторы <code>!</code> и <code>not</code> возвращают логическую противоположность булева значения своих операндов. <code>not</code> &mdash; низкоприоритетная версия <code>!</code>.</p>

<p>Оператор <code>xor</code> &mdash; инфиксный оператор, вычисляющий исключающее или своих операндов.</p>

<h3>Побитовые операторы</h3>

<p>          </p>

<p> </p>

<p>       </p>

<p>Побитовые операторы обрабатывают свои операнды численно на битовом уровне. Эти операторы не очень распространены. Они включают левый сдвиг (<code><<</code>), правый сдвиг (<code>>></code>), побитовое и (<code>&</code>), побитовое или (<code>|</code>) и побитовое исключающее или (<code>^</code>), а также их варианты (<code><<=</code>, <code>>>=</code>, <code>&=</code>, <code>|=</code> и <code>^=</code>).</p>

<h3>Специальные операторы</h3>

<p><a name="auto_increment_operator"></p>

<p>   </p>

<p>Оператор автоинкремента имеет специальное поведение. При использовании на значении с числовым компонентом (<a href="chapter_03.html#cached_coercions">Кешированное преобразование типов</a>), оператор инкрементирует этот числовой компонент. Если значение очевидно строка (и не имеет числового компонента), оператор инкрементирует это строковое значение так, что <code>a</code> становится <code>b</code>, <code>zz</code> становится <code>aaa</code> и <code>a9</code> становится <code>b0</code>.</p>

<pre><code>    my $num = 1;
    my $str = &#39;a&#39;;

    $num++;
    $str++;
    is( $num,   2, &#39;numeric autoincrement&#39; );
    is( $str, &#39;b&#39;, &#39;string autoincrement&#39;  );

    no warnings &#39;numeric&#39;;
    $num += $str;
    $str++;

    is( $num, 2, &#39;numeric addition with $str&#39;    );
    is( $str, 1, &#39;... gives $str a numeric part&#39; );</code></pre>

<p>  </p>

<p>Оператор повторения (<code>x</code>) &mdash; инфиксный оператор со сложным поведением. В списочном контексте, когда передан список, он возвращает этот список, повторённый количество раз, определяемое вторым операндом. В списочном контексте если передан скаляр, он выдаёт строку, состояющую из строкового значения его первого операнда, конкатенированного с собой количество раз, определяемое вторым операндом.</p>

<p>В скалярном контексте оператор всегда выдаёт конкатенированную строку, соответствующим образом повторённую. Например:</p>

<pre><code>    my @scheherazade = (&#39;nights&#39;) x 1001;
    my $calendar     =  &#39;nights&#39;  x 1001;
    my $cal_length   =  length $calendar;

    is( @scheherazade, 1001, &#39;list repeated&#39; );
    is( $cal_length,   1001 * length &#39;nights&#39;,
                       &#39;word repeated&#39; );

    my @schenolist   =  &#39;nights&#39;  x 1001;
    my $calscalar    = (&#39;nights&#39;) x 1001;

    is( @schenolist, 1, &#39;no lvalue list&#39; );
    is( length $calscalar,
        1001 * length &#39;nights&#39;, &#39;word still repeated&#39; );</code></pre>

<p>   </p>

<p>Инфиксный оператор <em>диапазона</em> (<code>..</code>) генерирует список элементов в списочном контексте:</p>

<pre><code>    my @cards = ( 2 .. 10, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39;, &#39;A&#39; );</code></pre>

<p>Он может генерировать простые инкрементирующиеся диапазоны (как целочисленные, так и строковые), но не может угадать шаблоны более сложных диапазонов.</p>

<p>  </p>

<p>В булевом контексте оператор диапазона становится оператором <em>триггера</em>. Этот оператор выдаёт ложное значение до тех пор, пока его левый операнд &mdash; истина. Это значение остаётся истинным, пока правый оператор &mdash; истина, после чего вновь становится ложным, пока левый операнд снова не станет истинным. Представьте разбор текста формального письма следующим образом:</p>

<pre><code>    while (/Hello, $user/ .. /Sincerely,/)
    {
        say &quot;&gt; $_&quot;;
    }</code></pre>

<p>    </p>

<p>Оператор <em>запятая</em> (<code>,</code>) &mdash; инфиксный оператор. В скалярном контексте он вычисляет свой левый операнд, а затем возвращает значение, полученное при вычислении правого операнда. В списочном контексте он вычисляет оба операнда в порядке слева направо.</p>

<p>Оператор толстой запятой (<code>=></code>) кроме того автоматически заключает в кавычки любое голое слово, использованное как его левый операнд (<a href="chapter_03.html#hashes">Хеши</a>).</p>

</body></html>