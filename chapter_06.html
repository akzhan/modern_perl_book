<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="style.css" type="text/css"></head><body><h1>Регулярные выражения и сопоставление</h1>

<p><a name="regex"></p>

<p>  </p>

<p>Мощь Perl в обработке текста проистекает из использования им <em>регулярных выражений</em>. Регулярное выражение (<em>regular expression</em>, <em>regex</em> или <em>regexp</em>) &mdash; это <em>шаблон</em>, описывающий свойства куска текста. <em>Механизм регулярных выражений</em> интерпретирует шаблоны и применяет их для сопоставления или изменения кусков текста.</p>

<p>Базовая документация Perl 5 по регулярным выражениям включает туториал (<code>perldoc perlretut</code>), справочное руководство (<code>perldoc perlreref</code>) и полную документацию (<code>perldoc perlre</code>). Книга Джефри Фридла (Jeffrey Friedl) <em>Освоение регулярных выражений</em> (<em>Mastering Regular Expressions</em>) объясняет теорию и механику того, как работают регулярные выражения. Хотя овладение регулярными выражениями &mdash; непростой процесс, даже небольшое знание даст вам большие возможности.</p>

<p><a name="regular_expressions"></p>

<h2>Литералы</h2>

<p></p>

<p>Регулярные выражения могут быть простыми шаблонами подстрок:</p>

<pre><code>    my $name = &#39;Chatfield&#39;;
    say &#39;Found a hat!&#39; if $name =~ <strong>/hat/</strong>;</code></pre>

<p>    </p>

<p>Оператор сопоставления (<em>match</em>, <code>m//</code>, сокращёно <code>//</code>) распознаёт регулярное выражение, в этом примере &mdash; <code>hat</code>. Этот шаблон &mdash; <em>не</em> слово. Он означает &laquo;символ <code>h</code>, за которым следует символ <code>a</code>, за которым следует символ <code>t</code>&raquo;. Каждый символ в шаблоне &mdash; неделимый элемент, или <em>атом</em>. Он либо совпадает, либо нет.</p>

<p>   </p>

<p>Оператор связывания с регулярным выражением (<code>=~</code>) &mdash; инфиксный оператор (<a href="chapter_04.html#fixity">Фиксность</a>), который применяет регулярное выражение, являющееся его вторым операндом к строке, указанной в качестве первого операнда. При использовании в скалярном контексте, сопоставление возвращает истинное значение в случае успеха. Отрицательная форма оператора связывания (<code>!~</code>) возвращает истинное значение в случае неудачного сопоставления.</p>

<p></p>

<p>Встроенная функция <code>index</code> тоже может осуществлять поиск литеральной подстроки в строке. Использование для этого механизма регулярных выражений &mdash; это как полёт на автономном боевом вертолёте в магазин на углу за сыром, но Perl позволяет вам решать, что вы находите более поддерживаемым.</p>

<p> </p>

<p>Оператор замены, <code>s///</code>, это, в некотором смысле, циркумфиксный оператор (<a href="chapter_04.html#fixity">Фиксность</a>) с двумя операндами. Его первый операнд &mdash; регулярное выражение для поиска соответствия при использовании с оператором связывания с регулярным выражением. Второй операнд &mdash; подстрока, используемая для замены сопоставленной части первого операнда. Например, вылечить надоедливые летние аллергии можно так:</p>

<pre><code>    my $status = &#39;I feel ill.&#39;;
    $status    =~ s/ill/well/;
    say $status;</code></pre>

<h2>Оператор qr// и объединения регулярных выражений</h2>

<p>   </p>

<p>Оператор <code>qr//</code> создаёт регулярные выражения первого класса. Для использования интерполируйте их в оператор сопоставления:</p>

<pre><code>    my $hat = <strong>qr/hat/</strong>;
    say &#39;Found a hat!&#39; if $name =~ /$hat/;</code></pre>

<p>&hellip;или объедините несколько регулярных выражений в составные шаблоны:</p>

<pre><code>    my $hat   = qr/hat/;
    my $field = qr/field/;

    say &#39;Found a hat in a field!&#39;
        if $name =~ /<strong>$hat$field</strong>/;

    like( $name, qr/<strong>$hat$field</strong>/,
                   &#39;Found a hat in a field!&#39; );</code></pre>

<p> </p>

<p>Функция <code>like</code> модуля <code>Test::More</code> проверяет, что первый аргумент соответствует регулярному выражению, указанному как второй аргумент.</p>

<h2>Квантификаторы</h2>

<p>  </p>

<p>Регулярные выражения становятся более мощными благодаря использованию <em>квантификаторов регулярных выражений</em>, который позволяют вам указать, сколько раз компонент регулярного выражения может появляться в строке. Самый простой квантификатор &mdash; <em>квантификатор &laquo;ноль или один&raquo;</em>, или <code>?</code>:</p>

<pre><code>    my $cat_or_ct = qr/ca<strong>?</strong>t/;

    like( &#39;cat&#39;, $cat_or_ct, &quot;&#39;cat&#39; matches /ca?t/&quot; );
    like( &#39;ct&#39;,  $cat_or_ct, &quot;&#39;ct&#39; matches /ca?t/&quot;  );</code></pre>

<p>Любой атом в регулярном выражении, за которым следует символ <code>?</code>, означает &laquo;найти ноль или одни таких атомов&raquo;. Это регулярное выражение проходит сопоставление, если один или более символов <code>a</code> следуют сразу за символом <code>c</code> и непосредственно предшествуют символу <code>t</code>, будь это литеральная подстрока <code>cat</code> или <code>ct</code>.</p>

<p> </p>

<p><em>Квантификатор &laquo;один или более&raquo;</em>, или <code>+</code>, проходит сопоставление только если есть как минимум одно вхождение квантифицируемого атома:</p>

<pre><code>    my $some_a = qr/ca<strong>+</strong>t/;

    like( &#39;cat&#39;,    $some_a, &quot;&#39;cat&#39; matches /ca+t/&quot; );
    like( &#39;caat&#39;,   $some_a, &quot;&#39;caat&#39; matches/&quot;      );
    like( &#39;caaat&#39;,  $some_a, &quot;&#39;caaat&#39; matches&quot;      );
    like( &#39;caaaat&#39;, $some_a, &quot;&#39;caaaat&#39; matches&quot;     );

    unlike( &#39;ct&#39;,   $some_a, &quot;&#39;ct&#39; does not match&quot;  );</code></pre>

<p>Нет теоретического ограничения максимального количества квантифицированных атомов, которые могут пройти сопоставление.</p>

<p> </p>

<p><em>Квантификатор &laquo;ноль или более&raquo;</em>, <code>*</code>, находит соответствие ноля или более экземпляров квантифицируемого атома:</p>

<pre><code>    my $any_a = qr/ca<strong>*</strong>t/;

    like( &#39;cat&#39;,    $any_a, &quot;&#39;cat&#39; matches /ca*t/&quot; );
    like( &#39;caat&#39;,   $any_a, &quot;&#39;caat&#39; matches&quot;       );
    like( &#39;caaat&#39;,  $any_a, &quot;&#39;caaat&#39; matches&quot;      );
    like( &#39;caaaat&#39;, $any_a, &quot;&#39;caaaat&#39; matches&quot;     );
    like( &#39;ct&#39;,     $any_a, &quot;&#39;ct&#39; matches&quot;         );</code></pre>

<p>Как бы глупо это ни выглядело, это позволяет вам указать необязательные компоненты регулярного выражения. Всё же, используйте это экономно: это грубый и дорогой инструмент. <em>Большинство</em> регулярных выражений получают гораздо больше выгоды от использования <code>?</code> и <code>+</code>, чем от <code>*</code>. Точность намерений зачастую увеличивает ясность.</p>

<p> </p>

<p><em>Количественные квантификаторы</em> выражают конкретное количество возможных повторений атома. <code>{n}</code> означает, что совпадение должно быть найдено ровно <em>n</em> раз.</p>

<pre><code>    # &#x44D;&#x43A;&#x432;&#x438;&#x432;&#x430;&#x43B;&#x435;&#x43D;&#x442;&#x43D;&#x43E; qr/cat/;
    my $only_one_a = qr/ca<strong>{1}</strong>t/;

    like( &#39;cat&#39;, $only_one_a, &quot;&#39;cat&#39; matches /ca{1}t/&quot; );</code></pre>

<p><code>{n,}</code> требует <em>как минимум</em> <em>n</em> повторений:</p>

<pre><code>    # &#x44D;&#x43A;&#x432;&#x438;&#x432;&#x430;&#x43B;&#x435;&#x43D;&#x442;&#x43D;&#x43E; qr/ca+t/;
    my $some_a = qr/ca<strong>{1,}</strong>t/;

    like( &#39;cat&#39;,    $some_a, &quot;&#39;cat&#39; matches /ca{1,}t/&quot; );
    like( &#39;caat&#39;,   $some_a, &quot;&#39;caat&#39; matches&quot;          );
    like( &#39;caaat&#39;,  $some_a, &quot;&#39;caaat&#39; matches&quot;         );
    like( &#39;caaaat&#39;, $some_a, &quot;&#39;caaaat&#39; matches&quot;        );</code></pre>

<p><code>{n,m}</code> означает, что должно быть как минимум <em>n</em>, но не более <em>m</em> совпадений:</p>

<pre><code>    my $few_a = qr/ca<strong>{1,3}</strong>t/;

    like( &#39;cat&#39;,    $few_a, &quot;&#39;cat&#39; matches /ca{1,3}t/&quot; );
    like( &#39;caat&#39;,   $few_a, &quot;&#39;caat&#39; matches&quot;           );
    like( &#39;caaat&#39;,  $few_a, &quot;&#39;caaat&#39; matches&quot;          );

    unlike( &#39;caaaat&#39;, $few_a, &quot;&#39;caaaat&#39; doesn&#39;t match&quot; );</code></pre>

<p>Вы можете выразить символьные квантификаторы в терминах количественных квантификаторов, но большинство программ, как правило, используют первые.</p>

<h2>Жадность</h2>

<p> </p>

<p>Квантификаторы <code>+</code> и <code>*</code> &mdash; <em>жадные</em>, они пытаются сопоставить настолько большую часть входной строки, насколько можно. Это особенно пагубное поведение. Рассмотрите наивное использование шаблона &laquo;ноль или более символов, не являющихся символами перевода строки&raquo; <code>.*</code>:</p>

<pre><code>    # &#x43F;&#x43B;&#x43E;&#x445;&#x43E;&#x435; &#x440;&#x435;&#x433;&#x443;&#x43B;&#x44F;&#x440;&#x43D;&#x43E;&#x435; &#x432;&#x44B;&#x440;&#x430;&#x436;&#x435;&#x43D;&#x438;&#x435;
    my $hot_meal = qr/hot.*meal/;

    say &#39;Found a hot meal!&#39;
        if &#39;I have a hot meal&#39; =~ $hot_meal;

    say &#39;Found a hot meal!&#39;
         if &#39;one-shot, piecemeal work!&#39; =~ $hot_meal;</code></pre>

<p>Жадные квантификаторы начинают с того, что сопоставляют <em>всё</em>, а затем возвращаются на один символ за раз только если очевидно, что сопоставление не успешно.</p>

<p> </p>

<p>Модификатор <code>?</code>, добавленный к квантификатору, делает жадный квантификатор бережливым:</p>

<pre><code>    my $minimal_greedy = qr/hot.*?meal/;</code></pre>

<p>При использовании нежадного квантификатора, механизм регулярных выражений предпочтёт по возможности <em>наикратчайшее</em> потенциальное совпадение и будет увеличивать количество символов, идентифицируемых токеном <code>.*?</code>, только если текущее количество не проходит сопоставление. Поскольку <code>*</code> требует нуля или более повторений, минимальное потенциальное совпадение для этого токена &mdash; ноль символов:</p>

<pre><code>    say &#39;Found a hot meal&#39;
    if &#39;ilikeahotmeal&#39; =~ /$minimal_greedy/;</code></pre>

<p></p>

<p>Для нежадной проверки одного или более элементов используйте <code>+?</code>:</p>

<pre><code>    my $minimal_greedy_plus = qr/hot.+?meal/;

    unlike( &#39;ilikeahotmeal&#39;, $minimal_greedy_plus );

    like( &#39;i like a hot meal&#39;, $minimal_greedy_plus );</code></pre>

<p></p>

<p>Модификатор <code>?</code> применим также и к квантификатору <code>?</code> (ноль или более совпадений), как и к квантификаторам диапазона. В каждом случае он заставляет регулярное выражение захватывать настолько мало входных данных, насколько возможно.</p>

<p>Жадные шаблоны <code>.+</code> и <code>.*</code> соблазнительны, но опасны. Кроссвордист (footnote: Любитель разгадывания кроссвордов.), которому нужно заполнить 7 по вертикали (&laquo;Богатая почва&raquo;) найдёт слишком много неверных кандидатов со следующим шаблоном:</p>

<pre><code>    my $seven_down   = qr/l$letters_only*m/;</code></pre>

<p>Придётся отбросить <code>Alabama</code>, <code>Belgium</code> и <code>Bethlehem</code> задолго до того, как программа предложит <code>loam</code>. Эти слова не только слишком длинные, но и соответствие начинается с середины слов. Рабочее понимание жадности поможет, но ничто не заменит обширное тестирование на реальных рабочих данных.</p>

<h2>Якоря регулярных выражений</h2>

<p>  </p>

<p><em>Якоря регулярных выражений</em> заставляют механизм регулярных выражений начинать или заканчивать сопоставление на абсолютной позиции. <em>Якорь начала строки</em> (<code>\A</code>) требует, чтобы любое соответствие начиналось с начала строки:</p>

<pre><code>    # &#x442;&#x430;&#x43A;&#x436;&#x435; &#x441;&#x43E;&#x43E;&#x442;&#x432;&#x435;&#x442;&#x441;&#x442;&#x432;&#x443;&#x435;&#x442; &quot;lammed&quot;, &quot;lawmaker&quot; &#x438; &quot;layman&quot;
    my $seven_down = qr/\Al${letters_only}{2}m/;</code></pre>

<p> </p>

<p><em>Якорь конца строки</em> (<code>\Z</code>) требует, чтобы соответствие заканчивалось в конце строки.</p>

<pre><code>    # &#x442;&#x430;&#x43A;&#x436;&#x435; &#x441;&#x43E;&#x43E;&#x442;&#x432;&#x435;&#x442;&#x441;&#x442;&#x432;&#x443;&#x435;&#x442; &quot;loom&quot;, &#x43D;&#x43E; &#x443;&#x436;&#x435; &#x43E;&#x447;&#x435;&#x432;&#x438;&#x434;&#x43D;&#x43E;&#x435; &#x443;&#x43B;&#x443;&#x448;&#x435;&#x43D;&#x438;&#x435;
    my $seven_down = qr/\Al${letters_only}{2}m\Z/;</code></pre>

<p> </p>

<p><em>Якорь границы слова</em> (<code>\b</code>) находит соответствие только на границе между символом слова (<code>\w</code>) и несловарным символом (<code>\W</code>). Используйте регулярное выражение с якорями, чтобы найти <code>loam</code>, отбросив <code>Belgium</code>:</p>

<pre><code>    my $seven_down = qr/\bl${letters_only}{2}m\b/;</code></pre>

<h2>Метасимволы</h2>

<p>  </p>

<p>Perl интерпретирует некоторые символы в регулярных выражениях как <em>метасимволы</em>, символы, представляющие нечто отличное от их буквальной интерпретации. Метасимволы пользователям регулярных выражений силу, далеко выходящую за рамки всего лишь поиска подстрок. Механизм регулярных выражений обрабатывает все метасимволы как атомы.</p>

<p> </p>

<p>Метасимвол <code>.</code> означает &laquo;соответствие любому символу, исключая перевод строки&raquo;. Запомните это пояснение; многие новички его забывают. Простой поиск по регулярному выражению &mdash; не принимая в счёт явное улучшение с использованием якорей &mdash; для 7 по вертикали может быть <code>/l..m/</code>. Конечно, всегда есть более чем один способ получить правильный ответ:</p>

<pre><code>    for my $word (@words)
    {
        next unless length( $word ) == 4;
        next unless $word =~ /l<strong>..</strong>m/;
        say &quot;Possibility: $word&quot;;
    }</code></pre>

<p> </p>

<p>Если потенциальные совпадения в <code>@words</code> &mdash; более, чем простые английские слова, вы получите ложноположительные результаты. <code>.</code> также соответствует знакам пунктуации, пробельным символам и числам. Будьте точны! Метасимвол <code>\w</code> представляет все буквенно-числовые символы (<a href="chapter_03.html#unicode">Юникод и строки</a>) и символ подчёркивания:</p>

<pre><code>        next unless $word =~ /l<strong>\w\w</strong>m/;</code></pre>

<p> </p>

<p>Метасимвол <code>\d</code> соответствует цифрам (тоже в смысле Юникод):</p>

<pre><code>    # &#x43D;&#x435;&#x43D;&#x430;&#x434;&#x451;&#x436;&#x43D;&#x430;&#x44F; &#x43F;&#x440;&#x43E;&#x432;&#x435;&#x440;&#x43A;&#x430; &#x442;&#x435;&#x43B;&#x435;&#x444;&#x43E;&#x43D;&#x43D;&#x44B;&#x445; &#x43D;&#x43E;&#x43C;&#x435;&#x440;&#x43E;&#x432;
    next unless $number =~ /<strong>\d</strong>{3}-<strong>\d</strong>{3}-<strong>\d</strong>{4}/;
    say &quot;I have your number: $number&quot;;</code></pre>

<p> </p>

<p>Используйте метасимвол <code>\s</code> для сопоставления пробельным символам, будь это литеральный пробел, символ табуляции, возврат каретки, подача страницы или перевод строки:</p>

<pre><code>    my $two_three_letter_words = qr/\w{3}<strong>\s</strong>\w{3}/;</code></pre>

<p>       </p>

<p>Эти метасимволы имеют отрицательные формы. Используйте <code>\W</code> для поиска любого символа, <em>исключая</em> словарные символы. Используйте <code>\D</code> для поиска нецифровых символов. Используйте <code>\S</code> для поиска чего угодно, кроме пробельных символов. Используйте <code>\B</code> для сопоставления где угодно, кроме границы слова.</p>

<h2>Классы символов</h2>

<p><a name="character_classes">  </p>

<p>Если все эти метасимволы недостаточно точны, определите свой собственный <em>класс символов</em>, заключив их в квадратные скобки:</p>

<pre><code>    my $ascii_vowels = qr/<strong>[</strong>aeiou<strong>]</strong>/;
    my $maybe_cat    = qr/c${ascii_vowels}t/;</code></pre>

<p>Без фигурных скобок парсер Perl интерпретирует имя переменной как <code>$ascii_vowelst</code>, что либо вызовет ошибку времени компиляции о неизвестной переменной, или интерполирует в регулярное выражение содержимое существующей переменной <code>$ascii_vowelst</code>.</p>

<p></p>

<p>Символ дефиса (<code>-</code>) позволяет указывать в классе непрерывный диапазон символов, как в регулярном выражении <code>$ascii_letters_only</code>:</p>

<pre><code>    my $ascii_letters_only = qr/[a-zA-Z]/;</code></pre>

<p>Чтобы использовать дефис как член класса, переместите его в начало или в конец:</p>

<pre><code>    my $interesting_punctuation = qr/[-!?]/;</code></pre>

<p>&hellip;или экранируйте его:</p>

<pre><code>    my $line_characters = qr/[|=\-_]/;</code></pre>

<p></p>

<p>Используйте символ каре (<code>^</code>) как первый элемент класса символов, чтобы сказать &laquo;любые символы <em>кроме</em> этих&raquo;:</p>

<pre><code>    my $not_an_ascii_vowel = qr/[^aeiou]/;</code></pre>

<p>Используйте символ каре в любом месте, кроме первой позиции, чтобы сделать его членом класса символов. Чтобы включить в класс символов дефис, поместите его после знака вставки, или в конце класса, или экранируйте его.</p>

<h2>Захват</h2>

<p><a name="regex_captures"></p>

<p>Регулярные выражения позволяют вам группировать и захватывать части совпадения для дальнейшего использования. Извлечь из строки американский телефонный номер вида <code>(202) 456-1111</code> можно следующим образом:</p>

<pre><code>    my $area_code    = qr/\(\d{3}\)/;
    my $local_number = qr/\d{3}-?\d{4}/;
    my $phone_number = qr/$area_code\s?$local_number/;</code></pre>

<p>Обратите особое внимание на экранирование круглых скобок в <code>$area_code</code>. Скобки имеют особое значение для регулярных выражений Perl 5. Они группируют атомы в единицы большего размера, а также захватывают части сопоставленных строк. Для поиска литеральных скобок, экранируйте их с помощью обратных слешей, как сделано в <code>$area_code</code>.</p>

<h3>Именованные захваты</h3>

<p><a name="named_captures">   </p>

<p>В Perl 5.10 были добавлены <em>именованные захваты</em>, которые позволяют вам захватывать части совпадения при применении регулярного выражения и получать к ним доступ позже, как например при нахождении телефонного номера в строке, содержащей контактную информацию:</p>

<pre><code>    if ($contact_info =~ /(?&lt;phone&gt;$phone_number)/)
    {
        say &quot;Found a number $+{phone}&quot;;
    }</code></pre>

<p>Регулярные выражения имеют тенденцию выглядеть как пунктуационный суп, пока вы не соберёте разные части вместе, как кусочки. Синтаксис именованного захвата имеет следующий вид:</p>

<pre><code>    (?&lt;capture name&gt; ... )</code></pre>

<p> </p>

<p>Скобки окружают захват. Конструкция <code>?< name ></code> именует этот конкретный захват, и должна следовать сразу же за левой скобкой. Оставшаяся часть захвата &mdash; регулярное выражение.</p>

<p>Когда будет найдено соответствие заключённому в конструкцию шаблону, Perl сохранит совпадающую с шаблоном часть строки в магическую переменную <code>%+</code>. В этом хеше ключ &mdash; это имя захвата, а значение &mdash; соответствующая часть найденной строки.</p>

<h3>Нумерованные захваты</h3>

<p> </p>

<p>С давних пор Perl поддерживает <em>нумерованные захваты</em>:</p>

<pre><code>    if ($contact_info =~ /($phone_number)/)
    {
        say &quot;Found a number $1&quot;;
    }</code></pre>

<p>   </p>

<p>Эта форма захвата не предоставляет идентифицирующего имени и не сохраняет в <code>%+</code>. Вместо этого, Perl сохраняет захваченную подстроку в последовательности магических переменных. <em>Первый</em> найденный захват попадает в <code>$1</code>, второй &mdash; в <code>$2</code> и так далее. Подсчёт захватов начинается с <em>открывающей</em> скобки захвата; так что первая левая скобка начинает захват в <code>$1</code>, вторая &mdash; в <code>$2</code> и т. д.</p>

<p>Хотя синтаксис именованных захватов длиннее, чем нумерованных, он предоставляет дополнительную ясность. Подсчёт левых скобок &mdash; утомительный труд, и объединение регулярных выражений, содержащих нумерованные захваты, слишком сложно. Именованные захваты улучшают поддерживаемость регулярных выражений &mdash; хотя коллизии имён возможны, они относительно редки. Минимизируйте риск путём использования нумерованных захватов только в регулярных выражениях верхнего уровня.</p>

<p>В списочном контексте сопоставление регулярному выражению возвращает список захваченных подстрок:</p>

<pre><code>    if (my ($number) = $contact_info =~ /($phone_number)/)
    {
        say &quot;Found a number $number&quot;;
    }</code></pre>

<p>Нумерованные захваты также полезны в простых заменах, где именованные захваты могут быть слишком громоздкими:</p>

<pre><code>    my $order = &#39;Vegan brownies!&#39;;

    $order =~ s/Vegan (\w+)/Vegetarian $1/;
    # &#x438;&#x43B;&#x438;
    $order =~ s/Vegan (?&lt;food&gt;\w+)/Vegetarian $+{food}/;</code></pre>

<h2>Группировка и выбор</h2>

<p>Все предыдущие примеры применяли квантификаторы к простым атомам. Вы можете применять их к любому элементу регулярного выражения:</p>

<pre><code>    my $pork  = qr/pork/;
    my $beans = qr/beans/;

    like( &#39;pork and beans&#39;, qr/\A$pork?.*?$beans/,
         &#39;maybe pork, definitely beans&#39; );</code></pre>

<p>Если вы расширите регулярное выражение вручную, результат может вас удивить:</p>

<pre><code>    my $pork_and_beans = qr/\Apork?.*beans/;

    like( &#39;pork and beans&#39;, qr/$pork_and_beans/,
        &#39;maybe pork, definitely beans&#39; );
    like( &#39;por and beans&#39;, qr/$pork_and_beans/,
         &#39;wait... no phylloquinone here!&#39; );</code></pre>

<p>Иногда определённость помогает аккуратности шаблона:</p>

<pre><code>    my $pork  = qr/pork/;
    my $and   = qr/and/;
    my $beans = qr/beans/;

    like( &#39;pork and beans&#39;, qr/\A$pork? $and? $beans/,
        &#39;maybe pork, maybe and, definitely beans&#39; );</code></pre>

<p> </p>

<p>Некоторым регулярным выражениям нужно сопоставить одному варианту или другому. Метасимвол <em>выбора</em> (<code>|</code>) выражает это намерение:</p>

<pre><code>    my $rice  = qr/rice/;
    my $beans = qr/beans/;

    like( &#39;rice&#39;,  qr/$rice|$beans/, &#39;Found rice&#39;  );
    like( &#39;beans&#39;, qr/$rice|$beans/, &#39;Found beans&#39; );</code></pre>

<p>Метасимвол выбора указывает, что любой из предшествующих фрагментов может быть сопоставлен. Имейте ввиду, что выбор имеет приоритет (<a href="chapter_04.html#precedence">Приоритет</a>) даже ниже, чем атомы:</p>

<pre><code>    like(   &#39;rice&#39;,  qr/rice|beans/, &#39;Found rice&#39;   );
    like(   &#39;beans&#39;, qr/rice|beans/, &#39;Found beans&#39;  );
    unlike( &#39;ricb&#39;,  qr/rice|beans/, &#39;Found hybrid&#39; );</code></pre>

<p>Хотя легко воспринять <code>rice|beans</code> как <code>ric</code>, за которым следует либо <code>e</code>, либо <code>b</code>, и далее <code>eans</code>, выбор всегда включает <em>весь</em> фрагмент до ближайшего ограничителя регулярного выражения, будь это начало или конце шаблона, круглые скобки, другой символ выбора или квадратная скобка.</p>

<p> </p>

<p>Чтобы уменьшить путаницу, используйте именованные фрагменты в переменных (<code>$rice|$beans</code>) или группируйте альтернативные варианты в <em>незахватывающие группы</em>:</p>

<pre><code>    my $starches = qr/(?:pasta|potatoes|rice)/;</code></pre>

<p></p>

<p>Последовательность <code>(?:)</code> группирует серию атомов, не осуществляя захват.</p>

<p>Преобразованное в строку регулярное выражение включает окружающую его незахватывающую группировку; <code>qr/rice|beans/</code> преобразуется в <code>(?^u:rice|beans)</code>.</p>

<h2>Другие экранированные последовательности</h2>

<p>  </p>

<p>Для поиска <em>литерального</em> экземпляра метасимвола, <em>экранируйте</em> его с помощью обратного слеша (<code>\</code>). Вы встречали это раньше, где <code>\(</code> обозначало одну левую круглую скобку, а <code>\]</code> &mdash; одну правую квадратную скобку. <code>\.</code> обозначает литеральный символ точки вместо атома, захватывающего что угодно, кроме символа перевода строки.</p>

<p>Вам, вероятно, понадобится экранировать метасимвол выбора (<code>|</code>), так же как метасимвол конца строки (<code>$</code>) и квантификаторы (<code>+</code>, <code>?</code>, <code>*</code>).</p>

<p>  </p>

<p><em>Символы отключения метасимволов</em> (<code>\Q</code> and <code>\E</code>) отключают интерпретацию метасимволов в своих границах. Это особенно полезно при получении текста для сопоставления из источника, который вы не контролируете при написании программы:</p>

<pre><code>    my ($text, $literal_text) = @_;

    return $text =~ /\Q$literal_text\E/;</code></pre>

<p>Аргумент <code>$literal_text</code> может содержать всё что угодно &mdash; например, строку <code>** ALERT **</code>. С фрагментом, заключённым в <code>\Q</code> и <code>\E</code>, Perl воспримет регулярное выражение как <code>\*\* ALERT \*\*</code> и попытается найти соответствие литеральным символам звёздочки, а не жадным квантификаторам.</p>

<p>Будьте осторожны при обработке регулярных выражений из недоверенного пользовательского ввода. Злонамеренный мастер регулярных выражений может провести DOS-атаку (denial-of-service) на вашу программу.</p>

<h2>Проверки</h2>

<p></p>

<p>Якоря регулярных выражений, такие как <code>\A</code>, <code>\b</code>, <code>\B</code> и <code>\Z</code> &mdash; форма <em>проверок регулярных выражений</em>, которые требуют, чтобы строка удовлетворяла определённым условиям. Эти проверки не сопоставляются отдельным символам строки. Независимо от того, что содержит строка, регулярное выражение <code>qr/\A/</code> <em>всегда</em> будет совпадать.</p>

<p></p>

<p><em>Проверки нулевой ширины</em> соответствуют <em>шаблону</em>. Что ещё более важно, они при этом не потребляют часть шаблона, которой сопоставляются. Например, чтобы найти кота самого по себе, вы можете использовать проверку границы слова:</p>

<pre><code>    my $just_a_cat = qr/cat\b/;</code></pre>

<p> </p>

<p>&hellip;но если хотите найти животное, не вызывающее бедствий, вы можете использовать <em>проверку нулевой ширины отрицательного заглядывания вперёд</em>:</p>

<pre><code>    my $safe_feline = qr/cat(?!astrophe)/;</code></pre>

<p>Конструкция <code>(?!...)</code> соответствует фразе <code>cat</code>, только если сразу за ней не следует фраза <code>astrophe</code>.</p>

<p> </p>

<p><em>Проверка нулевой ширины положительного заглядывания вперёд</em>:</p>

<pre><code>    my $disastrous_feline = qr/cat(?=astrophe)/;</code></pre>

<p>&hellip;соответствует фразе <code>cat</code>, только если сразу за ней следует фраза <code>astrophe</code>. Хотя того же самого можно добиться с помощью обычного регулярного выражения, рассмотрите регулярное выражение для поиска всех некатастрофических слов в словаре, начинающихся с <code>cat</code>:</p>

<pre><code>    my $disastrous_feline = qr/cat(?!astrophe)/;

    while (&lt;$words&gt;)
    {
        chomp;
        next unless /\A(?&lt;cat&gt;$disastrous_feline.*)\Z/;
        say &quot;Found a non-catastrophe &#39;$+{cat}&#39;&quot;;
    }</code></pre>

<p>Утверждение нулевой ширины не потребляет ничего из исходной строки, оставляя для сопоставления фрагмент с якорем <code>.*\Z</code>. В противном случае захват захватил бы только часть <code>cat</code> из исходной строки.</p>

<p>   </p>

<p>Чтобы проверить, что ваше животное никогда не появляется в начале строки, вы можете использовать <em>утверждение нулевой ширины отрицательного заглядывания назад</em>. Эти проверки должны иметь фиксированный размер; вы не можете использовать квантификаторы:</p>

<pre><code>    my $middle_cat = qr/(?&lt;!\A)cat/;</code></pre>

<p>Конструкция <code>(?<!...)</code> содержит шаблон фиксированной ширины. Также вы можете выразить, что <code>cat</code> всегда появляется сразу после символа пробела, с помощью <em>утверждения нулевой ширины положительного заглядывания назад</em>:</p>

<pre><code>    my $space_cat = qr/(?&lt;=\s)cat/;</code></pre>

<p>Конструкция <code>(?<=...)</code> содержит шаблон фиксированной ширины. Этот подход может быть полезен при объединении глобального сопоставления регулярному выражению с модификатором <code>\G</code>, но это продвинутая возможность, которую вы, вероятно, не будете использовать часто.</p>

<p> </p>

<p>Новейшая возможность регулярных выражений Perl 5 &mdash; проверка <em>сохранения</em> <code>\K</code>. Это проверка нулевой ширины положительного заглядывания назад <em>может</em> иметь переменную длину:</p>

<pre><code>    my $spacey_cat = qr/\s+\Kcat/;

    like( &#39;my cat has been to space&#39;, $spacey_cat );
    like( &#39;my  cat  has  been  to  doublespace&#39;,
         $spacey_cat );</code></pre>

<p><code>\K</code> на удивление полезна для некоторых замен, которые удаляют конец шаблона:</p>

<pre><code>    my $exclamation = &#39;This is a catastrophe!&#39;;
    $exclamation    =~ s/cat\K\w+!/./;

    like( $exclamation, qr/\bcat\./,
                          &quot;That wasn&#39;t so bad!&quot; );</code></pre>

<h2>Модификаторы регулярных выражений</h2>

<p>   </p>

<p>Некоторые модификаторы изменяют поведение операторов регулярных выражений. Эти модификаторы располагаются на конце операторов сопоставления, замены или <code>qr//</code>. Например, так можно включить регистронезависимое сопоставление:</p>

<pre><code>    my $pet = &#39;CaMeLiA&#39;;

    like( $pet, qr/Camelia/,  &#39;Nice butterfly!&#39;  );
    like( $pet, qr/Camelia/i, &#39;shift key br0ken&#39; );</code></pre>

<p>Первый <code>like()</code> провалится, потому что строка содержит другие буквы. Второй <code>like()</code> будет успешен, потому что модификатор <code>/i</code> заставляет регулярное выражение игнорировать различия в регистре. <code>M</code> и <code>m</code> во втором регулярном выражении эквивалентны, благодаря модификатору.</p>

<p></p>

<p>Также вы можете включать модификаторы в шаблон:</p>

<pre><code>    my $find_a_cat = qr/(?&lt;feline&gt;(?i)cat)/;</code></pre>

<p>Синтаксис <code>(?i)</code> включает регистронезависимый поиск только внутри включающей его группы: в данном случае, в именованном захвате. Вы можете использовать несколько модификаторов в этой форме. Отключите определённые модификаторы, предварив их знаком минуса (<code>-</code>):</p>

<pre><code>    my $find_a_rational = qr/(?&lt;number&gt;(?-i)Rat)/;</code></pre>

<p>    </p>

<p>Многострочный оператор, <code>/m</code>, позволяет якорям <code>\A</code> и <code>\Z</code> соответствовать любому переводу строки, входящему в строку.</p>

<p>  </p>

<p>Модификатор <code>/s</code> воспринимает исходную строку как единую строку, так что метасимвол <code>.</code> будет соответствовать в том числе символу перевода строки. Демьен Конвей (Damian Conway) предлагает мнемонику: <code>/m</code> модифицирует поведение <em>нескольких</em> (<em>multiple</em>) метасимволов регулярного выражения, а <code>/s</code> модифицирует поведение <em>одного</em> (<em>single</em>) метасимвола.</p>

<p>  </p>

<p>Модификатор <code>/r</code> заставляет операцию замены возвращать результат замены, оставляя исходную строку как есть. Если замена успешна, результатом будет модифицированная копия оригинала. Если замена проваливается (потому что шаблон не соответствует), результатом будет немодифицированная копия оригинала:</p>

<pre><code>    my $status     = &#39;I am hungry for pie.&#39;;
    my $newstatus  = $status =~ s/pie/cake/r;
    my $statuscopy = $status
                   =~ s/liver and onions/bratwurst/r;

    is( $status, &#39;I am hungry for pie.&#39;,
        &#39;original string should be unmodified&#39; );

    like( $newstatus,    qr/cake/,      &#39;cake wanted&#39; );
    unlike( $statuscopy, qr/bratwurst/, &#39;wurst not&#39;   );</code></pre>

<p>  </p>

<p>Модификатор <code>/x</code> позволяет вам включать в шаблон дополнительные пробельные символы и комментарии. При использовании этого модификатора, механизм регулярных выражений игнорирует пробельные символы и комментарии. Результат зачастую получается намного более читабельный:</p>

<pre><code>    my $attr_re = qr{
        \A                    # &#x43D;&#x430;&#x447;&#x430;&#x43B;&#x43E; &#x441;&#x442;&#x440;&#x43E;&#x43A;&#x438;

        (?:
          [;\n\s]*            # &#x43F;&#x440;&#x43E;&#x431;&#x435;&#x43B;&#x44B; &#x438; &#x434;&#x432;&#x43E;&#x435;&#x442;&#x43E;&#x447;&#x438;&#x44F;
          (?:/\*.*?\*/)?      # &#x43A;&#x43E;&#x43C;&#x43C;&#x435;&#x43D;&#x442;&#x430;&#x440;&#x438;&#x438; &#x432; &#x441;&#x442;&#x438;&#x43B;&#x435; C
        )*

        ATTR

        \s+
        (   U?INTVAL
          | FLOATVAL
          | STRING\s+\*
        )
    }x;</code></pre>

<p>Это регулярное выражение не <em>простое</em>, но комментарии и пробельные символы улучшают его читабельность. Даже если вы составляете регулярные выражения из компилированных фрагментов, модификатор <code>/x</code> всё ещё может улучшить ваш код.</p>

<p>  </p>

<p>Модификатор <code>/g</code> проверяет соответствие регулярному выражению глобально по всей строке. Это имеет смысл при использовании в замене:</p>

<pre><code>    # &#x443;&#x441;&#x43F;&#x43E;&#x43A;&#x43E;&#x438;&#x442;&#x44C; Mitchell estate
    my $contents = slurp( $file );
    $contents    =~ s/Scarlett O&#39;Hara/Mauve Midway/g;</code></pre>

<p>  </p>

<p>При использовании с сопоставлением &mdash; не заменой &mdash; метасимвол <code>\G</code> позволяет вам обработать строку в цикле по одному куску за раз. <code>\G</code> соответствует позиции, на которой завершилось самое последнее соответствие. Чтобы обработать плохо закодированный файл, полный американских телефонных номеров в логических кусках, вы можете написать:</p>

<pre><code>    while ($contents =~ /\G(\w{3})(\w{3})(\w{4})/g)
    {
        push @numbers, &quot;($1) $2-$3&quot;;
    }</code></pre>

<p>Имейте ввиду, что якорь <code>\G</code> будет занимать последнюю точку в строке, где произошла предыдущаю итерация совпадения. Если предыдущее совпадение закончилось жадным совпадением, таким как <code>.*</code>, следующее соответствие будет иметь меньше доступной строки для сопоставления. Проверки заглядывания вперёд тоже могут помочь.</p>

<p>  </p>

<p>Модификатор <code>/e</code> позволяет вам писать произвольный код Perl 5 на правой стороне операции замены. Если сопоставление будет успешным, механизм регулярных выражений выполнит код и использует возвращаемое им значение как значение для замены. Приведённый ранее пример глобальной замены может быть выполнен проще с помощью такого кода:</p>

<pre><code>    # &#x443;&#x441;&#x43F;&#x43E;&#x43A;&#x43E;&#x438;&#x442;&#x44C; Mitchell estate
    $sequel  =~ s{Scarlett( O&#39;Hara)?}
                 {
                    &#39;Mauve&#39; . defined $1
                            ? &#39; Midway&#39;
                            : &#39;&#39;
                 }ge;</code></pre>

<p>Каждое дополнительное вхождение модификатора <code>/e</code> будет приводить к ещё одному вычислению результата выражения, хотя только Perl-гольферы используют что-нибудь дальше <code>/ee</code>.</p>

<h2>Умное сопоставление</h2>

<p><a name="smart_match"></p>

<p>    </p>

<p>Оператор умного сопоставления, <code>~~</code>, сравнивает два операнда и возвращает истинное значение, если они успешно сопоставлены. Расплывчатость определения демонстрирует умность оператора: тип сравнения зависит от типов обоих операндов. <code>given</code> (<a href="chapter_03.html#given_when">given/when</a>) выполняет неявное умное сопоставление.</p>

<p> </p>

<p>Оператор умного сопоставления &mdash; инфиксный оператор:</p>

<pre><code>    say &#39;They match (somehow)&#39; if $loperand ~~ $roperand;</code></pre>

<p>Тип сравнения обычно зависит в первую очередь от типа правого операнда, а затем &mdash; от левого. Например, если правый операнд &mdash; скаляр с числовой составляющей, сравнение будет использовать числовое равенство. Если правый операнд &mdash; регулярное выражение, сравнение будет использовать grep или сопоставление шаблону. Если правый операнд &mdash; массив, сравнение будет выполнять grep или рекурсивное умное сопоставление Если правый операнд &mdash; хеш, сравнение будет проверять существование одного или более ключей. Большая и устрашающая диаграмма в <code>perldoc perlsyn</code> даёт гораздо больше деталей обо всех сравнениях, которые может выполнять оператор умного сопоставления.</p>

<p>Серьёзное предложение для 5.16 предполагает существенное упрощение умного сопоставления. Чем более сложны ваши операнды, тем больше у вас шансов получить сбивающий с толку результат. Избегайте сравнения объектов и придерживайтесь простых операций между двумя скалярами или одним скаляром и одной агрегатной переменной для достижения наилучших результатов.</p>

<p>С учётом вышесказанного, умное сопоставление может быть полезным:</p>

<pre><code>    my ($x, $y) = (10, 20);
    say &#39;Not equal numerically&#39; unless $x ~~ $y;

    my $z = &#39;10 little endians&#39;;
    say &#39;Equal numeric-ishally&#39; if $x ~~ $z;

    # &#x441;&#x43E;&#x43F;&#x43E;&#x441;&#x442;&#x430;&#x432;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x440;&#x435;&#x433;&#x443;&#x43B;&#x44F;&#x440;&#x43D;&#x43E;&#x43C;&#x443; &#x432;&#x44B;&#x440;&#x430;&#x436;&#x435;&#x43D;&#x438;&#x44E;
    my $needle = qr/needle/;

    say &#39;Pattern match&#39; if &#39;needle&#39; ~~ $needle;

    say &#39;Grep through array&#39; if @haystack ~~ $needle;

    say &#39;Grep through hash keys&#39; if %hayhash ~~ $needle;

    say &#39;Grep through array&#39; if $needle ~~ @haystack;

    say &#39;Array elements exist as hash keys&#39;
        if %hayhash    ~~ @haystack;

    say &#39;Smart match elements&#39; if @straw ~~ @haystack;

    say &#39;Grep through hash keys&#39; if $needle ~~ %hayhash;

    say &#39;Array elements exist as hash keys&#39;
        if @haystack  ~~ %hayhash;

    say &#39;Hash keys identical&#39; if %hayhash ~~ %haymap;</code></pre>

<p>Умный поиск соответствия работает даже если один из операндов &mdash; <em>ссылка</em> на заданный тип данных:</p>

<pre><code>    say &#39;Hash keys identical&#39; if %hayhash ~~ \%hayhash;</code></pre>

</body></html>