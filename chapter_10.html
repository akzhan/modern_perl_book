<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="style.css" type="text/css"></head><body><h1>Perl за пределами синтаксиса</h1>

<p>Детский Perl доведёт вас лишь до сюда. Беглость языка позволит вам использовать естественные шаблоны и идиомы языка. Эффективные программисты понимают, как возможности Perl взаимодействуют и сочетаются друг с другом.</p>

<p>Приготовьтесь к второй кривой обучения Perl: Perl-мышление. Результатом будет лаконичный, мощный код в стиле Perl.</p>

<h2>Идиомы</h2>

<p><a name="idioms"></p>

<p>Каждый язык &mdash; язык программирования или естественный &mdash; имеет распространённые шаблоны выражений, или <em>идиомы</em>. Земля вращается, но мы говорим о восходящем и заходящем солнце. Мы хвастаемся умными хаками и и морщимся от страшных хаков в процессе работы с кодом.</p>

<p>Идиомы Perl &mdash; не совсем возможности языка или техники дизайна. Это манеры и механизмы, которые, сложенные вместе, дают вашему коду перловый акцент. Вы не обязаны их использовать, но они придают Perl силу.</p>

<h3>Объект как <code>$self</code></h3>

<p>    </p>

<p>Объектная система Perl 5 (<a href="chapter_07.html#moose">Moose</a>) работает с инвокантом метода как с обычным параметром. Независимо от того, вызываете ли вы метод класса или экземпляра, первый элемент <code>@_</code> &mdash; всегда инвокант метода. По соглашению, большая часть кода на Perl 5 использует <code>$class</code> как имя инвоканта метода класса и <code>$self</code> как имя инвоканта объекта. Это соглашение достаточно сильно, чтобы полезные расширения, такие как <code>MooseX::Method::Signatures</code>, исходили из предположения, что бы используете <code>$self</code> как имя объектных инвокантов.</p>

<h3>Именованные параметры</h3>

<p>   </p>

<p>Обработка списков &mdash; фундаментальная составляющая обработки выражений в Perl 5. Способность Perl-программистов объединять в цепочки выражения, возвращающие списки переменной длины, предоставляет бесчисленные возможности для эффективного манипулирования данными.</p>

<p>Хотя простота передачи аргументов в Perl 5 (всё разглаживается в <code>@_</code>) иногда слишком проста, присваивание из <code>@_</code> в списочном контексте позволяет вам распаковывать именованные параметры как пары. Оператор толстой запятой (<a href="chapter_03.html#declaring_hashes">Объявление хешей</a>) превращает простой список в то, что очевидно является списком пар аргументов:</p>

<pre><code>    make_ice_cream_sundae(
        whipped_cream =&gt; 1,
        sprinkles     =&gt; 1,
        banana        =&gt; 0,
        ice_cream     =&gt; &#39;mint chocolate chip&#39;,
    );</code></pre>

<p>Вызываемая сторона может распаковать эти параметры в хеш и работать с хешем, как если бы он был одним аргументом:</p>

<pre><code>    sub make_ice_cream_sundae
    {
        <strong>my %args    = @_;</strong>
        my $dessert = get_ice_cream( $args{ice_cream} );

        ...
    }</code></pre>

<p><em>Perl Best Practices</em> предлагает вместо хешей передавать ссылки на хеши. Это позволяет Perl выполнять валидацию ссылки на хеш на вызываемой стороне.</p>

<p>Эта техника хорошо работает с <code>import()</code> (<a href="chapter_05.html#importing">Импорт</a>) или другими методами; обработайте столько параметров, сколько хотите, прежде чем поглотить оставшуюся часть в хеш:</p>

<pre><code>    sub import
    {
        <strong>my ($class, %args)  = @_;</strong>
        my $calling_package = caller();

        ...
    }</code></pre>

<h3>Преобразование Шварца</h3>

<p><a name="schwartzian_transform"></p>

<p>    </p>

<p><em>Преобразование Шварца</em> &mdash; элегантная демонстрация всепроникающей обработки списков в Perl в виде идиомы, удачно позаимствованной из семейства языков Lisp.</p>

<p>Предположим, у вас есть Perl-хеш, ассоциирующий имена ваших коллег с их телефонными номерами:</p>

<pre><code>    my %extensions =
    (
        &#39;001&#39; =&gt; &#39;Armon&#39;,
        &#39;002&#39; =&gt; &#39;Wesley&#39;,
        &#39;003&#39; =&gt; &#39;Gerald&#39;,
        &#39;005&#39; =&gt; &#39;Rudy&#39;,
        &#39;007&#39; =&gt; &#39;Brandon&#39;,
        &#39;008&#39; =&gt; &#39;Patrick&#39;,
        &#39;011&#39; =&gt; &#39;Luke&#39;,
        &#39;012&#39; =&gt; &#39;LaMarcus&#39;,
        &#39;017&#39; =&gt; &#39;Chris&#39;,
        &#39;020&#39; =&gt; &#39;Maurice&#39;,
        &#39;023&#39; =&gt; &#39;Marcus&#39;,
        &#39;024&#39; =&gt; &#39;Andre&#39;,
        &#39;052&#39; =&gt; &#39;Greg&#39;,
        &#39;088&#39; =&gt; &#39;Nic&#39;,
    );</code></pre>

<p>Заключение в кавычки ключа хеша с помощью толстой запятой работает только с тем, что выглядит как голые слова; эти ключи выглядят как числа &mdash; восьмеричные числа, если быть конкретным, с ведущим нулём. Да, почти все делают эту ошибку.</p>

<p>Чтобы отсортировать список по имени в алфавитном порядке, вы должны отсортировать хеш по его значениям, не ключам. Получить корректно отсортированные значения легко:</p>

<pre><code>    my @sorted_names = sort values %extensions;</code></pre>

<p>&hellip;но вам нужен дополнительный шаг для сохранения связи имён и телефонов, тут и вступает в дело преобразование Шварца. Во-первых, сконвертируйте хеш в список структур данных, которые легко сортировать &mdash; в данном случае, двухэлементных анонимных массивов:</p>

<pre><code>    my @pairs = map  { [ $_, $extensions{$_} ] }
                keys %extensions;</code></pre>

<p><code>sort</code> принимает список анонимных массивов и сравнивает их вторые элементы (имена) как строки:</p>

<pre><code>    my @sorted_pairs = sort { $a-&gt;[1] cmp $b-&gt;[1] }
                            @pairs;</code></pre>

<p>  </p>

<p>Блок, переданный в <code>sort</code>, принимает её аргументы в виде двух переменных <code>$a</code> и <code>$b</code>, принадлежащих области видимости пакета (footnote: См. в <code>perldoc -f sort</code> пространное обсуждение применений такой организации области видимости.). Блок <code>sort</code> принимает свои аргументы по два за раз; первый становится содержимым <code>$a</code>, а второй &mdash; содержимым <code>$b</code>. Если значение <code>$a</code> должно идти в результатах перед <code>$b</code>, блок должен вернуть -1. Если оба значения достаточно эквиваленты с точки зрения сортировки, блок должен вернуть 0. Наконец, если <code>$a</code> должно идти в результатах после <code>$b</code>, блок должен вернуть 1. Любые другие возвращаемые значения являются ошибками.</p>

<p>Переворачивание хеша <em>на месте</em> будет работать, если имена ни у кого не повторяются. Этот конкретный набор данных не имеет такой проблемы, но пишите код с защитой.</p>

<p> </p>

<p>Оператор <code>cmp</code> выполняет строковое сравнение, а <code><=></code> выполняет числовое сравнение.</p>

<p>Имея <code>@sorted_pairs</code>, вторая операция <code>map</code> преобразует структуру данных в более удобную форму:</p>

<pre><code>    my @formatted_exts = map { &quot;$_-&gt;[1], ext. $_-&gt;[0]&quot; }
                             @sorted_pairs;</code></pre>

<p>&hellip;и теперь вы можете всё это вывести:</p>

<pre><code>    say for @formatted_exts;</code></pre>

<p>Преобразование Шварца само по себе использует всепроникающую обработку списков в Perl чтобы избавиться от временных переменных. Комбинация такая:</p>

<pre><code>    say for
        map  { &quot; $_-&gt;[1], ext. $_-&gt;[0]&quot;          }
        sort {   $a-&gt;[1] cmp   $b-&gt;[1]           }
        map  { [ $_      =&gt;    $extensions{$_} ] }
            keys %extensions;</code></pre>

<p>Читайте выражение справа налево, в порядке вычисления. Для каждого ключа в хеше телефонов создать двухэлементный анонимный массив, содержащий ключ и значение из хеша. Отсортировать этот список анонимных массивов по их вторым элементам, значениям из хеша. Сформировать строку вывода из этих отсортированных массивов.</p>

<p>Канал <code>map</code>&mdash;<code>sort</code>&mdash;<code>map</code> в преобразовании Шварца трансформирует структуру данных в другую, более подходящую для сортировки, а затем трансформирует её снова в другую форму.</p>

<p>Хотя этот пример сортировки прост, рассмотрите случай вычисления криптографического хеша для большого файла. Преобразование Шварца особенно полезно, потому что оно эффективно кеширует любые дорогие вычисления, выполняя их один раз в правом <code>map</code>.</p>

<h3>Лёгкое поглощение файлов</h3>

<p><a name="easy_file_slurping"></p>

<p>   </p>

<p><code>local</code> имеет большое значения для управления магическими глобальными переменными Perl 5. Вы должны понимать области видимости (<a href="chapter_05.html#scope">Область видимости</a>), чтобы эффективно использовать <code>local</code> &mdash; но если вам это удастся, вы можете использовать тесные и легковесные области видимости интересными способами. Например, для поглощения файлов в скаляр в одном выражении:</p>

<pre><code>    my $file = do { local $/ = &lt;$fh&gt; };

    # &#x438;&#x43B;&#x438;
    my $file = do { local $/; &lt;$fh&gt; };

    # &#x438;&#x43B;&#x438;
    my $file; { local $/; $file = &lt;$fh&gt; };</code></pre>

<p><code>$/</code> &mdash; это разделитель входных записей. Его локализация с помощью <code>local</code> устанавливает его значение в <code>undef</code>, ожидая присваивания. Эта локализация происходит <em>перед</em> присваиванием. Так как значение разделителя неопределённо, Perl охотно считает всё содержимое дескриптора файла сразу и присвоит это значение <code>$/</code>. Так как блок <code>do</code> возвращает значение последнего вычисленного внутри блока выражения, это возвращает значение присваивания: содержимое файла. Даже несмотря на то, что в конце блока <code>$/</code> немедленно возвращается к своему предыдущему состоянию, <code>$file</code> теперь вмещает содержимое файла.</p>

<p>Второй пример не содержит присваивания и всего лишь возвращает единственную строку, прочитанную из дескриптора файла.</p>

<p>Третий пример избегает повторного копирования строки, вмещающей содержимое файла; он не так красив, но использует меньше памяти.</p>

<p></p>

<p>Общеизвестно, что этот полезный пример сводит с ума людей, не понимающих, как работает и <code>local</code>, и области видимости. Модуль <code>File::Slurp</code> из CPAN &mdash; стоящая (и зачастую более быстрая) альтернатива.</p>

<h3>Обращение с главным</h3>

<p>Perl не требует специального синтаксиса для создания замыканий (<a href="chapter_05.html#closures">Замыкания</a>); вы можете непреднамеренно замкнуть лексическую переменную. Многие программы обычно выставляют несколько лексичеких переменных области видимости файла, прежде чем передать обработку другим функциям. Возникает соблазн использовать эти переменные напрямую, вместо передачи и возврата значений из функций, особенно с ростом программы. К сожалению, эти программы могут начать полагаться на тонкости того, что происходит во время процесса компиляции Perl 5; переменная, которая, как вы <em>думали</em>, должна быть инициализирована определённым значением, может быть инициализирована лишь намного позже.</p>

<p>Чтобы этого избежать, оберните основной код вашей программы в простую функцию, <code>main()</code>. Инкапсулируйте ваши переменные в соответствующих областях видимости. Затем добавьте единственную строку в начало вашей программы, после подключения всех нужных модулей и прагм:</p>

<pre><code>    #!/usr/bin/perl

    use Modern::Perl;

    ...

    <strong>exit main( @ARGS );</strong></code></pre>

<p>Вызов <code>main()</code> <em>перед</em> чем либо ещё в программе заставляет вас быть ясными относительно инициализации и порядка компиляции. Вызов <code>exit</code> с возвращаемым <code>main()</code> значением предотвращает любой другой голый код от выполнения, хотя вы должны удостовериться, что возвращаете <code>0</code> из <code>main()</code> в случае успешного выполнения.</p>

<h3>Контроллируемое выполнение</h3>

<p><a name="controlled_execution"></p>

<p>Фактическое различие между программой и модулем &mdash; в их намеренном использовании. Пользователи вызывают программы напрямую, тогда как программы загружают модули после того, как выполнение уже началось. Тем не менее, модуль &mdash; это Perl-код, точно так же, как и программа. Модуль легко сделать исполняемым. Так же как и заставить программу вести себя как модуль (полезно для тестирования частей существующей программы без формального преобразования её в модуль). Всё что вам нужно сделать &mdash; открыть для себя, <em>как</em> Perl начинает выполнение куска кода.</p>

<p></p>

<p>Единственный необязательный аргумент <code>caller</code> &mdash; это число фреймов вызова (<a href="chapter_05.html#recursion">Рекурсия</a>), которое нужно выдать. <code>caller(0)</code> выводит информацию о текущем фрейме вызова. Чтобы позволить модулю работать корректно как программа <em>или</em> модуль, поместите весь выполняемый код в функции, добавьте функцию <code>main()</code> и допишите одну строку в начало модуля:</p>

<pre><code>    main() unless caller(0);</code></pre>

<p>Если у модуля <em>нет</em> вызывающего кода, значит, кто-то вызвал его напрямую как программу (с помощью <code>perl path/to/Module.pm</code>) вместо <code>use Module;</code>).</p>

<p>Восьмой элемент списка, возвращаемого из <code>caller</code> в списочном контексте, будет истинным значением, если фрейм вызова представляет собой <code>use</code> или <code>require</code>, и <code>undef</code> в противном случае. Хотя это более точно, немногие этим пользуются.</p>

<h3>Постфиксная валидация параметров</h3>

<p><a name="postfix_parameter_validation"></p>

<p> </p>

<p>В CPAN есть несколько модулей, помогающих проверить параметры ваших функций; два хороших варианта &mdash; <code>Params::Validate</code> и <code>MooseX::Params::Validate</code>. Выполнить простую валидацию легко даже без этих модулей.</p>

<p>Предположим, ваша функция принимает два аргумента, не больше и не меньше. Вы <em>могли бы</em> написать:</p>

<pre><code>    use Carp &#39;croak&#39;;

    sub groom_monkeys
    {
        if (@_ != 2)
        {
            croak &#39;Grooming requires two monkeys!&#39;;
        }
        ...
    }</code></pre>

<p>&hellip;но с лингвистической точки зрения последствия более важны, чем проверка, и заслуживают быть в <em>начале</em> выражения:</p>

<pre><code>    croak &#39;Grooming requires two monkeys!&#39; if @_ != 2;</code></pre>

<p>&hellip;что может читаться проще в следующем виде:</p>

<pre><code>    croak &#39;Grooming requires two monkeys!&#39;
        unless @_ == 2;</code></pre>

<p>Эта техника раннего возврата &mdash; особенно с постфиксными условиями &mdash; может упростить оставшуюся часть кода. Каждая такая проверка &mdash; это фактически одна строка в таблице истинности.</p>

<h3>Регулярные выражения мимоходом</h3>

<p><a name="regex_en_passant"></p>

<p> </p>

<p>Многие идиомы Perl 5 полагаются на тот факт, что выражения возвращают значения:</p>

<pre><code>    say my $ext_num = my $extension = 42;</code></pre>

<p>Хотя этот код очевидно неуклюж, он демонстрирует, как использовать значение одного выражения в другом выражении. Эта идея не нова; вы с большой вероятностью и раньше использовали возвращаемое значение функции в списке или как аргумент другой функции. Вы, возможно, не осознавали последствий этого.</p>

<p></p>

<p>Предположим, вы хотите извлечь имя из сочетания имени и фамилии с помощью прекомпилированного регулярного выражения в <code>$first_name_rx</code>:</p>

<pre><code>    my ($first_name) = $name =~ /($first_name_rx)/;</code></pre>

<p>В списочном контексте успешное сопоставление регулярному выражению возвращает список всех захватов (<a href="chapter_06.html#regex_captures">Захват</a>), и Perl присваивает первый из них <code>$first_name</code>.</p>

<p>Чтобы изменить имя, возможно, удалив все несловарные символы для создания пригодного имени пользователя для системного аккаунта, вы можете написать:</p>

<pre><code>    (my $normalized_name = $name) =~ tr/A-Za-z//dc;</code></pre>

<p>В Perl 5.14 был добавлен недеструктивный модификатор замены <code>/r</code>, так что вы можете написать <code>my $normalized_name = $name =~ tr/A-Za-z//dc<strong>r</strong>;</code>.</p>

<p>Сперва присвойте значение <code>$name</code> <code>$normalized_name</code>, так как скобки влияют на приоритет, это присваивание произойдёт первым. Выражение присваивания возвращает <em>переменную</em> <code>$normalized_name</code>, так что эта переменная становится первым операндом оператора транслитерации.</p>

<p>Эта техника работает и с другими операциями модификации на месте:</p>

<pre><code>    my $age = 14;
    (my $next_age = $age)++;

    say &quot;Next year I will be $next_age&quot;;</code></pre>

<h3>Унарное приведение типа</h3>

<p><a name="unary_coercions"></p>

<p> </p>

<p>Система типов Perl 5 почти всегда делает то, что нужно, если вы выбираете правильные операторы. Используйте оператор строковой конкатенации, и Perl будет обращаться с обоими операндами как со строками. Используйте оператор сложения, и Perl будет обращаться с обоими операндами как с числовыми.</p>

<p>Иногда вам придётся дать Perl подсказку о том, что вы имеете ввиду, с помощью <em>унарного приведения типа</em>, чтобы заставить вычисление значения выполняться конкретным образом.</p>

<p></p>

<p>Чтобы убедиться, что Perl обрабатывает значение как числовое, прибавьте ноль:</p>

<pre><code>    my $numeric_value = 0 + $value;</code></pre>

<p></p>

<p>Чтобы убедиться, что Perl обрабатывает значение как булево, используйте двойное отрицание:</p>

<pre><code>    my $boolean_value = !! $value;</code></pre>

<p></p>

<p>Чтобы убедиться, что Perl обрабатывает значение как строку, конкатенируйте его с пустой строкой:</p>

<pre><code>    my $string_value = &#39;&#39; . $value;</code></pre>

<p>Хотя потребность в этих приведениях типа исчезающе мала, вы должны понимать эти идиомы, если они вам встретятся. Хотя удаление &laquo;бесполезного&raquo; <code>+ 0</code> из выражения может выглядеть безопасным, это может сломать код.</p>

<h2>Глобальные переменные</h2>

<p><a name="globals"></p>

<p> </p>

<p>Perl 5 предоставляет несколько <em>суперглобальных переменных</em>, которые поистине глобальны, не ограничены областью видимости пакета или файла. К сожалению, их глобальная доступность означает, что любые прямые или непрямые модификации могут повлиять на другие части программы &mdash; и они немногословны. Опытные программисты на Perl 5 запоминают некоторые из них. Мало кто помнит их все. Лишь некоторые из них бывают полезны. <code>perldoc perlvar</code> содержит исчерпывающий список таких переменных.</p>

<h3>Управление суперглобальными переменными</h3>

<p> </p>

<p>Perl 5 продолжает перемещать ещё больше глобального поведения в лексическое поведение, так что вы можете избежать многих из этих глобальных переменных. Когда вы не можете их избежать, используйте <code>local</code> в наименьшей возможной области видимости чтобы ограничить любые изменения. Вы всё ещё восприимчивы к любым изменениям, которые <em>вызываемый</em> вами код сделает с этими глобальными переменными, но вы уменьшаете вероятность неожиданного кода <em>снаружи</em> вашей области видимости. Как демонстрирует идиома лёгкого поглощения файла (<a href="chapter_10.html#easy_file_slurping">Лёгкое поглощение файлов</a>), <code>local</code> зачастую правильный подход:</p>

<pre><code>    my $file; { <strong>local $/</strong>; $file = &lt;$fh&gt; };</code></pre>

<p>Эффект локализации <code>$/</code> длится только до конца блока. Невелик шанс, что какой-либо Perl-код будет выполнен как результат чтения строк из дескриптора файла (footnote: Связанный дескриптор файла (<a href="chapter_11.html#tie">Связывание</a>) &mdash; одна из немногих вероятностей.) и изменит значение <code>$/</code> внутри блока <code>do</code>.</p>

<p>Не все случаюи использования суперглобальных переменных так легко защитить, но это зачастую работает.</p>

<p>  </p>

<p>В других случаях вам нужно <em>прочитать</em> значение суперглобальной переменной, и надеяться, что другой код его не изменил. Отлавливание исключений с помощью блока <code>eval</code> может быть восприимчиво к условиям гонки, поскольку метод <code>DESTROY()</code>, вызванный на лексической переменной, которая вышла за пределы области видимости, может сбросить <code>$@</code>:</p>

<pre><code>    local $@;

    eval { ... };

    if (<strong>my $exception = $@</strong>) { ... }</code></pre>

<p>Копируйте <code>$@</code> <em>сразу же</em> после поимки исключения, чтобы сохранить её содержимое. Смотрите также <code>Try::Tiny</code> вместо этого (<a href="chapter_08.html#exception_caveats">Предостережения об исключениях</a>).</p>

<h3>Английские имена</h3>

<p></p>

<p>Базовый модуль <code>English</code> предоставляет подробные имена для насыщенных пунктуацией суперглобальных переменных. Импортируйте их в пространство имён следующим образом:</p>

<pre><code>    use English &#39;-no_match_vars&#39;;</code></pre>

<p>Это позволит вам использовать подробные имена, документированные в <code>perldoc perlvar</code>, внутри области видимости этой прагмы.</p>

<p>     </p>

<p>Три связанных с регулярными выражениями суперглобальных переменных (<code>$&</code>, <code>$`</code> и <code>$'</code>) приводят к снижению производительности <em>всех</em> регулярных выражений в программе. Если вы забудете <code>-no_match_vars</code> при импорте, ваша программа получит минус производительности, даже если вы не читаете явно из этих переменных.</p>

<p>Программы на Современном Perl должны использовать переменную <code>@-</code> как замену для этих ужасных трёх.</p>

<h3>Полезные суперглобальные переменные</h3>

<p></p>

<p>Большая часть программ на современном Perl 5 может обойтись использованием только нескольких из суперглобальных переменных. Вы с большой вероятностью встретите лишь немногие из этих переменных в реальных программах.</p>

<p>    </p>

<ul>

<li><code>$/</code> (или <code>$INPUT_RECORD_SEPARATOR</code> из прагмы <code>English</code>) это строка из нуля или более символов, обозначающая конец записи при построчном чтении входных данных. По умолчанию, это платформозависимая последовательность символов новой строки. Если вы сделаете это значение неопределённым, Perl будет пытаться прочитать файл в память целиком. Если вы установите это значение в <em>ссылку</em> на целое число, Perl будет пытаться прочитать именно столько <em>байт</em> на запись (так что не забывайте о вопросах Юникода). Если вы установите это значение в пустую строку (<code>''</code>), Perl будет читать по параграфу за раз, где параграф &mdash; это порция текста, за которой следует произвольное количество новых строк.</li>

<p>   </p>

<li><code>$.</code> (<code>$INPUT_LINE_NUMBER</code>) содержит количество записей, прочитанных из дескриптора файла, к которому последний раз осуществлялся доступ. Вы можете читать из этой переменной, но запись в неё не даст никакого эффекта. Локализация этой переменной будет локализовать дескриптор файла, на который она ссылается.</li>

<p>   </p>

<li><code>$|</code> (<code>$OUTPUT_AUTOFLUSH</code>) управляет тем, будет ли Perl сбрасывать всё, что записано в текущий выбранный дескриптор файла, сразу же, или только когда буфер Perl заполнится. Небуферизованный вывод полезен при записи в канал, или сокет, или терминал, который не должен блокироваться ожиданием ввода. Эта переменная будет приводить любые присвоенные ей значение в булевы.</li>

<p> </p>

<li><code>@ARGV</code> содержит агрументы командной строки, переданные в программу.</li>

<p>   </p>

<li><code>$!</code> (<code>$ERRNO</code>) это двойная переменная (<a href="chapter_03.html#dualvars">Двойные переменные</a>), содержащая результат <em>последнего</em> системного вызова. В числовом контексте она соответствует значению <code>errno</code> в C, где всё, кроме ноля, обозначает ошибку. В строковом контексте она возвращает соответствующую строку системной ошибки. Локализуйте эту переменную, прежде чем выполнить системный вызов (явно или неявно), чтобы избежать перезаписывания соответствующего значения для другого кода где бы то ни было. Многие места в самом Perl 5 делают системные вызовы, о которых вы не знаете, так что значение этой переменной может измениться независимо от вас. Копируйте его <em>сразу же</em> после выполнения системного вызова для получения наиболее точных результатов.</li>

<p>   </p>

<li><code>$"</code> (<code>$LIST_SEPARATOR</code>) это строка, используемая для разделения элементов массивов и списков, интерполируемых в строку.</li>

<p> </p>

<li><code>%+</code> содержит именованные захваты из успешного сопоставления регулярному выражению (<a href="chapter_06.html#named_captures">Именованные захваты</a>).</li>

<p>   </p>

<li><code>$@</code> (<code>$EVAL_ERROR</code>) содержит значение, выброшенное из последнего исключения (<a href="chapter_08.html#catching_exceptions">Отлавливание исключений</a>).</li>

<p>   </p>

<li><code>$0</code> (<code>$PROGRAM_NAME</code>) содержит имя выполняемой программы. Вы можете модифицировать это значение на некоторых Unix-подобных платформах чтобы изменить имя программы, под которым она предстаёт перед другими программами, такими как <code>ps</code> или <code>top</code>.</li>

<p>   </p>

<li><code>$$</code> (<code>$PID</code>) содержит идентификатор процесса текущего выполняемого экземпляра программы, как его понимает операционная система. Он будет различаться между программами, разветвлёнными с помощью <code>fork()</code>, и <em>может</em> различаться между потоками в одной и той же программе.</li>

<p> </p>

<li><code>@INC</code> содержит список путей в файловой системе, по которым Perl будет искать файлы для загрузки с помощью <code>use</code> или <code>require</code>. Смотрите <code>perldoc -f require</code> для информации о других элементах, которые этот массив может содержать.</li>

<p> </p>

<li><code>%SIG</code> ставит в соответствие низкоуровневым сигналам ОС и Perl ссылки на функции, используемые для обработки этих сигналов. Например, можно отловить стандартное прерывание по Ctrl-C с помощью сигнала <code>INT</code>. См. <code>perldoc perlipc</code> для большей информации о сигналах и особенно безопасных сигналах.</li>

</ul>

<h3>Альтернативы суперглобальным переменным</h3>

<p> </p>

<p>Самые тяжёлые обвинения о воздействии на расстоянии относятся к вводу/выводу и исключительным условиям. Использование <code>Try::Tiny</code> (<a href="chapter_08.html#exception_caveats">Предостережения об исключениях</a>) поможет вам защититься от хитрой семантики правильной обработки исключений. Локализация и копирование значения <code>$!</code> может помощь вам избежать странных поведений, когда Perl выполняет неявные системные вызовы. Использование <code>IO::File</code> и его методов на лексических дескрипторах файлов (<a href="chapter_09.html#file_handling_variables">Специальные переменные обработки файлов</a>) поможет предотвратить нежелательные глобальные изменения поведения ввода/вывода.</p>

</body></html>