<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="style.css" type="text/css"></head><body><h1>Чего следует избегать</h1>

<p>Perl 5 не идеален. Некоторые возможности сложно использовать корректно. Другие никогда не работали хорошо. Некоторые &mdash; странные комбинации других возможностей со странными граничными случаями. Хотя лучше избегать этих возможностей, знание того, почему их нужно избегать, поможет вам найти более подходящие решения.</p>

<h2>Голые слова</h2>

<p><a name="barewords"></p>

<p>Perl &mdash; податливый язык. Вы можете писать программы в предпочитаемой вами наиболее творческой, поддерживаемой, запутанной или эксцентричной манере. Хорошие программисты заботятся о поддерживаемости, но Perl не пытается диктовать, что <em>вы</em> считаете поддерживаемым.</p>

<p>  </p>

<p>Парсер Perl понимает встроенные функции и операторы Perl. Он использует сигилы для идентификации переменных и другую пунктуацию для распознавания вызовов функций и методов. Однако, иногда парсеру приходится догадываться, что вы имеете ввиду, особенно когда вы используете <em>голое слово</em> &mdash; идентификатор без сигила или другой синтаксически значимой пунктуации.</p>

<h3>Хорошее использование голых слов</h3>

<p></p>

<p>Хотя прагма <code>strict</code> (<a href="chapter_08.html#pragmas">Прагмы</a>) справедливо запрещает неоднозначные голые слова, некоторые голые слова приемлемы.</p>

<h4>Голые слова как ключи хеша</h4>

<p> </p>

<p>Ключи хеша в Perl 5 обычно <em>не</em> допускают неоднозначности, потому что парсер может идентифицировать их как строковые ключи; <code>pinball</code> в <code>$games{pinball}</code> &mdash; это очевидно строка.</p>

<p>Иногда эта интерпретация &mdash; не то, чего вы хотите, особенно если вы намеревались <em>вычислить</em> встроенную или пользовательскую функцию, чтобы сгенерировать ключ хеша. В этом случае, устраните неоднозначность, указав аргументы, используя круглые скобки для аргументов функции, или предварите унарным плюсом, чтобы форсировать вычисление встроенной функции:</p>

<pre><code>    # &#x43A;&#x43B;&#x44E;&#x447;&#x43E;&#x43C; &#x431;&#x443;&#x434;&#x435;&#x442; &#x43B;&#x438;&#x442;&#x435;&#x440;&#x430;&#x43B;&#x44C;&#x43D;&#x44B;&#x439; &laquo;shift&raquo;
    my $value = $items{<strong>shift</strong>};

    # &#x43A;&#x43B;&#x44E;&#x447;&#x43E;&#x43C; &#x431;&#x443;&#x434;&#x435;&#x442; &#x437;&#x43D;&#x430;&#x447;&#x435;&#x43D;&#x438;&#x435;, &#x432;&#x43E;&#x437;&#x432;&#x440;&#x430;&#x449;&#x451;&#x43D;&#x43D;&#x43E;&#x435; &laquo;shift&raquo;
    my $value = $items{<strong>shift @_</strong>}

    # &#x443;&#x43D;&#x430;&#x440;&#x43D;&#x44B;&#x439; &#x43F;&#x43B;&#x44E;&#x441; &#x43F;&#x440;&#x438;&#x432;&#x43E;&#x434;&#x438;&#x442; &#x43A; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x44E; &#x432;&#x441;&#x442;&#x440;&#x43E;&#x435;&#x43D;&#x43D;&#x43E;&#x439; &#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x438; &laquo;shift&raquo;
    my $value = $items{<strong>+</strong>shift};</code></pre>

<h4>Голые слова как имена пакетов</h4>

<p></p>

<p>Имена пакетов в Perl 5 тоже являютя голыми словами. Если вы следуете соглашениям об именовании, согласно которым имена пакетов начинаются с заглавных букв, а функций &mdash; нет, маловероятно, что вы встретитесь с коллизиями имён, но парсер Perl 5 должен определить, как парсить <code>Package->method()</code>. Значит ли это &laquo;вызвать функцию с именем <code>Package()</code> и вызвать метод <code>method()</code> на возвращаемом ей значении&raquo; или &laquo;вызвать метод с именем <code>method()</code> в пространстве имён <code>Package</code>&raquo;? Ответ различается в зависимости от того, какой код парсер уже встретил в текущем пространстве имён.</p>

<p>Принудите парсер воспринимать <code>Package</code> как имя пакета, добавив разделитель пакетов (<code>::</code>) (footnote: Даже среди тех, кто понимает, почему это работает, очень немногие это делают.):</p>

<pre><code>    # &#x432;&#x435;&#x440;&#x43E;&#x44F;&#x442;&#x43D;&#x43E; &#x43C;&#x435;&#x442;&#x43E;&#x434; &#x43A;&#x43B;&#x430;&#x441;&#x441;&#x430;
    Package-&gt;method();

    # &#x43E;&#x43F;&#x440;&#x435;&#x434;&#x435;&#x43B;&#x451;&#x43D;&#x43D;&#x43E; &#x43C;&#x435;&#x442;&#x43E;&#x434; &#x43A;&#x43B;&#x430;&#x441;&#x441;&#x430;
    Package::-&gt;method();</code></pre>

<h4>Голые слова как имена блоков кода</h4>

<p>      </p>

<p>Специальные именованные блоки кода <code>AUTOLOAD</code>, <code>BEGIN</code>, <code>CHECK</code>, <code>DESTROY</code>, <code>END</code>, <code>INIT</code> и <code>UNITCHECK</code> &mdash; это голые слова, которые <em>объявляют</em> функции без использования встроенной директивы <code>sub</code>. Вы уже видели это раньше (<a href="chapter_09.html#code_generation">Кодогенерация</a>):</p>

<pre><code>    package Monkey::Butler;

    BEGIN { initialize_simians( __PACKAGE__ ) }

    sub AUTOLOAD { ... }</code></pre>

<p>Хотя вы <em>можете</em> опустить <code>sub</code> из объявления <code>AUTOLOAD()</code>, немногие так делают.</p>

<h4>Голые слова как константы</h4>

<p></p>

<p>Константы, объявленные с помощью прагмы <code>constant</code>, можно использовать как голые слова:</p>

<pre><code>    # &#x43D;&#x435; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x443;&#x439;&#x442;&#x435; &#x44D;&#x442;&#x43E; &#x434;&#x43B;&#x44F; &#x440;&#x435;&#x430;&#x43B;&#x44C;&#x43D;&#x43E;&#x439; &#x430;&#x443;&#x442;&#x435;&#x43D;&#x442;&#x438;&#x444;&#x438;&#x43A;&#x430;&#x446;&#x438;&#x438;
    use constant NAME     =&gt; &#39;Bucky&#39;;
    use constant PASSWORD =&gt; &#39;|38fish!head74|&#39;;

    return unless $name eq NAME &amp;&amp; $pass eq PASSWORD;</code></pre>

<p>Обратите внимание, что эти константы <em>не</em> интерполируются в строках, заключённых в двойные кавычки.</p>

<p></p>

<p>Константы &mdash; специальный случай прототипированных функций (<a href="chapter_11.html#prototypes">Прототипы</a>). Когда вы предварительно объявляете функцию с прототипом, парсер знает, как воспринимать эту функцию, и будет предупреждать об ошибках неоднозначности парсинга. Все остальные недостатки прототипов всё ещё имеют место.</p>

<h3>Неблагоразумное использование голых слов</h3>

<p></p>

<p>Независимо от того, насколько внимательно вы пишете код, голые слова всё равно приводят к неоднозначностям. Вы можете избежать большинства их использований, но вам встретится несколько типов голых слов в унаследованном коде.</p>

<h4>Голые вызовы функций</h4>

<p> </p>

<p>Код, написанный без <code>strict 'subs'</code>, может использовать голые имена функций. Добавление скобок заставляет код пройти эти ограничения. Используйте <code>perl -MO=Deparse,-p</code> (см. <code>perldoc B::Deparse</code>) чтобы понять, как Perl парсит их, затем расставляйте скобки соответствующим образом.</p>

<h4>Голые значения хешей</h4>

<p></p>

<p>Некоторый старый код может не заботиться о том, чтобы заключить в кавычки <em>значения</em> хеш-пар:</p>

<pre><code>    # &#x43F;&#x43B;&#x43E;&#x445;&#x43E;&#x439; &#x441;&#x442;&#x438;&#x43B;&#x44C;; &#x43D;&#x435; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x442;&#x44C;
    my %parents =
    (
        mother =&gt; Annette,
        father =&gt; Floyd,
    );</code></pre>

<p>Если не существует ни функции <code>Floyd()</code>, ни <code>Annette()</code>, Perl будет интерпретировать эти голые слова как строки. <code>strict 'subs'</code> выдаст ошибку в этой ситуации.</p>

<h4>Голые дескрипторы файлов</h4>

<p></p>

<p>До появления лексических дескрипторов файлов (<a href="chapter_03.html#lexical_filehandles">Ссылки на дескрипторы файлов</a>), все дескрипторы файлов и директорий использовали голые слова. Вы почти всегда можете безопасно переписать этот код на использование лексических дескрипторов файлов; исключения &mdash; <code>STDIN</code>, <code>STDOUT</code> и <code>STDERR</code>. К счастью, парсер Perl распознаёт их.</p>

<h4>Голые функции sort</h4>

<p>  </p>

<p>Наконец, встроенная фукнция <code>sort</code> может принимать в качестве второго аргумента <em>имя</em> функции, которую нужно использовать для сортировки. Хотя это редко бывает неоднозначным для парсера, это может смутить читающих <em>людей</em>. Альтернатива в виде передачи ссылки на функцию в скаляре немного лучше:</p>

<pre><code>    # &#x441;&#x442;&#x438;&#x43B;&#x44C; &#x441; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435;&#x43C; &#x433;&#x43E;&#x43B;&#x43E;&#x433;&#x43E; &#x441;&#x43B;&#x43E;&#x432;&#x430;
    my @sorted = sort compare_lengths @unsorted;

    # &#x441;&#x441;&#x44B;&#x43B;&#x43A;&#x430; &#x43D;&#x430; &#x444;&#x443;&#x43A;&#x43D;&#x446;&#x438;&#x44E; &#x432; &#x441;&#x43A;&#x430;&#x43B;&#x44F;&#x440;&#x435;
    my $comparison = \&amp;compare_lengths;
    my @sorted     = sort $comparison @unsorted;</code></pre>

<p>Второй вариант избегает использования голого слова, но результат на одну строчку длиннее. К сожалению, парсер Perl 5 <em>не</em> понимает однострочную версию вследствие специального парсинга <code>sort</code>; вы не можете использовать произвольное выражение (такое как взятие ссылки на именованную функцию) там, где может пройти блок или скаляр.</p>

<pre><code>    # &#x43D;&#x435; &#x440;&#x430;&#x431;&#x43E;&#x442;&#x430;&#x435;&#x442;
    my @sorted = sort \&amp;compare_lengths @unsorted;</code></pre>

<p>В обоих случаях то, как <code>sort</code> вызывает функцию и передаёт аргументы, может быть запутывающим (см. <code>perldoc -f sort</code> для подробностей). Где возможно, рассмотрите использование вместо этого блочной формы <code>sort</code>. Если же вы должны использовать какую-либо из форм с функцией, рассмотрите добавление объясняющего комментария.</p>

<h2>Непрямые объекты</h2>

<p><a name="indirect_objects"></p>

<p>В Perl 5 нет оператора <code>new</code>; конструктором в Perl 5 является всё, что возвращает объект. По соглашению, конструкторы &mdash; методы классов, называемые <code>new()</code>, но вы можете выбрать всё, что захотите. Некоторые старые руководства по объектам Perl 5 поощряют использование вызовов конструкторов в стиле C++ и Java:</p>

<pre><code>    my $q = <strong>new</strong> CGI; # &#x41D;&#x415; &#x418;&#x421;&#x41F;&#x41E;&#x41B;&#x42C;&#x417;&#x41E;&#x412;&#x410;&#x422;&#x42C;</code></pre>

<p>&hellip;вместо очевидного вызова метода:</p>

<pre><code>    my $q = CGI-&gt;new();</code></pre>

<p>Эти варианты синтаксиса дают одинаковое поведение, за исключением случаев, когда это не так.</p>

<h3>Непрямые вызовы с голыми словами</h3>

<p> </p>

<p>В непрямой объектной форме (более точно, в <em>дательном</em> случае) первого примера глагол (метод) предшествует существительному, к которому относится (объект). Это нормально в разговорных языках, но в Perl 5 создаёт неоднозначности парсинга.</p>

<p>Так как имя метода &mdash; голое слово (<a href="chapter_11.html#barewords">Голые слова</a>), парсер должен предсказать правильную интерпретацию кода с помощью использования нескольких эвристик. Хотя эти эвристики хорошо протестированы и <em>почти</em> всегда корректны, их режимы сбоя сбивают с толку. Хуже того, они зависят от порядка компиляции кода и модулей.</p>

<p>Трудность парсинга увеличивается, если конструктор принимает аргументы. Непрямой стиль может выглядеть так:</p>

<pre><code>    # &#x41D;&#x415; &#x418;&#x421;&#x41F;&#x41E;&#x41B;&#x42C;&#x417;&#x41E;&#x412;&#x410;&#x422;&#x42C;
    my $obj = new Class( arg =&gt; $value );</code></pre>

<p>&hellip;таким образом заставляя имя класса выглядеть как вызов функции. Perl 5 <em>может</em> устранить неоднозначность во многих подобных случаях, но его эвристики зависят от того, какие имена пакетов видит парсер, какие голые слова он уже разрешил (и как он разрешил их) и от <em>имён</em> функций, уже объявленных в текущем пакете.</p>

<p>Представьте противоречие в случае прототипированной функции (<a href="chapter_11.html#prototypes">Прототипы</a>) с именем, которому случилось каким-то образом вступить в конфликт с именем класса или метода, вызываемого непрямо. Это случается редко, но так неприятно для отладки, что стоит того, чтобы избегать непрямых вызовов.</p>

<h3>Скалярные ограничения непрямой нотации</h3>

<p>Другая опасность такого синтаксиса в том, что парсер ожидает объект как одно скалярное выражение. Вывод в дескриптор файла, сохранённый в агрегатной переменной, <em>выглядит</em> очевидным, но таковым не является:</p>

<pre><code>    # &#x41D;&#x415; &#x420;&#x410;&#x411;&#x41E;&#x422;&#x410;&#x415;&#x422; &#x41A;&#x410;&#x41A; &#x41D;&#x410;&#x41F;&#x418;&#x421;&#x410;&#x41D;&#x41E;
    say $config-&gt;{output} &#39;Fun diagnostic message!&#39;;</code></pre>

<p>Perl попытается вызвать <code>say</code> на объекте <code>$config</code>.</p>

<p>  </p>

<p><code>print</code>, <code>close</code> и <code>say</code> &mdash; все встроенные функции, оперирующие с дескрипторами файлов &mdash; оперируют в непрямой манере. Это было нормально, когда дескрипторы файлов были глобальными переменными пакета, но лексические дескрипторы файлов (<a href="chapter_03.html#lexical_filehandles">Ссылки на дескрипторы файлов</a>) делают очевидными проблемы непрямого объектного синтаксиса. Чтобы устранить это, избавьтесь от неоднозначности подвыражения, выдающего подразумеваемый инвокант:</p>

<pre><code>    say <strong>{</strong>$config-&gt;{output}<strong>}</strong> &#39;Fun diagnostic message!&#39;;</code></pre>

<h3>Альтернативы непрямой нотации</h3>

<p>Нотация прямого вызова не страдает этой проблемой неоднозначности. Чтобы сконструировать объект, вызовите метод-конструктор напрямую на имени класса:</p>

<pre><code>    my $q   = CGI-&gt;new();
    my $obj = Class-&gt;new( arg =&gt; $value );</code></pre>

<p>Этот синтаксис <em>всё ещё</em> имеет проблему голого слова, в том смысле, что если у вас есть функция с именем <code>CGI</code>, Perl будет интерпретировать голое имя класса как вызов функции:</p>

<pre><code>    sub CGI;

    # &#x432;&#x44B; &#x43D;&#x430;&#x43F;&#x438;&#x441;&#x430;&#x43B;&#x438; CGI-&gt;new(), &#x43D;&#x43E; Perl &#x443;&#x432;&#x438;&#x434;&#x435;&#x43B;
    my $q = CGI()-&gt;new();</code></pre>

<p>Хотя это случается редко, вы можете устранить неоднозначность имён классов, добавив разделитель пакетов (<code>::</code>) или явно пометив имена классов как строковые литералы:</p>

<pre><code>    # &#x440;&#x430;&#x437;&#x434;&#x435;&#x43B;&#x438;&#x442;&#x435;&#x43B;&#x44C; &#x43F;&#x430;&#x43A;&#x435;&#x442;&#x43E;&#x432;
    my $q = CGI::-&gt;new();

    # &#x43D;&#x435; &#x438;&#x43C;&#x435;&#x44E;&#x449;&#x438;&#x439; &#x43D;&#x435;&#x43E;&#x434;&#x43D;&#x43E;&#x437;&#x43D;&#x430;&#x447;&#x43D;&#x43E;&#x441;&#x442;&#x438; &#x441;&#x442;&#x440;&#x43E;&#x43A;&#x43E;&#x432;&#x44B;&#x439; &#x43B;&#x438;&#x442;&#x435;&#x440;&#x430;&#x43B;
    my $q = &#39;CGI&#39;-&gt;new();</code></pre>

<p>Однако почти никто этого не делает.</p>

<p></p>

<p>Для ограниченного случая операций с дескрипторами файлов дательное использование настолько общепринято, что вы можете использовать подход непрямого вызова, если окружите свой подразумеваемый инвокант фигурными скобками. Если вы используете Perl 5.14 (или если вы загрузили <code>IO::File</code> или <code>IO::Handle</code>), вы можете использовать методы на лексических дескрипторах файлов (footnote: Хотя почти никто не делает этого для <code>print</code> и <code>say</code>.).</p>

<p>  </p>

<p>CPAN-модуль <code>Perl::Critic::Policy::Dynamic::NoIndirect</code> (плагин для <code>Perl::Critic</code>) может обнаружить непрямые вызовы во время проверки кода. CPAN-модуль <code>indirect</code> может обнаружить и запретить их использование в запущенных программах:</p>

<pre><code>    # &#x432;&#x44B;&#x434;&#x430;&#x442;&#x44C; &#x43F;&#x440;&#x435;&#x434;&#x443;&#x43F;&#x440;&#x435;&#x436;&#x434;&#x435;&#x43D;&#x438;&#x435; &#x43F;&#x440;&#x438; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x438; &#x43D;&#x435;&#x43F;&#x440;&#x44F;&#x43C;&#x44B;&#x445; &#x432;&#x44B;&#x437;&#x43E;&#x432;&#x43E;&#x432;
    no indirect;

    # &#x432;&#x44B;&#x431;&#x440;&#x43E;&#x441;&#x438;&#x442;&#x44C; &#x438;&#x441;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x438;&#x435; &#x43F;&#x440;&#x438; &#x438;&#x445; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x438;
    no indirect &#39;:fatal&#39;;</code></pre>

<h2>Прототипы</h2>

<p><a name="prototypes"></p>

<p></p>

<p><em>Прототип</em> &mdash; это набор необязательных метаданных, присоединённых к функции, которые влияют на то, как парсер понимает её аргументы. Хотя внешне они могут выглядеть как сигнатуры функций в других языках, на самом деле они очень отличаются.</p>

<p></p>

<p>Прототипы позволяют пользователям определять свои собственные функции, ведущие себя как встроенные. Рассмотрим встроенную фукнцию <code>push</code>, которая принимает массив и список. Хотя обычно Perl 5 разгладил бы массив и список в единый список, переданный в <code>push</code>, парсер знает, что не нужно разглаживать массив, чтобы <code>push</code> мог модифицировать его на месте.</p>

<p>Прототипы функций являются частью объявления:</p>

<pre><code>    sub foo        <strong>(&amp;@)</strong>;
    sub bar        <strong>($$)</strong> { ... }
    my  $baz = sub <strong>(&amp;&amp;)</strong> { ... };</code></pre>

<p>Любой прототип, привязанный к предварительному объявлению, должен совпадать с прототипом, привязанным к объявлению функции. Perl выдаст предупреждение, если это не так. Как ни странно, вы можете опустить прототип в предварительном объявлении и включить его в полное объявление &mdash; но делать так нет причин.</p>

<p></p>

<p>Встроенная функция <code>prototype</code> принимает имя функции и возвращает строку, представляющую её прототип. Используйте форму <code>CORE::</code>, чтобы увидеть прототип встроенной функции:</p>

<pre><code>    $ <strong>perl -E &quot;say prototype &#39;CORE::push&#39;;&quot;</strong>
    \@@
    $ <strong>perl -E &quot;say prototype &#39;CORE::keys&#39;;&quot;</strong>
    \%
    $ <strong>perl -E &quot;say prototype &#39;CORE::open&#39;;&quot;</strong>
    *;$@</code></pre>

<p><code>prototype</code> вернёт <code>undef</code> для тех встроенных функций, которые вы не можете эмулировать:</p>

<pre><code>    <strong>say prototype &#39;CORE::system&#39; // &#39;undef&#39;</strong>
    # undef; &#x43D;&#x435;&#x432;&#x43E;&#x437;&#x43C;&#x43E;&#x436;&#x43D;&#x43E; &#x44D;&#x43C;&#x443;&#x43B;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x442;&#x44C; &#x432;&#x441;&#x442;&#x440;&#x43E;&#x435;&#x43D;&#x43D;&#x443;&#x44E; &#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x44E; <code>system</code>

    <strong>say prototype &#39;CORE::prototype&#39; // &#39;undef&#39;</strong>
    # undef; &#x432;&#x441;&#x442;&#x440;&#x43E;&#x435;&#x43D;&#x43D;&#x430;&#x44F; &#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x44F; <code>prototype</code> &#x43D;&#x435; &#x438;&#x43C;&#x435;&#x435;&#x442; &#x43F;&#x440;&#x43E;&#x442;&#x43E;&#x442;&#x438;&#x43F;&#x430;</code></pre>

<p>Помните <code>push</code>?</p>

<pre><code>    $ <strong>perl -E &quot;say prototype &#39;CORE::push&#39;;&quot;</strong>
    \@@</code></pre>

<p>Символ <code>@</code> представляет список. Обратный слеш принуждает к использованию <em>ссылки</em> для соответствующего аргумента. Этот прототип обозначает, что <code>push</code> принимает ссылку на массив и список значений. Вы можете написать <code>mypush</code> так:</p>

<pre><code>    sub mypush (\@@)
    {
        my ($array, @rest) = @_;
        push @$array, @rest;
    }</code></pre>

<p>Другие символы прототипов включают <code>$</code> для скалярного аргумента, <code>%</code> для обозначения хеша (чаще всего используется как ссылка) и <code>&</code> для указания на блок кода. См. <code>perldoc perlsub</code> для полной документации.</p>

<h3>Проблемы с прототипами</h3>

<p>Прототипы изменяют то, как Perl парсит ваш код, и могут вызывать приведение типов аргументов. Они не документируют количество или типы аргументов, которые функция ожидает, как и не устанавливают соответствие аргументов именованным параметрам.</p>

<p>Приведение типов при использовании прототипов работает неочевидным образом, как навязывание скалярного контекста входным аргументам:</p>

<pre><code>    sub numeric_equality($$)
    {
        my ($left, $right) = @_;
        return $left == $right;
    }

    my @nums = 1 .. 10;

    say &#39;They&#39;re equal, whatever that means!&#39;
        if numeric_equality @nums, 10;</code></pre>

<p>&hellip;но работает только с простыми выражениями:</p>

<pre><code>    sub mypush(\@@);

    # &#x43E;&#x448;&#x438;&#x431;&#x43A;&#x430; &#x43A;&#x43E;&#x43C;&#x43F;&#x438;&#x43B;&#x44F;&#x446;&#x438;&#x438;: &#x43D;&#x435;&#x441;&#x43E;&#x43E;&#x442;&#x432;&#x435;&#x442;&#x441;&#x442;&#x432;&#x438;&#x435; &#x43F;&#x440;&#x43E;&#x442;&#x43E;&#x442;&#x438;&#x43F;&#x43E;&#x432;
    # (&#x43E;&#x436;&#x438;&#x434;&#x430;&#x43B;&#x441;&#x44F; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432;, &#x43F;&#x43E;&#x43B;&#x443;&#x447;&#x435;&#x43D;&#x43E; &#x441;&#x43A;&#x430;&#x43B;&#x44F;&#x440;&#x43D;&#x43E;&#x435; &#x43F;&#x440;&#x438;&#x441;&#x432;&#x430;&#x438;&#x432;&#x430;&#x43D;&#x438;&#x435;)
    mypush( my $elems = [], 1 .. 20 );</code></pre>

<p>Чтобы отладить это, пользователи <code>mypush</code> должны знать как то, что прототип существует, так и ограничения прототипов массивов. Хуже того, это <em>простые</em> ошибки, которые могут вызывать прототипы.</p>

<h3>Хорошее использование прототипов</h3>

<p>  </p>

<p>Немногие использования прототипов достаточно интересны, чтобы перевесить их недостатки, но они существуют.</p>

<p>Во-первых, они могут позволить вам переопределить встроенные функции. Сначала проверьте, что вы <em>можете</em> переопределить встроенную функцию, проверив её прототип в маленькой тестовой программе. Затем используйте прагму <code>subs</code>, чтобы сказать Perl, что вы собираетесь переопределить встроенную функцию, и, наконец, объявите ваше переопределение с корректным прототипом:</p>

<pre><code>    use subs &#39;push&#39;;

    sub push (\@@) { ... }</code></pre>

<p>Имейте ввиду, что прагма <code>subs</code> действует для всей оставшейся части <em>файла</em>, независимо от лексической области видимости.</p>

<p></p>

<p>Вторая причина использования прототипов &mdash; это определение констант времени компиляции. Когда Perl встречает функцию, объявленную с пустым прототипом (в противоположность <em>отсутствию</em> прототипа), <em>и</em> эта функция возвращает единственное константное выражение, оптимизатор превратит все вызовы этой функции в константы вместо вызовов функции:</p>

<pre><code>    sub PI () { 4 * atan2(1, 1) }</code></pre>

<p>Весь последующий код будет использовать вычисленное значение Пи на месте голого слова <code>PI</code> или вызова <code>PI()</code>, с учётом области видимости.</p>

<p>  </p>

<p>Базовая прагма <code>constant</code> справляется с этими деталями за вас. Модуль <code>Const::Fast</code> из CPAN создаёт константные скаляры, которые вы можете интерполировать в строки.</p>

<p> </p>

<p>Разумное использование прототипов &mdash; это расширение синтаксиса Perl 5 для оперирования анонимными функциями как блоками. CPAN-модуль <code>Test::Exception</code> использует это во благо для предоставления приятного API с отложенными вычислениями (footnote: См. также <code>Test::Fatal</code>). Его функция <code>throws_ok()</code> принимает три аргумента: блок кода для выполнения, регулярное выражение для сравнения со строкой исключения и необязательное описание теста:</p>

<pre><code>    use Test::More tests =&gt; 1;
    use Test::Exception;

    throws_ok
        { my $unobject; $unobject-&gt;yoink() }
        qr/Can&#39;t call method &quot;yoink&quot; on an undefined/,
        &#39;Method on undefined invocant should fail&#39;;</code></pre>

<p>Экспортируемая функция <code>throws_ok()</code> имеет протоип <code>&$;$</code>. Его первый аргумент &mdash; это блок, который становится анонимной функцией. Второй аргумент &mdash; скаляр. Третий аргумент не обязателен.</p>

<p>Внимательные читатели, возможно, заметили отсутствие запятой после блока. Это причуда парсера Perl 5, который ожидает после прототипированного блока пробел, а не оператор запятой. Это недостаток синтаксиса прототипов.</p>

<p>Вы можете использовать <code>throws_ok()</code>, не пользуясь прототипами:</p>

<pre><code>    use Test::More tests =&gt; 1;
    use Test::Exception;

    throws_ok<strong>(</strong>
        <strong>sub</strong> { my $unobject; $unobject-&gt;yoink() }<strong>,</strong>
        qr/Can&#39;t call method &quot;yoink&quot; on an undefined/,
        &#39;Method on undefined invocant should fail&#39; <strong>)</strong>;</code></pre>

<p></p>

<p>Последнее хорошее применение прототипов &mdash; при определении произвольной именованной функции для использования с <code>sort</code> (footnote: Бен Тилли (Ben Tilly) предложил этот пример.):</p>

<pre><code>    sub length_sort ($$)
    {
        my ($left, $right) = @_;
        return length($left) &lt;=&gt; length($right);
    }

    my @sorted = sort length_sort @unsorted;</code></pre>

<p>Прототип <code>$$</code> заставляет Perl передавать сортируемые пары в <code>@_</code>. Документация <code>sort</code> предполагает, что это немного медленнее, чем использование глобальных переменных пакета <code>$a</code> и <code>$b</code>, но использование лексических переменных зачастую оправдывает любое снижение скорости.</p>

<h2>Эквивалентность методов и функций</h2>

<p><a name="method_sub_equivalence"></p>

<p></p>

<p>Объектная система Perl 5 преднамеренно минималистична (<a href="chapter_07.html#blessed_references">Благословлённые ссылки</a>). Так как класс является пакетом, Perl не делает различий между функцией и методом, хранящимися в пакете. Одна и та же встроенная директива, <code>sub</code>, объявляет и одно, и другое. Документация может прояснить ваши намерения, но Perl охотно диспетчеризует функцию, вызванную как метод. Подобным же образом вы можете вызвать метод как если бы он был функцией &mdash; полностью определённой, экспортированной или ссылкой &mdash; если вручную передадите свой инвокант.</p>

<p>Вызов не того, что нужно, не так, как нужно, вызывает проблемы.</p>

<h3>Вызывающая сторона</h3>

<p>Рассмотрим класс с несколькими методами:</p>

<pre><code>    package Order;

    use List::Util &#39;sum&#39;;

    ...

    sub calculate_price
    {
        my $self = shift;
        return sum( 0, $self-&gt;get_items() );
    }</code></pre>

<p>Если есть объект <code>$o</code> класса <code>Order</code>, следующие вызовы этого метода <em>могут</em> выглядеть эквивалентными:</p>

<pre><code>    my $price = $o-&gt;calculate_price();

    # &#x441;&#x43B;&#x43E;&#x43C;&#x430;&#x43D;&#x43E;; &#x43D;&#x435; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x442;&#x44C;
    my $price = Order::calculate_price( $o );</code></pre>

<p>Хотя в этом простом случае они дадут один и тот же вывод, последнее нарушает инкапсуляцию объекта, избегая поиска метода.</p>

<p></p>

<p>Если же <code>$0</code> был бы подклассом или алломорфом (<a href="chapter_07.html#roles">Роли</a>) класса <code>Order</code>, который переопределял бы <code>calculate_price()</code>, обход диспетчеризации метода привёл бы к вызову неверного метода. Любое изменение реализации <code>calculate_price()</code>, такое как модификация наследования или делегирования через <code>AUTOLOAD()</code> &mdash; могло бы сломать вызывающий код.</p>

<p>  </p>

<p>В Perl есть одно обстоятельство, где это поведение может выглядеть необходимым. Если вы форсируете разрешение метода без диспетчеризации, как вы вызовете результирующую ссылку на метод?</p>

<pre><code>    my $meth_ref = $o-&gt;can( &#39;apply_discount&#39; );</code></pre>

<p>Здесь есть две возможности. Первая &mdash; отбросить возвращаемое значение метода <code>can()</code>:</p>

<pre><code>    $o-&gt;apply_discount() if $o-&gt;can( &#39;apply_discount&#39; );</code></pre>

<p>Вторая &mdash; использовать саму ссылку посредством синтаксиса вызова метода:</p>

<pre><code>    if (my $meth_ref = $o-&gt;can( &#39;apply_discount&#39; ))
    {
        $o-&gt;$meth_ref();
    }</code></pre>

<p>Если <code>$meth_ref</code> содержит ссылку на функцию, Perl вызовет эту ссылку с <code>$o</code> в качестве инвоканта. Это работает даже со включенным <code>strict</code>, как и при вызове метода с помощью скаляра, содержащего его имя:</p>

<pre><code>    my $name = &#39;apply_discount&#39;;
    $o-&gt;$name();</code></pre>

<p>Есть один небольшой недостаток в вызове метода по ссылке; если структура программы изменяется между сохранением ссылки и вызовом по ссылке, ссылка может уже не ссылаться на наиболее соответствующий метод. Если класс <code>Order</code> был изменён так, что <code>Order::apply_discount</code> уже не является правильным методом для вызова, ссылка в <code>$meth_ref</code> не будет обновлена.</p>

<p>Когда вы используете эту форму вызова, ограничьте область видимости ссылки.</p>

<h3>Вызываемая сторона</h3>

<p> </p>

<p>Так как Perl 5 не делает различий между функциями и методами в точке объявления, и так как <em>возможно</em> (хотя и не рекомендуется) вызвать заданную функцию как функцию или метод, возможно написать функцию, которую можно вызывать любым из этих способов. Базовый модуль <code>CGI</code> &mdash; главный обвиняемый. Его функции применяют несколько эвристик для определения того, является ли их первый аргумент инвокантом.</p>

<p>Недостатков этого множество. Трудно точно предсказать, какой инвокант потенциально валиден для заданного метода, особенно если вам приходится иметь дело с подклассами. Также труднее создать API, который пользователи не смогут с лёгкостью неправильно использовать, как и бремя документации становится тяжелее. Что случится, если одна часть проекта использует процедурный интерфейс, а другая &mdash; объектный?</p>

<p>Если вам <em>необходимо</em> предоставить отдельный процедурный и ОО интерфейс к библиотеке, создайте два отдельных API.</p>

<h2>Связывание</h2>

<p><a name="tie"></p>

<p>Тогда как перегрузка (<a href="chapter_09.html#overloading">Перегрузка</a>) позволяет вам настраивать поведение классов и объектов для конкретных случаев приведения типа, механизм, называемый <em>связыванием</em>, позволяет вам настраивать поведение простых переменных (скаляров, массивов, хешей и дескрипторов файлов). Любая операция, которую вы можете выполнить на связанной переменной, транслируется в определённый вызов метода.</p>

<p> </p>

<p>Встроенная директива <code>tie</code> изначально позволяла вам использовать место на диске как резервную память для хешей, так что Perl мог осуществлять доступ к файлам, которые больше, чем можно поместить в память. Базовый модуль <code>Tie::File</code> предоставляет похожую систему и позволяет вам обращаться с файлами как если бы они были массивами.</p>

<p>  </p>

<p>Класс, с которым вы связываете переменную с помощью <code>tie()</code>, должен соотвествовать определённому интерфейсу для конкретных типов данных. Смотрите <code>perldoc perltie</code> для получения общего представления, затем обратитесь к базовым модулям <code>Tie::StdScalar</code>, <code>Tie::StdArray</code> и <code>Tie::StdHash</code> за более конкретными деталями. Начните с наследования от одного из этих классов, затем переопределите любые конкретные методы, которые вам нужно модифицировать.</p>

<p>Как будто бы <code>tie</code> уже не достаточно сбивающий с толку, <code>Tie::Scalar</code>, <code>Tie::Array</code> и <code>Tie::Hash</code> определяют необходимые интерфейсы для связывания скаляров, массивов и хешей, но реализацию по умолчанию предоставляют <code>Tie::StdScalar</code>, <code>Tie::StdArray</code> и <code>Tie::StdHash</code>.</p>

<h3>Связывание переменных</h3>

<p>Так можно связать переменную:</p>

<pre><code>    use Tie::File;
    tie my @file, &#39;Tie::File&#39;, @args;</code></pre>

<p>Первый аргумент &mdash; это переменная для связывания, второй &mdash; имя класса, с которым её нужно связать, а <code>@args</code> &mdash; необязательный список аргументов, требуемый для связывающей функции. В случае <code>Tie::File</code> это допустимое имя файла.</p>

<p> </p>

<p>Связывающие функции напоминают конструкторы: <code>TIESCALAR</code>, <code>TIEARRAY()</code>, <code>TIEHASH()</code> или <code>TIEHANDLE()</code> для скаляров, массивов, хешей и дескрипторов файлов соответственно. Каждая функция возвращает новый объект, представляющий связанную переменную. Обе встроенные директивы, <code>tie</code> и <code>tied</code>, возвращают этот объект. Однако, большинство использует <code>tied</code> в булевом контексте.</p>

<h3>Реализация связанных переменных</h3>

<p>Чтобы реализовать класс связанных переменных, унаследуйте от встроенного модуля, такого как <code>Tie::StdScalar</code> (footnote: У <code>Tie::StdScalar</code> отсутствует собственный файл <em>.pm</em>, так что используйте <code>Tie::Scalar</code>, чтобы сделать его доступным.), затем переопределите конкретные методы для операций, которые вы хотите изменить. В случае связанного скаляра это, скорее всего, будут <code>FETCH</code> и <code>STORE</code>, возможно, <code>TIESCALAR()</code>, и, вероятно, не <code>DESTROY()</code>.</p>

<p>Вы можете создать класс, который логирует все операции чтения и записи скаляра, с помощью очень небольшого количества кода:</p>

<pre><code>    package Tie::Scalar::Logged
    {
        use Modern::Perl;

        use Tie::Scalar;
        use parent -norequire =&gt; &#39;Tie::StdScalar&#39;;

        sub STORE
        {
            my ($self, $value) = @_;
            Logger-&gt;log(&quot;Storing &lt;$value&gt; (was [$$self])&quot;, 1);
            $$self = $value;
        }

        sub FETCH
        {
            my $self = shift;
            Logger-&gt;log(&quot;Retrieving &lt;$$self&gt;&quot;, 1);
            return $$self;
        }
    }

    1;</code></pre>

<p>Допустим, метод <code>log()</code> класса <code>Logger</code> принимает строку и количество фреймов вверх по стеку вызовов, которые нужно вывести.</p>

<p>Внутри методов <code>STORE()</code> и <code>FETCH()</code>, <code>$self</code> работает как благословлённый скаляр. Присваивание этой ссылке на скаляр изменяет значение скаляра, а чтение из неё возвращает его значение.</p>

<p>Аналогично, методы <code>Tie::StdArray</code> и <code>Tie::StdHash</code> воздействуют на благословлённые ссылки на массив и хеш сооветственно. Документация в <code>perldoc perltie</code> объясняет обширное количество методов, которые они поддерживают, как например, вы можете читать или записывать множественные значения в них, помимо других операций.</p>

<p>Опция <code>-norequire</code> предотвращает прагму <code>parent</code> от попытки загрузить файл для <code>Tie::StdScalar</code>, поскольку этот модуль является частью файла <em>Tie/Scalar.pm</em>.</p>

<h3>Когда использовать связанные переменные?</h3>

<p>Связанные переменные выглядять как весёлые возможности для проявления ума, но они могут приводить к сбивающим с толку интерфейсам. Если у вас нет очень хорошей причины для того, чтобы заставлять объект вести себя так, как если бы он был встроенным типом данных, избегайте создания собственных связываний. К тому же, <code>tie</code> намного медленнее, чем использование встроенных типов данных, ввиду различных причин, кроющихся в реализации.</p>

<p>Хорошие причины включают облегчение отладки (используйте логгируемый скаляр, чтобы понять, где изменяется значение) и необходимость сделать некоторые невозможные операции возможными (доступ к большим файлам способом с эффективным использованием памяти). Связанные переменнные менее полезны как первичные интерфейсы к объектам; зачастую слишком трудно и ограничивающе пытаться вместить весь ваш интерфейс в тот, что поддерживается <code>tie()</code>.</p>

<p>Последнее слово предупреждения одновременно печально и убедительно; слишком много кода сбивается со своего пути, чтобы <em>предотвратить</em> использование связанных переменных, зачастую по случайности. Это неудачно, но нарушение ожиданий библиотечного кода склонно к раскрытию багов, исправить которые зачастую не в ваших силах.</p>

</body></html>