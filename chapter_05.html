<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="style.css" type="text/css"></head><body><h1>Функции</h1>

<p> </p>

<p><em>Функция</em> (или <em>подпрограмма</em>) в Perl &mdash; это обособленная, инкапсулированная единица поведения. Программа &mdash; это набор маленьких чёрных ящиков, в котором взаимодействие функций руководит потоком управления. Функция может иметь имя. Она может потреблять входную информацию. Она может генерировать выходную информацию.</p>

<p>Функции &mdash; первичный механизм абстракции, инкапсуляции и повторного использования в Perl 5.</p>

<h2>Объявление функций</h2>

<p><a name="functions"></p>

<p> </p>

<p>Используйте встроенную директиву <code>sub</code> для объявления функции:</p>

<pre><code>    <strong>sub</strong> greet_me  { ... }</code></pre>

<p>Теперь функция <code>greet_me()</code> доступна для вызова в любом месте программы.</p>

<p></p>

<p>Вы не обязаны <em>определять</em> функцию в той точке, в которой вы её объявляете. <em>Предварительное объявление</em> указывает Perl запомнить имя функции, несмотря на то, что вы объявите её позже:</p>

<pre><code>    sub greet_sun;</code></pre>

<h2>Вызов функций</h2>

<p></p>

<p>Используйте постфиксные (<a href="chapter_04.html#fixity">Фиксность</a>) круглые скобки и имя функции для вызова этой функции и передачи необязательного списка аргументов:</p>

<pre><code>    greet_me( &#39;Jack&#39;, &#39;Brad&#39; );
    greet_me( &#39;Snowy&#39; );
    greet_me();</code></pre>

<p>Хотя эти скобки не являются строго обязательными для этих примеров &mdash; даже с включенной прагмой <code>strict</code> &mdash; они обеспечивают ясность для читателей и парсера Perl. Если есть сомнения, используйте их.</p>

<p>Аргументы функций могут быть произвольными выражениями, включая простые переменные:</p>

<pre><code>    greet_me( $name );
    greet_me( @authors );
    greet_me( %editors );</code></pre>

<p>&hellip;хотя стандартная обработка параметров в Perl 5 иногда удивляет новичков.</p>

<h2>Параметры функций</h2>

<p><a name="function_parameters"></p>

<p>   </p>

<p>Функция получает свои параметры в едином массиве, <code>@_</code> (<a href="chapter_01.html#default_array_variables">Подразумеваемая переменная-массив</a>). Perl <em>разглаживает</em> все входные параметры в единый список. Функция должна либо распаковать все параметры в переменные, или работать с <code>@_</code> напрямую:</p>

<pre><code>    sub greet_one
    {
        <strong>my ($name) = @_</strong>;
        say &quot;Hello, $name!&quot;;
    }

    sub greet_all
    {
        say &quot;Hello, <strong>$_!&quot; for @_</strong>;
    }</code></pre>

<p>Большая часть кода использует <code>shift</code> или распаковку списка, однако <code>@_</code> ведёт себя как обычный массив, так что вы можете ссылаться на отдельные элементы по индексу:</p>

<pre><code>    sub greet_one_shift
    {
        <strong>my $name = shift</strong>;
        say &quot;Hello, $name!&quot;;
    }

    sub greet_two_no_shift
    {
        my ($hero, $sidekick) = @_;
        say &quot;Well if it isn&#39;t $hero and $sidekick. Welcome!&quot;;
    }

    sub greet_one_indexed
    {
        <strong>my $name = $_[0]</strong>;
        say &quot;Hello, $name!&quot;;

        # or, less clear
        say &quot;Hello, $_[0]!&quot;;
    }</code></pre>

<p>&hellip; или использовать <code>shift</code>, <code>unshift</code>, <code>push</code>, <code>pop</code>, <code>splice</code> и <code>slice</code> с @_.</p>

<p>Вспомните, что встроенные функции работы с массивами используют <code>@_</code> как операнд по умолчанию <em>внутри функций</em>. Пользуйтесь этой идиомой.</p>

<p>Присваивание скалярного параметра из <code>@_</code> требует использования <code>shift</code>, доступа по индексу к <code>@_</code> или скобок списочного контекста в левом значении. В противном случае, Perl 5 с удовольствием вычислит для вас <code>@_</code> в скалярном контексте и присвоит количество переданных параметров:</p>

<pre><code>    sub bad_greet_one
    {
        <strong>my $name = @_</strong>;  # &#x431;&#x430;&#x436;&#x43D;&#x43E;
        say &quot;Hello, $name; you look numeric today!&quot;
    }</code></pre>

<p>Списочное присваивание нескольких параметров зачастую яснее, чем несколько строчек <code>shift</code>. Сравните:</p>

<pre><code>    sub calculate_value
    {
        # &#x43D;&#x435;&#x441;&#x43A;&#x43E;&#x43B;&#x44C;&#x43A;&#x43E; &#x432;&#x44B;&#x437;&#x43E;&#x432;&#x43E;&#x432; shift
        my $left_value  = shift;
        my $operation   = shift;
        my $right_value = shift;
        ...
    }</code></pre>

<p>&hellip;и:</p>

<pre><code>    sub calculate_value
    {
        <strong>my ($left_value, $operation, $right_value) = @_;</strong>
        ...
    }</code></pre>

<p>Иногда требуется извлечь несколько параметров из <code>@_</code>, а остальные передать в другую функцию:</p>

<pre><code>    sub delegated_method
    {
        my $self = <strong>shift</strong>;
        say &#39;Calling delegated_method()&#39;

        $self-&gt;delegate-&gt;delegated_method( <strong>@_</strong> );
    }</code></pre>

<p>Используйте <code>shift</code>, если ваша функция требует только одного параметра. Используйте списочное присваивание для доступа к нескольким параметрам.</p>

<p>   </p>

<p>Несколько дистрибутивов из CPAN расширяют обработку параметров в Perl 5 дополнительным синтаксисом и опциями. <code>signatures</code> и <code>Method::Signatures</code> очень мощны. <code>Method::Signatures::Simple</code> &mdash; прост, но удобен. <code>MooseX::Method::Signatures</code> отлично работает с Moose (<a href="chapter_07.html#moose">Moose</a>).</p>

<h3>Разглаживание</h3>

<p>Разглаживание параметров в <code>@_</code> происходит на стороне вызывающего кода вызова функции. Передача хеша в качестве аргумента генерирует список пар ключ/значение:</p>

<pre><code>    my %pet_names_and_types = (
        Lucky   =&gt; &#39;dog&#39;,
        Rodney  =&gt; &#39;dog&#39;,
        Tuxedo  =&gt; &#39;cat&#39;,
        Petunia =&gt; &#39;cat&#39;,
    );

    show_pets( %pet_names_and_types );

    sub show_pets
    {
        my %pets = @_;
        while (my ($name, $type) = each %pets)
        {
            say &quot;$name is a $type&quot;;
        }
    }</code></pre>

<p>Когда Perl разглаживает <code>%pet_names_and_types</code> в список, порядок пар ключ/значение из хеша будет различаться, но список всегда будет включать значение, следующее сразу за своим ключом. Присваивание хеша внутри <code>show_pets()</code> работает по существу также, как более явное присваивание <code>%pet_names_and_types</code>.</p>

<p>Разглаживание часто полезно, но остерегайтесь смешивать в списке параметров скаляры с разглаживаемыми агрегатными переменными. При написании функции <code>show_pets_of_type()</code>, в которой один параметр &mdash; это тип животного для вывода, передавайте этот тип как <em>первый</em> аргумент (или используйте <code>pop</code> для удаления его из конца <code>@_</code>):</p>

<pre><code>    sub show_pets_by_type
    {
        <strong>my ($type, %pets) = @_</strong>;

        while (my ($name, $species) = each %pets)
        {
            <strong>next unless $species eq $type;</strong>
            say &quot;$name is a $species&quot;;
        }
    }

    my %pet_names_and_types = (
        Lucky   =&gt; &#39;dog&#39;,
        Rodney  =&gt; &#39;dog&#39;,
        Tuxedo  =&gt; &#39;cat&#39;,
        Petunia =&gt; &#39;cat&#39;,
    );

    show_pets_by_type( &#39;dog&#39;,   %pet_names_and_types );
    show_pets_by_type( &#39;cat&#39;,   %pet_names_and_types );
    show_pets_by_type( &#39;moose&#39;, %pet_names_and_types );</code></pre>

<h3>Проглатывание</h3>

<p><a name="parameter_slurping"> </p>

<p>Списочное присваивание агрегатной переменной всегда проявляет жадность, поэтому присваивание <code>%pets</code> <em>проглатывает</em> все оставшиеся значения из <code>@_</code>. Если параметр <code>$type</code> находится в конце <code>@_</code>, Perl предупредит о присваивании нечётного числа элементов хешу. Вы <em>можете</em> обойти это:</p>

<pre><code>    sub show_pets_by_type
    {
        <strong>my $type = pop;</strong>
        <strong>my %pets = @_;</strong>

        ...
    }</code></pre>

<p>&hellip;ценой ясности. Тот же самый принцип, конечно же, применим к присваиванию массиву как параметру. Используйте ссылки (<a href="chapter_03.html#references">Ссылки</a>) чтобы избежать нежелательного разглаживания и проглатывания агрегатных значений.</p>

<h3>Создание псевдонимов</h3>

<p> </p>

<p><code>@_</code> имеет тонкость; он <em>создаёт псевдонимы</em> для аргументов функции, так что вы можете модифицировать их напрямую. Например:</p>

<pre><code>    sub modify_name
    {
        $_[0] = reverse $_[0];
    }

    my $name = &#39;Orange&#39;;
    modify_name( $name );
    say $name;

    # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; <code>egnarO</code></code></pre>

<p>Модифицируйте элемент <code>@_</code> напрямую, и вы модифицируете исходный параметр. Будьте осторожны, и тщательно распаковывайте <code>@_</code>.</p>

<h2>Функции и пространства имён</h2>

<p>Каждая функция содержится в некотором пространстве имён (<a href="chapter_03.html#packages">Пакеты</a>). Функции в необъявленном пространстве имён &mdash; функции, объявление которых не расположено после явной директивы <code>package</code> &mdash; находятся в пространстве имён <code>main</code>. Кроме того, вы можете объявить функцию в другом пространстве имён, добавив префикс к её имени:</p>

<pre><code>    sub <strong>Extensions::Math::</strong>add {
        ...
    }</code></pre>

<p>Это объявит функцию и создаст необходимое пространство имён. Помните, что пакеты в Perl 5 открыты для изменений в любой точке. Вы можете объявить только одну функцию с определённым именем в одном пространстве имён. В противном случае Perl 5 выдаст предупреждение о переопределении функции. Отключите эти предупреждения с помощью <code>no warnings 'redefine'</code> &mdash; если точно уверены, что это именно то, что вам нужно.</p>

<p>Вызов функций в других пространствах имён осуществляется с помощью их полностью определённых имён:</p>

<pre><code>    package main;

    Extensions::Math::add( $scalar, $vector );</code></pre>

<p>Функции в пространствах имён <em>видимы</em> снаружи этих пространств имён по их полностью определённым именам. Внутри пространства имён вы можете использовать короткие имена для доступа к любой функции, объявленной в этом пространстве имён. Также вы можете импортировать имена из других пространств имён.</p>

<h3>Импорт</h3>

<p><a name="importing"></p>

<p> </p>

<p>При загрузке модуля с помощью встроенной директивы <code>use</code> (<a href="chapter_09.html#modules">Модули</a>), Perl автоматически вызывает метод <code>import()</code> этого модуля. Модули могут предоставлять свои собственные методы <code>import()</code>, делающие некоторые или все определённые символы доступными в вызывающем пакете. Любые аргументы после имени модуля в директиве <code>use</code> будут переданы в метод <code>import()</code> модуля. Так:</p>

<pre><code>    use strict;</code></pre>

<p>&hellip;загружает модуль <em>strict.pm</em> и вызывает <code>strict->import()</code> без аргументов, тогда как:</p>

<pre><code>    use strict &#39;refs&#39;;
    use strict qw( subs vars );</code></pre>

<p>&hellip;загружает модуль <em>strict.pm</em>, вызывает <code>strict->import( 'refs' )</code>, а затем вызывает <code>strict->import( 'subs', vars' )</code>.</p>

<p><code>use</code> имеет специальное поведение по отношению к <code>import()</code>, но вы можете вызвать <code>import()</code> и напрямую. Пример использования <code>use</code> эквивалентен следующему:</p>

<pre><code>    BEGIN
    {
        require strict;
        strict-&gt;import( &#39;refs&#39; );
        strict-&gt;import( qw( subs vars ) );
    }</code></pre>

<p>Встроенная директива <code>use</code> добавляет неявный блок <code>BEGIN</code> вокруг этих выражений, так что вызов <code>import()</code> происходит <em>сразу</em> после того, как парсер скомпилирует всю директиву <code>use</code>. Это гарантирует, что любые импортируемые символы будут видимы при компиляции остальной части программы. В противном случае любые функции, <em>импортированные</em> из других модулей, но не <em>объявленные</em> в текущем файле, будут выглядеть как голые слова, тем самым нарушая режим <code>strict</code>.</p>

<h2>Оповещение об ошибках</h2>

<p><a name="reporting_errors"> </p>

<p>Внутри функции проверить контекст её вызова можно с помощью встроенной функции <code>caller</code>. Если не передано никаких аргументов, она возвращает список из трёх элементов, содержащий имя вызывающего пакета, имя файла, содержащего вызов, и номер строки файла, на которой произошёл вызов:</p>

<pre><code>    package main;

    main();

    sub main
    {
        show_call_information();
    }

    sub show_call_information
    {
        my ($package, $file, $line) = caller();
        say &quot;Called from $package in $file:$line&quot;;
    }</code></pre>

<p>Для инспектирования доступна полная цепочка вызовов. Передайте единственный целочисленный аргумент <em>n</em> в <code>caller()</code> чтобы просмотреть вызов вызова вызова <em>n</em> раз. Другими словами, если бы <code>show_call_information()</code> использовала <code>caller(0)</code>, то получила бы информацию о вызове из <code>main()</code>. Если же она использовала бы <code>caller(1)</code>, то получила бы информацию о вызове из начала программы.</p>

<p>Этот необязательный аргумент также требует от <code>caller</code> предоставить дополнительные возвращаемые значения, включая имя функции и контекст вызова:</p>

<pre><code>    sub show_call_information
    {
        my ($package, $file, $line<strong>, $func</strong>) = caller(<strong>0</strong>);
        say &quot;Called <strong>$func</strong> from $package in $file:$line&quot;;
    }</code></pre>

<p>  </p>

<p>Стандартный модуль <code>Carp</code> успешно использует эту технику для оповещения об ошибках и выбрасывания предупреждений в функциях. При использовании вместо <code>die</code> в коде библиотеки, <code>croak()</code> выбрасывает исключение с точки зрения своего вызывающего кода. <code>carp()</code> сообщает о предупреждении из файла, сообщая номер строки своего вызывающего кода (<a href="chapter_09.html#producing_warnings">Генерация предупреждений</a>).</p>

<p>Это поведение наиболее полезно при валидации параметров и предварительных условий фукнций, для указания того, что вызывающий код в чём-то неверен.</p>

<h3>Валидация аргументов</h3>

<p>Хотя Perl старается как может делать то, что имеет ввиду программист, он предоставляет немного нативных способов проверки валидности аргументов, передаваемых в функции. Для определения того, что <em>количество</em> параметров, переданных в функцию, корректно, вычислите <code>@_</code> в скалярном контексте:</p>

<pre><code>    sub add_numbers
    {
        croak &#39;Expected two numbers, received: &#39; . @_
            unless @_ == 2;

        ...
    }</code></pre>

<p></p>

<p>Проверка типа более трудна из-за свойственного Perl оператор-ориентированного преобразования типов (<a href="chapter_01.html#context_philosophy">Контекст</a>). Модуль <code>Params::Validate</code> из CPAN предлагает больше точности.</p>

<h2>Продвинутые функции</h2>

<p>Функции &mdash; фундамент многих продвинутых возможностей Perl.</p>

<h3>Учёт контекста</h3>

<p>  </p>

<p>Встроенные функции Perl 5 знает, вызвали ли вы их в пустом, скалярном или списочном контексте. Как могут и ваши функции. Неудачно названная (footnote: См. <code>perldoc -f wantarray</code> для подтверждения.) директива <code>wantarray</code> возвращает <code>undef</code> для обозначения пустого контекста, ложное значение для обозначения скалярного контекста и истинное значение для обозначения списочного контекста.</p>

<pre><code>    sub context_sensitive
    {
        my $context = wantarray();

        return qw( List context )   if         $context;
        say    &#39;Void context&#39;   unless defined $context;
        return &#39;Scalar context&#39; unless         $context;
    }

    context_sensitive();
    say my $scalar = context_sensitive();
    say context_sensitive();</code></pre>

<p>Это может быть полезно для функций, которые могут производить дорогие возвращаемые значения, чтобы избежать этого в пустом контексте. Некоторые идиоматические функции возвращают список в списочном контексте и первый элемент списка или ссылку на массив в скалярном контексте. Но помните, что для использования <code>wantarray</code> не существует единых наилучших рекомендаций. Иногда понятнее будет написать отдельные однозначные функции.</p>

<p> </p>

<p>Дистрибутивы <code>Want</code> Робина Хьюстона (Robin Houston) и <code>Contextual::Return</code> Демиена Конвея (Damian Conway) из CPAN предлагают множество возможностей для написания мощных и практичных интерфейсов, учитывающих контекст.</p>

<h3>Рекурсия</h3>

<p><a name="recursion">   </p>

<p>Предположим, вы хотите найти элемент в отсортированном массиве. Вы <em>можете</em> в поисках цели обойти в цикле каждый элемент массива отдельно, но в среднем вам придётся проверить половину элементов в массиве. Другой подход &mdash; разделить массив пополам, выбрать элемент посередине, сравнить, затем повторить либо с нижней, либо с верхней половиной. Разделяй и властвуй. Когда закончатся элементы для проверки или будет найден искомый, остановитесь.</p>

<p>Автоматизированный тест для этой техники может быть таким:</p>

<pre><code>    use Test::More;

    my @elements =
    (
        1, 5, 6, 19, 48, 77, 997, 1025, 7777, 8192, 9999
    );

    ok   elem_exists(     1, @elements ),
            &#39;found first element in array&#39;;
    ok   elem_exists(  9999, @elements ),
             &#39;found last element in array&#39;;
    ok ! elem_exists(   998, @elements ),
            &#39;did not find element not in array&#39;;
    ok ! elem_exists(    -1, @elements ),
            &#39;did not find element not in array&#39;;
    ok ! elem_exists( 10000, @elements ),
            &#39;did not find element not in array&#39;;

    ok   elem_exists(    77, @elements ),
            &#39;found midpoint element&#39;;
    ok   elem_exists(    48, @elements ),
            &#39;found end of lower half element&#39;;
    ok   elem_exists(   997, @elements ),
            &#39;found start of upper half element&#39;;

    done_testing();</code></pre>

<p>Рекурсия &mdash; обманчиво простое понятие. Каждый вызов функции в Perl создаёт новый <em>фрейм вызова</em>, внутреннюю структуру данных, представляющую сам вызов, включая лексическое окружение текущего вызова функции. Это значит, что функция может вызвать сама себя, <em>рекурсивно</em>.</p>

<p>Чтобы добиться прохождения предыдущего теста, напишите функцию под названием <code>elem_exists()</code>, которая знает, как вызывать себя, каждый раз деля список пополам:</p>

<pre><code>    sub elem_exists
    {
        my ($item, @array) = @_;

        # &#x43F;&#x440;&#x435;&#x440;&#x432;&#x430;&#x442;&#x44C; &#x440;&#x435;&#x43A;&#x443;&#x440;&#x441;&#x438;&#x44E;, &#x435;&#x441;&#x43B;&#x438; &#x43D;&#x435; &#x43E;&#x441;&#x442;&#x430;&#x43B;&#x43E;&#x441;&#x44C; &#x44D;&#x43B;&#x435;&#x43C;&#x435;&#x43D;&#x442;&#x43E;&#x432; &#x434;&#x43B;&#x44F; &#x43F;&#x43E;&#x438;&#x441;&#x43A;&#x430;
        return unless @array;

        # &#x441;&#x43C;&#x435;&#x449;&#x430;&#x435;&#x43C;&#x441;&#x44F; &#x432;&#x43D;&#x438;&#x437; &#x43F;&#x440;&#x438; &#x43D;&#x435;&#x447;&#x451;&#x442;&#x43D;&#x43E;&#x43C; &#x43A;&#x43E;&#x43B;&#x438;&#x447;&#x435;&#x441;&#x442;&#x432;&#x435; &#x44D;&#x43B;&#x435;&#x43C;&#x435;&#x43D;&#x442;&#x43E;&#x432;
        my $midpoint = int( (@array / 2) - 0.5 );
        my $miditem  = $array[ $midpoint ];

        # &#x432;&#x43E;&#x437;&#x432;&#x440;&#x430;&#x449;&#x430;&#x435;&#x43C; &#x438;&#x441;&#x442;&#x438;&#x43D;&#x443; &#x435;&#x441;&#x43B;&#x438; &#x44D;&#x43B;&#x435;&#x43C;&#x435;&#x43D;&#x442; &#x43D;&#x430;&#x439;&#x434;&#x435;&#x43D;
        return 1 if $item  == $miditem;

        # &#x432;&#x43E;&#x437;&#x432;&#x440;&#x430;&#x449;&#x430;&#x435;&#x43C; &#x43B;&#x43E;&#x436;&#x44C;, &#x435;&#x441;&#x43B;&#x438; &#x43E;&#x441;&#x442;&#x430;&#x43B;&#x441;&#x44F; &#x442;&#x43E;&#x43B;&#x44C;&#x43A;&#x43E; &#x43E;&#x434;&#x438;&#x43D; &#x44D;&#x43B;&#x435;&#x43C;&#x435;&#x43D;&#x442;
        return   if @array == 1;

        # &#x440;&#x430;&#x437;&#x431;&#x438;&#x432;&#x430;&#x435;&#x43C; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432; &#x43D;&#x430;&#x434;&#x432;&#x43E;&#x435; &#x438; &#x43F;&#x440;&#x43E;&#x434;&#x43E;&#x43B;&#x436;&#x430;&#x435;&#x43C; &#x440;&#x435;&#x43A;&#x443;&#x440;&#x441;&#x438;&#x432;&#x43D;&#x43E;
        return <strong>elem_exists</strong>(
            $item, @array[0 .. $midpoint]
        ) if $item &lt; $miditem;

        # &#x440;&#x430;&#x437;&#x431;&#x438;&#x432;&#x430;&#x435;&#x43C; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432; &#x43D;&#x430;&#x434;&#x432;&#x43E;&#x435; &#x438; &#x43F;&#x440;&#x43E;&#x434;&#x43E;&#x43B;&#x436;&#x430;&#x435;&#x43C; &#x440;&#x435;&#x43A;&#x443;&#x440;&#x441;&#x438;&#x432;&#x43D;&#x43E;
        return <strong>elem_exists</strong>(
             $item, @array[ $midpoint + 1 .. $#array ]
        );
    }</code></pre>

<p>Хотя вы <em>можете</em> написать этот код в процедурном виде и самостоятельно управлять делением списка, этот рекурсивный подход позволяет Perl управлять процессом.</p>

<h3>Лексические переменные</h3>

<p>Каждый новый вызов функции создаёт собственный <em>экземпляр</em> лексической области видимости. Даже несмотря на то, что объявление <code>elem_exists()</code> создаёт единственную область видимости для лексических переменных <code>$item</code>, <code>@array</code>, <code>$midpoint</code> и <code>$miditem</code>, каждый <em>вызов</em> <code>elem_exists()</code> &mdash; даже рекурсивный &mdash; сохраняет значения этих лексических переменных отдельно.</p>

<p><code>elem_exists()</code> не только может вызывать саму себя, но и лексические переменные каждого вызова будут защищены и разделены:</p>

<pre><code>    <strong>use Carp &#39;cluck&#39;;</strong>

    sub elem_exists
    {
        my ($item, @array) = @_;

        <strong>cluck &quot;[$item] (@array)&quot;;</strong>

        # &#x434;&#x430;&#x43B;&#x435;&#x435; &#x441;&#x43B;&#x435;&#x434;&#x443;&#x435;&#x442; &#x434;&#x440;&#x443;&#x433;&#x43E;&#x439; &#x43A;&#x43E;&#x434;
        ...
    }</code></pre>

<h3>Хвостовые вызовы</h3>

<p><a name="tail_calls"> </p>

<p>Один из <em>недостатков</em> рекурсии &mdash; то, что вы должны корректно указать условия возврата, иначе ваша функция вызовет себя саму бесконечное количество раз. По этой причине функция <code>elem_exists()</code> имеет несколько директив <code>return</code>.</p>

<p>Perl выводит полезное предупреждение <code>Deep recursion on subroutine</code>, если подозревает неконтролируемую рекурсию. Ограничение в 100 рекурсивных вызовов произвольно, но зачастую удобно. Отключите это предупреждение, указав <code>no warnings 'recursion'</code> в области видимости рекурсивного вызова.</p>

<p>Так как каждый вызов функции требует нового фрейма вызова и пространства для хранения лексических переменных, глубокорекурсивный код может использовать больше памяти, чем итеративный код. <em>Устранение хвостовых вызовов</em> может помочь.</p>

<p><em>Хвостовой вызов</em> &mdash; это вызов функции, который напрямую возвращает результаты этой функции. Эти рекурсивные вызовы <code>elem_exists()</code>:</p>

<pre><code>    # &#x440;&#x430;&#x437;&#x431;&#x438;&#x432;&#x430;&#x435;&#x43C; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432; &#x43D;&#x430;&#x434;&#x432;&#x43E;&#x435; &#x438; &#x43F;&#x440;&#x43E;&#x434;&#x43E;&#x43B;&#x436;&#x430;&#x435;&#x43C; &#x440;&#x435;&#x43A;&#x443;&#x440;&#x441;&#x438;&#x432;&#x43D;&#x43E;
    return <strong>elem_exists</strong>(
        $item, @array[0 .. $midpoint]
    ) if $item &lt; $miditem;

    # &#x440;&#x430;&#x437;&#x431;&#x438;&#x432;&#x430;&#x435;&#x43C; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432; &#x43D;&#x430;&#x434;&#x432;&#x43E;&#x435; &#x438; &#x43F;&#x440;&#x43E;&#x434;&#x43E;&#x43B;&#x436;&#x430;&#x435;&#x43C; &#x440;&#x435;&#x43A;&#x443;&#x440;&#x441;&#x438;&#x432;&#x43D;&#x43E;
    return <strong>elem_exists</strong>(
         $item, @array[ $midpoint + 1 .. $#array ]
    );</code></pre>

<p>&hellip;кандидаты для устранения хвостовых вызовов. Эта оптимизация позволит избежать возврата в текущий вызов и последующего возврата в родительский вызов. Вместо этого, она возвращается в родительский вызов напрямую.</p>

<p>  </p>

<p>К сожалению, Perl 5 не устраняет хвостовые вызовы автоматически. Это делается вручную с помощью специальной формы встроенной директивы <code>goto</code>. В отличие от формы, зачастую производящей спагетти-код, функциональная форма <code>goto</code> заменяет текущий вызов функции вызовом другой функции. Вы можете указывать функцию с помощью имени или ссылки. Для передачи аргументов присваивайте напрямую в <code>@_</code>:</p>

<pre><code>    # &#x440;&#x430;&#x437;&#x431;&#x438;&#x432;&#x430;&#x435;&#x43C; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432; &#x43D;&#x430;&#x434;&#x432;&#x43E;&#x435; &#x438; &#x43F;&#x440;&#x43E;&#x434;&#x43E;&#x43B;&#x436;&#x430;&#x435;&#x43C; &#x440;&#x435;&#x43A;&#x443;&#x440;&#x441;&#x438;&#x432;&#x43D;&#x43E;
    if ($item &lt; $miditem)
    {
        @_ = ($item, @array[0 .. $midpoint]);
        <strong>goto &amp;elem_exists;</strong>
    }

    # &#x440;&#x430;&#x437;&#x431;&#x438;&#x432;&#x430;&#x435;&#x43C; &#x43C;&#x430;&#x441;&#x441;&#x438;&#x432; &#x43D;&#x430;&#x434;&#x432;&#x43E;&#x435; &#x438; &#x43F;&#x440;&#x43E;&#x434;&#x43E;&#x43B;&#x436;&#x430;&#x435;&#x43C; &#x440;&#x435;&#x43A;&#x443;&#x440;&#x441;&#x438;&#x432;&#x43D;&#x43E;
    else
    {
        @_ = ($item, @array[$midpoint + 1 .. $#array] );
        <strong>goto &amp;elem_exists;</strong>
    }</code></pre>

<p>Иногда оптимизации довольно уродливы.</p>

<h2>Ловушки и недостатки</h2>

<p>     </p>

<p>Perl 5 всё ещё поддерживает старомодный вызов функций, полученный в наследство от старших версий Perl. Тогда как сейчас вы можете вызывать Perl-функции по имени, предыдущие версии Perl требовали их вызова с использованием ведущего символа амперсанда (<code>&</code>). Perl 1 требовал использования встроенной директивы <code>do</code>:</p>

<pre><code>    # &#x443;&#x441;&#x442;&#x430;&#x440;&#x435;&#x432;&#x448;&#x438;&#x439; &#x441;&#x442;&#x438;&#x43B;&#x44C;; &#x438;&#x437;&#x431;&#x435;&#x433;&#x430;&#x439;&#x442;&#x435;
    my $result = &amp;calculate_result( 52 );

    # &#x441;&#x442;&#x438;&#x43B;&#x44C; Perl 1; &#x438;&#x437;&#x431;&#x435;&#x433;&#x430;&#x439;&#x442;&#x435;
    my $result = do calculate_result( 42 );

    # &#x441;&#x443;&#x43C;&#x430;&#x441;&#x448;&#x435;&#x434;&#x448;&#x430;&#x44F; &#x43C;&#x435;&#x448;&#x430;&#x43D;&#x438;&#x43D;&#x430;; &#x432; &#x441;&#x430;&#x43C;&#x43E;&#x43C; &#x434;&#x435;&#x43B;&#x435; &#x438;&#x437;&#x431;&#x435;&#x433;&#x430;&#x439;&#x442;&#x435;, &#x43F;&#x440;&#x430;&#x432;&#x434;&#x430;
    my $result = do &amp;calculate_result( 42 );</code></pre>

<p>Кроме того, что этот рудиментарный синтаксис &mdash; визуальный хаос, форма с ведущим амперсандом имеет несколько неожиданных поведений. Во-первых, она отключает любую проверку прототипа. Во-вторых, она <em>неявно</em> передаёт содержимое <code>@_</code> немодифицированным, если вы сами не укажете аргументы. И то, и другое может приводить к неожиданному поведению.</p>

<p>Последняя ловушка проистекает из опускания скобок из вызова фукнции. Парсер Perl 5 использует несколько эвристических методов для разрешения неоднозначных голых слов и количества параметров, передаваемых в функцию. Эвристики могут ошибаться:</p>

<pre><code>    # &#x432;&#x43D;&#x438;&#x43C;&#x430;&#x43D;&#x438;&#x435;; &#x441;&#x43E;&#x434;&#x435;&#x440;&#x436;&#x438;&#x442; &#x445;&#x438;&#x442;&#x440;&#x44B;&#x439; &#x431;&#x430;&#x433;
    ok elem_exists 1, @elements, &#39;found first element&#39;;</code></pre>

<p>Вызов <code>elem_exists()</code> поглотит описание теста, которое должно было быть вторым аргументом <code>ok()</code>. Так как <code>elem_exists()</code> использует проглатывающий второй параметр, это может пройти незамеченным до тех пор, пока Perl не выдаст предупреждение о сравнении нечислового значения (описание теста, которое он не может сконвертировать в число) с элементом в массиве.</p>

<p>Хотя лишние скобки можут препятствовать читаемости, обдуманное использование скобок может прояснить код и сделать коварные баги маловероятными.</p>

<h2>Область видимости</h2>

<p><a name="scope"></p>

<p> </p>

<p><em>Область видимости</em> в Perl обозначает продолжительность жизни и видимость именованных сущностей. В Perl всё, что имеет имя (переменная, функция), имеет область видимости. Ограничение области видимости помогает усилить <em>инкапсуляцию</em> &mdash; сохранение связанных понятий вместе и предотвращение их вытекания наружу.</p>

<h3>Лексическая область видимости</h3>

<p><a name="lexical_scope"></p>

<p> </p>

<p><em>Лексическая область видимости</em> &mdash; это область видимости, видимая по ходу <em>чтения</em> программы. Компилятор Perl определяет эту область видимости во время компиляции. Блок, ограниченный фигурными скобками, создаёт новую область видимости, будь это голый блок, блок конструкции цикла, блок объявления <code>sub</code>, блок <code>eval</code> или любой другой блок, не заключающий в кавычки.</p>

<p></p>

<p>Лексическая область видимости определяет видимость переменных, объявленных с помощью <code>my</code> &mdash; <em>лексических</em> переменных. Лексическая переменная, объявленная в одной области видимости, видима в этой области видимости и любых областях видимости, вложенных в неё, но невидима в областях видимости, находящихся на том же уровне вложенности или выше:</p>

<pre><code>    # &#x432;&#x43D;&#x435;&#x448;&#x43D;&#x44F;&#x44F; &#x43B;&#x435;&#x43A;&#x441;&#x438;&#x447;&#x435;&#x441;&#x43A;&#x430;&#x44F; &#x43E;&#x431;&#x43B;&#x430;&#x441;&#x442;&#x44C; &#x432;&#x438;&#x434;&#x438;&#x43C;&#x43E;&#x441;&#x442;&#x438;
    {
        package Robot::Butler

        # &#x432;&#x43D;&#x443;&#x442;&#x440;&#x435;&#x43D;&#x43D;&#x44F;&#x44F; &#x43B;&#x435;&#x43A;&#x441;&#x438;&#x447;&#x435;&#x441;&#x43A;&#x430;&#x44F; &#x43E;&#x431;&#x43B;&#x430;&#x441;&#x442;&#x44C; &#x432;&#x438;&#x434;&#x438;&#x43C;&#x43E;&#x441;&#x442;&#x438;
        my $battery_level;

        sub tidy_room
        {
            # &#x431;&#x43E;&#x43B;&#x435;&#x435; &#x433;&#x43B;&#x443;&#x431;&#x43E;&#x43A;&#x430;&#x44F; &#x432;&#x43B;&#x43E;&#x436;&#x435;&#x43D;&#x43D;&#x430;&#x44F; &#x43E;&#x431;&#x43B;&#x430;&#x441;&#x442;&#x44C; &#x432;&#x438;&#x434;&#x438;&#x43C;&#x43E;&#x441;&#x442;&#x438;
            my $timer;

            do {
                # &#x441;&#x430;&#x43C;&#x430;&#x44F; &#x433;&#x43B;&#x443;&#x431;&#x43E;&#x43A;&#x430;&#x44F; &#x43B;&#x435;&#x43A;&#x441;&#x438;&#x447;&#x435;&#x441;&#x43A;&#x430;&#x44F; &#x43E;&#x431;&#x43B;&#x430;&#x441;&#x442;&#x44C; &#x432;&#x438;&#x434;&#x438;&#x43C;&#x43E;&#x441;&#x442;&#x438;
                my $dustpan;
                ...
            } while (@_);

            # &#x43B;&#x435;&#x43A;&#x441;&#x438;&#x447;&#x435;&#x441;&#x43A;&#x430;&#x44F; &#x43E;&#x431;&#x43B;&#x430;&#x441;&#x442;&#x44C; &#x432;&#x438;&#x434;&#x438;&#x43C;&#x43E;&#x441;&#x442;&#x438;, &#x43D;&#x430;&#x445;&#x43E;&#x434;&#x44F;&#x449;&#x430;&#x44F;&#x441;&#x44F; &#x43D;&#x430; &#x442;&#x43E;&#x43C; &#x436;&#x435; &#x443;&#x440;&#x43E;&#x432;&#x43D;&#x435;
            for (@_)
            {
                # &#x43E;&#x442;&#x434;&#x435;&#x43B;&#x44C;&#x43D;&#x430;&#x44F; &#x441;&#x430;&#x43C;&#x430;&#x44F; &#x433;&#x43B;&#x443;&#x431;&#x43E;&#x43A;&#x430;&#x44F; &#x43B;&#x435;&#x43A;&#x441;&#x438;&#x447;&#x435;&#x441;&#x43A;&#x430;&#x44F; &#x43E;&#x431;&#x43B;&#x430;&#x441;&#x442;&#x44C; &#x432;&#x438;&#x434;&#x438;&#x43C;&#x43E;&#x441;&#x442;&#x438;
                my $polish_cloth;
                ...
            }
        }
    }</code></pre>

<p>&hellip;переменная <code>$battery_level</code> видима во всех четырёх областях видимости. <code>$timer</code> видима в методе, блоке <code>do</code> и цикле <code>for</code>. <code>$dustpan</code> видима только в блоке <code>do</code>, а <code>$polish_cloth</code> &mdash; только в цикле <code>for</code>.</p>

<p> </p>

<p>Объявление во внутренней области видимости лексической переменной с тем же именем, что и лексическая переменная во внешней области видимости, скрывает, или <em>затеняет</em>, внешнюю переменную во внутренней области видимости. Зачастую это именно то, что вам нужно:</p>

<pre><code>    my $name = &#39;Jacob&#39;;

    {
        my $name = &#39;Edward&#39;;
        say $name;
    }

    say $name;</code></pre>

<p>Лексическое затенение может происходить по случайности. Ограничивайте область видимости переменных и вложенность областей видимости для уменьшения риска.</p>

<p>Эта программа выводит <code>Edward</code> и затем <code>Jacob</code> (footnote: Члены семьи, а не вампиры.), несмотря на то, что переобъявление лексической переменной с тем же именем и типом <em>в той же самой лексической области видимости</em> приводит к предупреждающему сообщению. Затенение лексической переменной &mdash; особенность инкапсуляции.</p>

<p>Некоторые лексические объявления имеют тонкости, как, например, лексическая переменная, используемая как переменная-итератор в цикле <code>for</code>. Её объявление находится снаружи блока, но её область видимости &mdash; <em>внутри</em> блока цикла:</p>

<pre><code>    my $cat = &#39;Brad&#39;;

    for my $cat (qw( Jack Daisy Petunia Tuxedo Choco ))
    {
        say &quot;Iterator cat is $cat&quot;;
    }

    say &quot;Static cat is $cat&quot;;</code></pre>

<p> </p>

<p>Аналогично, <code>given</code> (<a href="chapter_03.html#given_when">given/when</a>) создаёт <em>лексический топик</em> (как <code>my $_</code>) внутри своего блока:</p>

<pre><code>    $_ = &#39;outside&#39;;

    given (&#39;inner&#39;)
    {
        say;
        $_ = &#39;this assignment does nothing useful&#39;;
    }

    say;</code></pre>

<p>&hellip;так что выход из блока восстанавливает предыдущее значение <code>$_</code>.</p>

<p>Функции &mdash; именованные и анонимные &mdash; создают лексическую область видимости для своих тел. Это помогает созданию замыканий (<a href="chapter_05.html#closures">Замыкания</a>).</p>

<h3>Область видимости our</h3>

<p><a name="our">   </p>

<p>Внутри заданной области видимости можно объявить псевдоним переменной пакета с помощью встроенной директивы <code>our</code>. Как и <code>my</code>, <code>our</code> обеспечивает лексическую область видимости псевдонима. Полностью определённое имя доступно из любого места, но лексический псевдоним виден только внутри своей области видимости.</p>

<p><code>our</code> наиболее полезна в применении к глобальным переменным пакета, таким как <code>$VERSION</code> и <code>$AUTOLOAD</code>.</p>

<h3>Динамическая область видимости.</h3>

<p><a name="dynamic_scope"></p>

<p> </p>

<p>Динамическая область видимости похожа на лексическую область видимости по своим правилам видимости, но вместо поиска наружу в области видимости времени компиляции, поиск проходит назад через контекст вызова. В то время как глобальная переменная пакета может быть <em>видима</em> внутри всех областей видимости, её <em>значение</em> изменяется в зависимости от локализации (<code>local</code>) и присваивания:</p>

<pre><code>    our $scope;

    sub inner
    {
        say $scope;
    }

    sub main
    {
        say $scope;
        local $scope = &#39;main() scope&#39;;
        middle();
    }

    sub middle
    {
        say $scope;
        inner();
    }

    $scope = &#39;outer scope&#39;;
    main();
    say $scope;</code></pre>

<p>Программа начинается с объявления <code>our</code>-переменной, <code>$scope</code>, а так же трёх функций. Заканчивается она присваиванием <code>$scope</code> и вызовом <code>main()</code>.</p>

<p></p>

<p>Внутри <code>main()</code> программа выводит текущее значение <code>$scope</code>, <code>outer scope</code>, затем локализует переменную с помощью <code>local</code>. Это изменяет видимость символа внутри текущей лексической области видимости, <em>так же как</em> и в любых функциях, вызываемых из <em>текущей</em> лексической области видимости. Таким образом, <code>$scope</code> содержит <code>main() scope</code> внутри тела как <code>middle()</code>, так и <code>inner()</code>. После возврата из <code>main()</code>, когда поток управления достигает конца её блока, Perl восстанавливает исходное значение локализованной <code>$scope</code>. Последняя директива <code>say</code> снова выводит <code>outer scope</code>.</p>

<p>  </p>

<p>Переменные пакетов и лексические переменные в Perl имеют разные правила видимости и механизмы хранения. Каждая область видимости, содержащая лексические переменные, имеет специальную структуру данных, называемую <em>лексическая записная книжка</em> (<em>lexical pad</em>, или <em>lexpad</em>), которая может хранить значения содержащихся в ней лексических переменных. Каждый раз, когда поток управления входит в одну из этих областей видимости, Perl создаёт ещё одну лексическую записную книжку для значений этих лексических переменных для этого конкретного вызова. Это позволяет функции работать корректно, особенно в рекурсивных вызовах (<a href="chapter_05.html#recursion">Рекурсия</a>).</p>

<p>Каждый пакет имеет единую <em>символьную таблицу</em>, содержащую переменные пакета, а также именованные функции. Импорт (<a href="chapter_05.html#importing">Импорт</a>) инспектирует и манипулирует этой символьной таблицей. Также делает и <code>local</code>. Вы можете локализовать только глобальные переменные и глобальные переменные пакета &mdash; но не лексические переменные.</p>

<p>       </p>

<p><code>local</code> чаще всего используется с магическими переменными. Например, <code>$/</code>, разделитель входных записей, определяет, сколько данных операция <code>readline</code> прочитает из дескриптора файла. <code>$!</code>, переменная системной ошибки, содержит номер ошибки последнего системного вызова. <code>$@</code>, переменная ошибки <code>eval</code>, содержит любую ошибку из последней операции <code>eval</code>. <code>$|</code>, переменная автосброса, определяет, будет ли Perl сбрасывать текущий выбранный (<code>select</code>) дескриптор файла после каждой операции записи.</p>

<p>Локализация этих переменных в как можно более узкой области видимости ограничивает эффект ваших изменений. Это может предотвратить странное поведение в других частях вашего кода.</p>

<h3>Область видимости state</h3>

<p><a name="state_scope"></p>

<p>  </p>

<p>Perl 5.10 добавил новую область видимости для поддержки встроенной директивы <code>state</code>. Область видимости state похожа на лексическую область видимости в отношении условий видимости, но добавляет однократную инициализацию, а также персистентность значения:</p>

<pre><code>    sub counter
    {
        <strong>state</strong> $count = 1;
        return $count++;
    }

    say counter();
    say counter();
    say counter();</code></pre>

<p>При первом вызове <code>counter</code> Perl выполняет единственную инициализацию <code>$count</code>. При последующих вызовах <code>$count</code> сохраняет своё предыдущее значение. Эта программа выведет <code>1</code>, <code>2</code> и <code>3</code>. Замените <code>state</code> на <code>my</code>, и программа будет выводить <code>1</code>, <code>1</code> и <code>1</code>.</p>

<p>Вы можете использовать выражение для установки начального значения <code>state</code>-переменной:</p>

<pre><code>    sub counter
    {
        state $count = shift;
        return $count++;
    }

    say counter(<strong>2</strong>);
    say counter(<strong>4</strong>);
    say counter(<strong>6</strong>);</code></pre>

<p>Несмотря на то, что простое прочтение кода может привести к предположению, что выведено будет <code>2</code>, <code>4</code> и <code>6</code>, на самом деле выведено будет <code>2</code>, <code>3</code> и <code>4</code>. Первый вызов процедуры <code>counter</code> установит значение переменной <code>$count</code>. Последующие вызовы не будут изменять её значение.</p>

<p><code>state</code> может быть полезна для установки значения по умолчанию или подготовки кеша, но если вы её используете, убедитесь, что понимаете её инициализационное поведение:</p>

<pre><code>    sub counter
    {
        state $count = shift;
        say &#39;Second arg is: &#39;, shift;
        return $count++;
    }

    say counter(2, &#39;two&#39;);
    say counter(4, &#39;four&#39;);
    say counter(6, &#39;six&#39;);</code></pre>

<p>Счётчик для этой программы выведет <code>2</code>, <code>3</code> и <code>4</code>, как и ожидалось, но значения подразумеваемого второго аргумента вызовов <code>counter()</code> будут <code>two</code>, <code>4</code> и <code>6</code> &mdash; потому что <code>shift</code> для первого аргумента происходит только при первом вызове <code>counter()</code>. Или измените API для предотвращения этой ошибки, или защититесь от неё:</p>

<pre><code>    sub counter
    {
        my ($initial_value, $text) = @_;

        state $count = $initial_value;
        say &quot;Second arg is: $text&quot;;
        return $count++;
    }

    say counter(2, &#39;two&#39;);
    say counter(4, &#39;four&#39;);
    say counter(6, &#39;six&#39;);</code></pre>

<h2>Анонимные функции</h2>

<p><a name="anonymous_functions"></p>

<p></p>

<p><em>Анонимная функция</em> &mdash; это функция без имени. В остальном она ведёт себя в точности так же, как именованная функция &mdash; вы можете вызывать её, передавать в неё аргументы, возвращать из неё значения и копировать ссылки на неё. Однако единственный способ работать с ней &mdash; по ссылке (<a href="chapter_03.html#function_references">Ссылки на функции</a>).</p>

<p>  </p>

<p>Распространённая идиома Perl 5, известная как <em>таблица диспетчеризации</em>, использует хеши для сопоставления входных данных с соответствующим поведением:</p>

<pre><code>    my %dispatch =
    (
        plus     =&gt; \&amp;add_two_numbers,
        minus    =&gt; \&amp;subtract_two_numbers,
        times    =&gt; \&amp;multiply_two_numbers,
    );

    sub add_two_numbers      { $_[0] + $_[1] }
    sub subtract_two_numbers { $_[0] - $_[1] }
    sub multiply_two_numbers { $_[0] * $_[1] }

    sub dispatch
    {
        my ($left, $op, $right) = @_;

        return unless exists $dispatch{ $op };

        return $dispatch{ $op }-&gt;( $left, $right );
    }</code></pre>

<p>Функция <code>dispatch()</code> принимает аргументы в форме <code>(2, 'times', 2)</code> и возвращает результат вычисления операции.</p>

<h3>Объявление анонимных функций</h3>

<p></p>

<p>Встроенная директива <code>sub</code>, использованная без имени, создаёт и возвращает анонимную функцию. Используйте эту ссылку на функцию в любом месте, где вы могли бы использовать ссылку на именованную функцию, как, например, объявление функций таблицы диспетчеризации прямо на месте:</p>

<pre><code>    my %dispatch =
    (
        plus      =&gt; sub { $_[0]  + $_[1] },
        minus     =&gt; sub { $_[0]  - $_[1] },
        times     =&gt; sub { $_[0]  * $_[1] },
        dividedby =&gt; sub { $_[0]  / $_[1] },
        raisedto  =&gt; sub { $_[0] ** $_[1] },
    );</code></pre>

<p>Эта таблица диспетчеризации создаёт некоторую степень защиты; только функции, входящие в таблицу, доступны для вызова пользователями. Если ваша функция диспетчеризации слепо предполагает, что строка, заданная как имя оператора, напрямую соответствует имени вызываемой функции, злонамеренный пользователь потенциально сможет вызвать любую функцию в любом пространстве имён, передав <code>'Internal::Functions::malicious_function'</code>.</p>

<p>Вам также может встретиться передача анонимных функций как аргументов функции:</p>

<pre><code>    sub invoke_anon_function
    {
        my $func = shift;
        return $func-&gt;( @_ );
    }

    sub named_func
    {
        say &#39;I am a named function!&#39;;
    }

    invoke_anon_function( \&amp;named_func );
    invoke_anon_function( <strong>sub { say &#39;Who am I?&#39; }</strong> );</code></pre>

<h3>Имена анонимных функций</h3>

<p></p>

<p></p>

<p>Имея ссылку на функцию, вы можете определить, именованная она или анонимная, с помощью интроспекции (footnote: &hellip;или с помощью <code>sub_name</code> из CPAN-модуля <code>Sub::Identitiy</code>.):</p>

<pre><code>    package ShowCaller;

    sub show_caller
    {
        my ($package, $file, $line, $sub) = caller(1);
        say &quot;Called from $sub in $package:$file:$line&quot;;
    }

    sub main
    {
        my $anon_sub = sub { show_caller() };
        show_caller();
        $anon_sub-&gt;();
    }

    main();</code></pre>

<p>Результат может быть неожиданным:</p>

<pre><code>    Called from ShowCaller::<strong>main</strong>
             in ShowCaller:anoncaller.pl:20
    Called from ShowCaller::<strong>__ANON__</strong>
             in ShowCaller:anoncaller.pl:17</code></pre>

<p></p>

<p><code>__ANON__</code> во второй строке вывода показывает, что анонимная функция не имеет имени, которое Perl мог бы распознать. Это может усложнить отладку. Функция <code>subname()</code> из CPAN-модуля <code>Sub::Name</code> позволяет вам закреплять имена за анонимными функциями:</p>

<pre><code>    use Sub::Name;
    use Sub::Identify &#39;sub_name&#39;;

    my $anon  = sub {};
    say sub_name( $anon );

    my $named = subname( &#39;pseudo-anonymous&#39;, $anon );
    say sub_name( $named );
    say sub_name( $anon );

    say sub_name( sub {} );</code></pre>

<p>Эта программа выведет:</p>

<pre><code>    __ANON__
    pseudo-anonymous
    pseudo-anonymous
    __ANON__</code></pre>

<p>Имейте ввиду, что обе ссылки ссылаются на одну и ту же лежащую в основе функцию. Использование <code>subname()</code> на одной ссылке на функцию будет изменять имя этой анонимной функции так, что все остальные ссылки на неё будут видеть это новое имя.</p>

<h3>Неявные анонимные функции</h3>

<p></p>

<p></p>

<p>Perl 5 позволяет объявлять анонимные фукнции неявно, используя прототипы (<a href="chapter_11.html#prototypes">Прототипы</a>). Хотя официально эта возможность существует для того, чтобы дать программистам возможность писать свой собственный синтаксис, подобный <code>map</code> и <code>eval</code>, интересным примером является использование <em>отложенных</em> функций, которые не выглядят как функции.</p>

<p>Рассмотрите CPAN-модуль <code>Test::Fatal</code>, который принимает анонимную функцию как первый аргумент своей функции <code>exception()</code>:</p>

<pre><code>    use Test::More;
    use Test::Fatal;

    my $croaker = exception { die &#39;I croak!&#39; };
    my $liver   = exception { 1 + 1 };

    like( $croaker, qr/I croak/, &#39;die() should croak&#39;   );
    is(   $liver,   undef,       &#39;addition should live&#39; );

    done_testing();</code></pre>

<p>Вы можете переписать это более многословно следующим образом:</p>

<pre><code>    my $croaker = exception( sub { die &#39;I croak!&#39; } );
    my $liver   = exception( sub { 1 + 1 } );</code></pre>

<p>&hellip; или передать именованную функцию по ссылке:</p>

<pre><code>    <strong>sub croaker { die &#39;I croak!&#39; }</strong>
    <strong>sub liver   { 1 + 1 }</strong>

    my $croaker = exception \&amp;croaker;
    my $liver   = exception \&amp;liver;

    like( $croaker, qr/I croak/, &#39;die() should die&#39;     );
    is(   $liver,   undef,       &#39;addition should live&#39; );</code></pre>

<p>&hellip;но вы <em>не</em> можете передавать их как скалярные ссылки:</p>

<pre><code>    <strong>my $croak_ref = \&amp;croaker;</strong>
    <strong>my $live_ref  = \&amp;liver;</strong>

    # &#x41E;&#x428;&#x418;&#x411;&#x41E;&#x427;&#x41D;&#x41E;: &#x43D;&#x435; &#x440;&#x430;&#x431;&#x43E;&#x442;&#x430;&#x435;&#x442;
    my $croaker   = exception $croak_ref;
    my $liver     = exception $live_ref;</code></pre>

<p>&hellip;потому что прототип изменяет то, как парсер Perl 5 интерпретирует этот код. Он не может со стопроцентной точностью определить, <em>что</em> будут содержать <code>$croaker</code> и <code>$liver</code>, и поэтому выбросит исключение.</p>

<pre><code>    Type of arg 1 to Test::Fatal::exception
       must be block or sub {} (not private variable)</code></pre>

<p>Кроме того, имейте ввиду, что функция, принимающая анонимную функцию как первый из нескольких аргументов, не может иметь замыкающую запятую после блока функции:</p>

<pre><code>    use Test::More;
    use Test::Fatal &#39;dies_ok&#39;;

    dies_ok { die &#39;This is my boomstick!&#39; }
            &#39;No movie references here&#39;;</code></pre>

<p>Это временами сбивающий с толку изъян в остальном полезного синтаксиса, учтивость в отношении причуд парсера Perl 5. Синтаксическая ясность, обеспечиваемая повышением голых блоков до анонимных функций, может быть полезной, но используйте её экономно и тщательно документируйте API.</p>

<h2>Замыкания</h2>

<p><a name="closures">  </p>

<p>Каждый раз, когда поток управления входит в функцию, эта функцию получает новое окружение, представляющее лексическую область видимости (<a href="chapter_05.html#scope">Область видимости</a>) этого вызова. Это в той же мере применимо и к анонимным функциям (<a href="chapter_05.html#anonymous_functions">Анонимные функции</a>). Следствия этого очень значимы. Термин компьютерных наук <em>функции высшего порядка</em> ссылается на функции, манипулирующие другими функциями. Замыкания &mdash; пример этой значимости.</p>

<h3>Создание замыканий</h3>

<p> </p>

<p><em>Замыкание</em> &mdash; это функция, использующая лексические переменные из внешней области видимости. Вы, вероятно, уже создавали и использовали замыкания, не осознавая этого:</p>

<pre><code>    package Invisible::Closure;

    my $filename = shift @ARGV;

    sub get_filename { return $filename }</code></pre>

<p>Если этот код выглядит для вас очевидным, отлично! <em>Конечно</em> функция <code>get_filename()</code> может видеть лексическую переменную <code>$filename</code>. Именно так работают области видимости!</p>

<p>Предположим, вы хотите пройти в цикле по списку элементов без необходимости самостоятельно управлять итератором. Вы можете создать функцию, которая возвращает функцию, которая, будучи вызванной, вернёт следующий элемент в итерации:</p>

<pre><code>    sub make_iterator
    {
        my @items = @_;
        my $count = 0;

        return sub
        {
            return if $count == @items;
            return $items[ $count++ ];
        }
    }

    my $cousins = make_iterator(
        qw( Rick Alex Kaycee Eric Corey Mandy Christine )
    );

    say $cousins-&gt;() for 1 .. 5;</code></pre>

<p>Хотя и произошёл возврат из <code>make_iterator()</code>, анонимная функция, сохранённая в <code>$cousins</code>, замкнула значения этих переменных как они существовали внутри вызова <code>make_iterator()</code>. Их значения продолжают существовать (<a href="chapter_03.html#reference_counts">Счётчики ссылок</a>).</p>

<p>Так как каждый вызов <code>make_iterator()</code> создаёт отдельное лексическое окружение, анонимная функция, которую она создаёт и возвращает, замыкается на уникальном лексическом окружении:</p>

<pre><code>    my $aunts = make_iterator(
        qw( Carole Phyllis Wendy Sylvia Monica Lupe )
    );

    say $cousins-&gt;();
    say $aunts-&gt;();</code></pre>

<p>Так как <code>make_iterator()</code> не возвращает эти лексические переменные по значению или по ссылке, никакой другой Perl-код, кроме замыкания, не сможет получить к ним доступ. Они инкапсулированы так же эффективно, как любая другая лексическая инкапсуляция, хотя любой код, разделяющий лексическое окружение, может получить доступ к этим значениями. Эта идиома предоставляет лучшую инкапсуляцию того, что в ином случае было бы глобальной переменной файла или пакета:</p>

<pre><code>    {
        my $private_variable;

        sub set_private { $private_variable = shift }
        sub get_private { $private_variable }
    }</code></pre>

<p>Имейте ввиду, что вы не можете <em>вкладывать</em> именованные функции. Именованные функции имеют глобальную область видимости пакета. Любые лексические переменные, разделяемые между вложенными функциями, перестанут быть разделяемыми, как только внешняя функция уничтожит своё первое лексическое окружение (footnote: Это это приводит вас в замешательство, представьте реализацию.).</p>

<p></p>

<p>CPAN-модуль <code>PadWalker</code> позволяет вам нарушать лексическую инкапсуляцию, но любой, кто использовал его и сломал ваш код, заслуживает права исправить любые сопутствующие баги без вашей помощи.</p>

<h3>Использование замыканий</h3>

<p>Итерирование по списку постоянного размера с помощью замыкания &mdash; интересный пример, но замыкания могут делать гораздо больше, как, например, итерирование по списку, который слишком дорог для вычисления или слишком велик, чтобы держать его в памяти целиком. Рассмотрим функцию, создающую последовательность чисел Фибоначчи по мере того, как вам понадобятся её элементы. Вместо повторного вычисления последовательности рекурсивно, используйте кеш и ленивое создание требуемых элементов:</p>

<pre><code>    sub gen_fib
    {
        my @fibs = (0, 1);

        return sub
        {
            my $item = shift;

            if ($item &gt;= @fibs)
            {
                for my $calc (@fibs .. $item)
                {
                    $fibs[$calc] = $fibs[$calc - 2]
                                 + $fibs[$calc - 1];
                }
            }
            return $fibs[$item];
        }
    }</code></pre>

<p>Каждый вызов функции, возвращаемой <code>get_fib()</code>, принимает один аргумент, <em>n</em>-ный элемент последовательности Фибоначчи. Функция генерирует все предшествующие значения в последовательности по мере необходимости, кеширует их и возвращает запрошенный элемент &mdash; и даже откладывает вычисление до абсолютной необходимости. Однако здесь шаблон, характерный для кеширования, переплетается с числовыми последовательностями. Что получится, если вы выделите связанный с кешированием код (инициализация кеша, выполнение нужного кода для заполнения элементов кеша и возврат вычисленного или полученного из кеша значения) в функцию <code>generate_caching_closure()</code>?</p>

<pre><code>    sub gen_caching_closure
    {
        my ($calc_element, @cache) = @_;

        return sub
        {
            my $item = shift;

            $calc_element-&gt;($item, \@cache)
                unless $item &lt; @cache;

            return $cache[$item];
        };
    }</code></pre>

<p>Встроенные функции <code>map</code>, <code>grep</code> и <code>sort</code> сами по себе &mdash; функции высшего порядка.</p>

<p>Теперь <code>gen_fib()</code> превращается в:</p>

<pre><code>    sub gen_fib
    {
        my @fibs = (0, 1, 1);

        return gen_caching_closure(
            sub
            {
                my ($item, $fibs) = @_;

                for my $calc ((@$fibs - 1) .. $item)
                {
                    $fibs-&gt;[$calc] = $fibs-&gt;[$calc - 2]
                                   + $fibs-&gt;[$calc - 1];
                }
            },
            @fibs
        );
    }</code></pre>

<p>Программа ведёт себя так же, как и раньше, но использование ссылок на функции и замыканий отделяет инициализирующее кеш поведение от вычисления следующего числа последовательности Фибоначчи. Кастомизация поведения кода &mdash; в данном случае <code>get_caching_closure()</code> &mdash; с помощью передачи функции обеспечивает потрясающую гибкость.</p>

<h3>Замыкания и частичное применение</h3>

<p><a name="partial_application"></p>

<p>Также замыкания могут <em>удалить</em> нежелательную универсальность. Рассмотрим случай функции, принимающей несколько параметров:</p>

<pre><code>    sub make_sundae
    {
        my %args = @_;

        my $ice_cream = get_ice_cream( $args{ice_cream} );
        my $banana    = get_banana( $args{banana} );
        my $syrup     = get_syrup( $args{syrup} );
        ...
    }</code></pre>

<p>Мириады возможностей кастомизации могут быть очень полезны в полноценном магазине мороженого, но в случае передвижного фургончика с мороженым, в котором подают только мороженое Французская ваниль на бананах Кавендиш, каждый вызов <code>make_sundae()</code> требует передачи аргументов, которые никогда не изменяются.</p>

<p></p>

<p>Техника, называемая <em>частичное применение</em>, позволяет вам привязать <em>некоторые</em> из аргументов к функции, а остальные предоставлять позже. Оберните функцию, которую намереваетесь вызывать, в замыкание, и передайте связанные аргументы.</p>

<p>Рассмотрим фургончик с мороженым, продающий только мороженое Французская ваниль на бананах Кавендиш:</p>

<pre><code>    my $make_cart_sundae = sub
    {
        return make_sundae( @_,
            ice_cream =&gt; &#39;French Vanilla&#39;,
            banana    =&gt; &#39;Cavendish&#39;,
        );
    };</code></pre>

<p></p>

<p>Вместо вызова <code>make_sundae()</code> напрямую, вызовите ссылку на функцию в <code>$make_cart_sundae</code> и передайте только нужные аргументы, не опасаясь позабыть о неизменяющихся или передать их некорректно (footnote: Вы можете даже использовать <code>Sub::Install</code> из CPAN для импорта этой функции напрямую в другое пространство имён.).</p>

<p></p>

<p>Это только начало того, что вы можете делать с функиями высшего порядка. <em>Higher Order Perl</em> Марка Джейсона Доминуса (Mark Jason Dominus) &mdash; канонический справочник по функциям первого класса и замыканиям в Perl. Вы можете прочитать его онлайн по адресу http://hop.perl.plover.com/.</p>

<h2>Состояния против замыканий</h2>

<p><a name="state"></p>

<p>Замыкания (<a href="chapter_05.html#closures">Замыкания</a>) пользуются возможностями лексической области видимости (<a href="chapter_05.html#scope">Область видимости</a>) для предоставления опосредованного доступа к полу-приватным переменным. Даже именованные функции могут возпользоваться лексическими привязками:</p>

<pre><code>    {
        my $safety = 0;

        sub enable_safety  { $safety = 1 }
        sub disable_safety { $safety = 0 }

        sub do_something_awesome
        {
            return if $safety;
            ...
        }
    }</code></pre>

<p>Инкапсуляция функций для обеспечения безопасности позволяет всем трём функциям разделять состояние, не открывая лексическую переменную прямому воздействию внешнего кода. Эта идиома хорошо работает для тех случаев, когда внешний код должен иметь возможность изменять внутреннее состояние, но слишком тяжеловесна, если только одной функции нужно управлять состоянием.</p>

<p>Предположим, что каждый сотый покупатель вашего магазина мороженого получает бесплатную посыпку:</p>

<pre><code>    my $cust_count = 0;

    sub serve_customer
    {
        $cust_count++;

        my $order = shift;

        add_sprinkles($order) if $cust_count % 100 == 0;

        ...
    }</code></pre>

<p> </p>

<p>Этот подход <em>работает</em>, но создание новой лексической области видимости для единственной функции создаёт больше сопутствующей сложности, чем нужно. Встроенная директива <code>state</code> позволяет вам объявлять переменные лексической области видимости со значением, сохраняющимся между вызовами:</p>

<pre><code>    sub serve_customer
    {
        <strong>state $cust_count = 0;</strong>
        $cust_count++;

        my $order = shift;
        add_sprinkles($order)
            if ($cust_count % 100 == 0);

        ...
    }</code></pre>

<p> </p>

<p>Вы должны явно подключить эту возможность, используя модуль <code>Modern::Perl</code>, прагму <code>feature</code> (<a href="chapter_08.html#pragmas">Прагмы</a>) или требуя конкретную версию Perl 5.10 или выше (например, с помощью <code>use 5.010;</code> или <code>use 5.012;</code>).</p>

<p><code>state</code> также работает внутри анонимных функций:</p>

<pre><code>    sub make_counter
    {
        return sub
        {
             <strong>state $count = 0;</strong>
             return $count++;
         }
    }</code></pre>

<p>&hellip;хотя у этого подхода немного очевидных преимуществ.</p>

<h2>Состояния против псевдосостояний</h2>

<p>Perl 5.10 не рекомендует использование техники из предыдущих версий Perl, с помощью который вы могли в сущности эмулировать <code>state</code>. Именованная функция может замкнуться на своей предыдущей лексической области видимости с помощью злоупотребления нюансом реализации. Использование постфиксного условия, возвращающего ложь, с объявлением <code>my</code> позволяет избежать <em>повторной инициализации</em> лексической переменной значением <code>undef</code> или её инициализирующим значением.</p>

<p>Любое использование постфиксного условного выражения, модифицирующего объявление лексической переменной, теперь вызывает предупреждение о нерекомендуемости. С использованием этой техники слишком легко написать непреднамеренно ошибочный код; вместо этого используйте <code>state</code> там где доступно, или настоящие замыкания в ином случае. Перепишите эту идиому, если она вам попадётся:</p>

<pre><code>    sub inadvertent_state
    {
        # my $counter  = 1 if 0; # &#x41D;&#x415; &#x420;&#x415;&#x41A;&#x41E;&#x41C;&#x415;&#x41D;&#x414;&#x423;&#x415;&#x422;&#x421;&#x42F;; &#x43D;&#x435; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x443;&#x439;&#x442;&#x435;
        state $counter = 1;      # &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x443;&#x439;&#x442;&#x435; &#x432;&#x43C;&#x435;&#x441;&#x442;&#x43E;

        ...
    }</code></pre>

<h2>Атрибуты</h2>

<p><a name="attributes"></p>

<p>Именованные сущности в Perl &mdash; переменные и функции &mdash; могут иметь дополнительные метаданные, присоединённые к ним в виде <em>атрибутов</em>. Атрибуты &mdash; это произвольные имена и значения, используемые в определённых видах метапрограммирования (<a href="chapter_09.html#code_generation">Кодогенерация</a>).</p>

<p>Синтаксис объявления атрибутов довольно неуклюж, а использование атрибутов, в сущности, скорее искусство, чем наука. Большинство программ никогда их не используют, но при правильном использовании они обеспечивают ясность и удобство поддержки.</p>

<h3>Использование атрибутов</h3>

<p>Простой атрибут &mdash; это идентификатор с предшествующим ему двоеточием, привязанный к объявлению:</p>

<pre><code>    my $fortress      <strong>:hidden</strong>;

    sub erupt_volcano <strong>:ScienceProject</strong> { ... }</code></pre>

<p>Эти объявления будут приводить к вызову обработчиков атрибутов, названных <code>hidden</code> и <code>ScienceProject</code>, если они существуют для соответствующего типа (скаляров и функций соответственно). Эти обработчики могут делать <em>что угодно</em>. Если соответствующего обработчика не существует, Perl выбросит исключение времени компиляции.</p>

<p></p>

<p>Атрибуты могут включать списки параметров. Perl обрабатывает эти параметры как списки строковых и только строковых констант. Модуль <code>Test::Class</code> из CPAN с успехом использует такие параметрические аргументы:</p>

<pre><code>    sub setup_tests          :Test(setup)    { ... }
    sub test_monkey_creation :Test(10)       { ... }
    sub shutdown_tests       :Test(teardown) { ... }</code></pre>

<p>Атрибут <code>Test</code> указывает на методы, содержащие тестовые проверки, и опционально устанавливает число проверок, которые метод намерен запустить. Хотя интроспекция (<a href="chapter_07.html#reflection">Рефлексия</a>) этих классов может обнаружить соответствующие тестовые методы, имея хорошо спроектированные надёжные эвристики, атрибут <code>:Test</code> делает ваши намерения ясными.</p>

<p>Параметры <code>setup</code> и <code>teardown</code> позволяют тестовым классам определить свои собственные методы поддержки, не беспокоясь о конфликтах с другими подобными методами в других классах. Это отделяет проблему указания того, что этот класс должен делать, от проблемы того, как другие классы делают свою работу, и обеспечивает высокую гибкость.</p>

<p></p>

<p>Веб-фреймворк Catalyst также использует атрибуты для определения видимости и поведения методов в веб-приложениях.</p>

<h3>Недостатки атрибутов</h3>

<p>   </p>

<p>У атрибутов есть свои недостатки. Каноническая прагма для работы с атрибутами (прагма <code>attributes</code>) обозначала свой интерфейс как экспериментальный в течение многих лет. Базовый модуль <code>Attribute::Handlers</code> Демьена Конвея (Damian Conway) упрощает их реализацию. <code>Attribute::Lexical</code> Эндрю Мейна (Andrew Main) &mdash; более новый подход. По возможности предпочтите использование любого из них использованию <code>attributes</code>.</p>

<p></p>

<p>Наихудшая особенность атрибутов &mdash; их склонность создавать странные синтаксические действия на расстоянии. Имея фрагмент кода с атрибутами, можете ли вы предугадать их действие? Хорошо написанная документация помогает, но если невинно выглядящее объявление лексической переменной где-то сохраняет ссылку на эту переменную, ваши ожидания относительно срока жизни этой переменной могут быть ошибочны. Подобным же образом обработчик может обернуть функцию в другую функцию и заменить её в символьной таблице, не осведомив вас об этом, &mdash; рассмотрите атрибут <code>:memoize</code>, который автоматически вызывает базовый модуль <code>Memoize</code>.</p>

<p>Атрибуты в вашем распоряжении, когда они нужны вам для решения сложных проблем. Они могут быть очень полезными при правильном использовании &mdash; но большинству программ они никогда не понадобятся.</p>

<h2>AUTOLOAD</h2>

<p><a name="autoload"></p>

<p>Perl не требует от вас объявлять каждую функцию, прежде чем её вызывать. Perl охотно попытается вызвать функцию, даже если она не существует. Расмотрим программу:</p>

<pre><code>    use Modern::Perl;

    bake_pie( filling =&gt; &#39;apple&#39; );</code></pre>

<p>Когда вы её запустите, Perl вызовет исключение по причине вызова неопределённой функции <code>backe_pie()</code>.</p>

<p>Теперь добавьте функцию, называемую <code>AUTOLOAD()</code>:</p>

<pre><code>    sub AUTOLOAD {}</code></pre>

<p>Теперь, когда вы запустите программу, ничего очевидного не произойдёт. Perl вызовет функцию пакета с именем <code>AUTOLOAD()</code> &mdash; если она существует &mdash; в случае, если обычная диспетчеризация не сработает. Измените <code>AUTOLOAD()</code> для вывода сообщения:</p>

<pre><code>    sub AUTOLOAD { <strong>say &#39;In AUTOLOAD()!&#39;</strong> }</code></pre>

<p>&hellip;чтобы продемонстрировать, что она вызывается.</p>

<h3>Основные возможности AUTOLOAD</h3>

<p></p>

<p>Функция <code>AUTOLOAD()</code> получает аргументы, переданные в неопределённую функцию, напрямую в <code>@_</code>, а <em>имя</em> неопределённой функции доступно в глобальной переменной пакета <code>$AUTOLOAD</code>. Манипулируйте этими аргументами по своему усмотрению:</p>

<pre><code>    sub AUTOLOAD
    {
        <strong>our $AUTOLOAD;</strong>

        # &#x43E;&#x444;&#x43E;&#x440;&#x43C;&#x43B;&#x435;&#x43D;&#x43D;&#x44B;&#x439; &#x432;&#x44B;&#x432;&#x43E;&#x434; &#x430;&#x440;&#x433;&#x443;&#x43C;&#x435;&#x43D;&#x442;&#x43E;&#x432;
        local $&quot; = &#39;, &#39;;
        say &quot;In AUTOLOAD(@_) <strong>for $AUTOLOAD</strong>!&quot;
    }</code></pre>

<p>Объявление <code>our</code> (<a href="chapter_05.html#our">Область видимости our</a>) ограничивает <code>$AUTOLOAD</code> в пределах тела функции. Переменная содержит полностью определённое имя неопределённой функции (в данном случае <code>main::bake_pie</code>). Удалить имя пакета можно с помощью регулярного выражения (<a href="chapter_06.html#regex">Регулярные выражения и сопоставление</a>):</p>

<pre><code>    sub AUTOLOAD
    {
        <strong>my ($name) = our $AUTOLOAD =~ /::(\w+)$/;</strong>

        # &#x43E;&#x444;&#x43E;&#x440;&#x43C;&#x43B;&#x435;&#x43D;&#x43D;&#x44B;&#x439; &#x432;&#x44B;&#x432;&#x43E;&#x434; &#x430;&#x440;&#x433;&#x443;&#x43C;&#x435;&#x43D;&#x442;&#x43E;&#x432;
        local $&quot; = &#39;, &#39;;
        say &quot;In AUTOLOAD(@_) <strong>for $name</strong>!&quot;
    }</code></pre>

<p>Оригинальный вызов получит то, что вернёт <code>AUTOLOAD()</code>:</p>

<pre><code>    say secret_tangent( -1 );

    sub AUTOLOAD { return &#39;mu&#39; }</code></pre>

<p>До сих пор приведённые примеры всего лишь перехватывали вызовы к неопределённым функциям. Но есть и другие возможности.</p>

<h3>Редиспетчеризация методов в AUTOLOAD()</h3>

<p>     </p>

<p>Распространённый шаблон в ОО-программировании (<a href="chapter_07.html#moose">Moose</a>) &mdash; <em>делегировать</em> или <em>проксировать</em> определённые методы одного объекта другому, зачастую содержащемуся в первом или доступному из него каким-либо иным способом. Проксирование логирования может помочь с отладкой:</p>

<pre><code>    package Proxy::Log;

    sub new
    {
        my ($class, $proxied) = @_;
        bless \$proxied, $class;
    }

    sub AUTOLOAD
    {
        my ($name) = our $AUTOLOAD =~ /::(\w+)$/;
        Log::method_call( $name, @_ );

        my $self = shift;
        return $$self-&gt;$name( @_ );
    }</code></pre>

<p>Эта функция <code>AUTOLOAD()</code> логирует вызов метода. Затем она разыменовывает проксируемый объект из благословлённой скалярной ссылки, извлекает имя неопределённого метода, а затем вызывает этот метод на проксируемом объекте с переданными параметрами.</p>

<h3>Генерация кода в AUTOLOAD()</h3>

<p></p>

<p>Эта двойная диспетчеризация легка для написания, но неэффективна. Каждый вызов метода на прокси должен провалить нормальную диспетчеризацию, чтобы попасть в <code>AUTOLOAD()</code>. Вы можете заплатить эту цену лишь раз, устанавливая новые методы в прокси-класс по мере того, как они понадобятся программе:</p>

<pre><code>    sub AUTOLOAD
    {
        <strong>my ($name) = our $AUTOLOAD =~ /::(\w+)$/;</strong>

        my $method = sub
        {
            Log::method_call( $name, @_ );

            my $self = shift;
            return $$self-&gt;$name( @_ );
        }

        <strong>no strict &#39;refs&#39;;</strong>
        <strong>*{ $AUTOLOAD } = $method;</strong>
        return $method-&gt;( @_ );
    }</code></pre>

<p>Тело предыдущей функции <code>AUTOLOAD()</code> стало замыканием (<a href="chapter_05.html#closures">Замыкания</a>), привязанным к <em>имени</em> неопределённого метода. Установка этого замыкания в соответствующую таблицу символов позволяет всем последующим обращениям к этому методу найти созданное замыкание (и обойти <code>AUTOLOAD()</code>). Наконец, этот код вызывает метод напрямую и возвращает результат.</p>

<p>Хотя этот подход чище и почти всегда прозрачнее, чем обработка поведения прямо в <code>AUTOLOAD()</code>, код, <em>вызванный</em> <code>AUTOLOAD()</code>, может определить, что обращение прошло через <code>AUTOLOAD()</code>. Короче говоря, <code>caller()</code> будет отображать двойную диспетчеризацию обеих приведённых техник. Хотя забота о том, что это происходит, может быть нарушением инкапсуляции, утечка деталей того, <em>как</em> объект предоставляет метод, тоже может быть нарушением инкапсуляции.</p>

<p> </p>

<p>Некоторый код использует хвостовые вызовы (<a href="chapter_03.html#tailcalls">Хвостовые вызовы</a>) для <em>замены</em> текущего вызова <code>AUTOLOAD()</code> вызовом целевого метода:</p>

<pre><code>    sub AUTOLOAD
    {
        <strong>my ($name) = our $AUTOLOAD =~ /::(\w+)$/;</strong>
        my $method = sub { ... }

        no strict &#39;refs&#39;;
        *{ $AUTOLOAD } = $method;
        <strong>goto &amp;$method;</strong>
    }</code></pre>

<p>Это приводит к тому же эффекту, что и вызов <code>$method</code> напрямую, за исключением того, что <code>AUTOLOAD()</code> не будет появляться в списке вызовов, доступном через <code>caller()</code>, так что это будет выглядеть так, как будто сгенерированный метод был просто вызван напрямую.</p>

<h3>Недостатки AUTOLOAD</h3>

<p><a name="autoload_drawbacks"></p>

<p>     </p>

<p><code>AUTOLOAD()</code> может быть полезным инструментом, хотя его и непросто использовать правильно. Наивный подход к генерированию методов во время исполнения означает, что метод <code>can()</code> не будет выдавать правильную информацию о возможностях объектов и классов. Самое простое решение &mdash; предварительно объявить все функции, которые вы планируете генерировать в <code>AUTOLOAD()</code>, с помощью прагмы <code>subs</code>:</p>

<pre><code>    use subs qw( red green blue ochre teal );</code></pre>

<p>Предварительные объявления могут пригодиться только в двух редких случаях использования атрибутов и автозагрузки (<a href="chapter_05.html#autoload">AUTOLOAD</a>).</p>

<p>Плюсом этой техники является документирование ваших намерений, но недостаток в том, что вам придётся поддерживать статический список функций или методов. Перегрузка <code>can()</code> (<a href="chapter_09.html#universal">Пакет UNIVERSAL</a>) иногда работает лучше:</p>

<pre><code>    sub can
    {
        my ($self, $method) = @_;

        # &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x442;&#x44C; &#x440;&#x435;&#x437;&#x443;&#x43B;&#x44C;&#x442;&#x430;&#x442; &#x440;&#x43E;&#x434;&#x438;&#x442;&#x435;&#x43B;&#x44C;&#x441;&#x43A;&#x43E;&#x433;&#x43E; can()
        my $meth_ref = $self-&gt;SUPER::can( $method );
        return $meth_ref if $meth_ref;

        # &#x434;&#x43E;&#x431;&#x430;&#x432;&#x438;&#x442;&#x44C; &#x444;&#x438;&#x43B;&#x44C;&#x442;&#x440;&#x430;&#x446;&#x438;&#x44E;
        return unless $self-&gt;should_generate( $method );

        $meth_ref = sub { ... };
        no strict &#39;refs&#39;;
        return *{ $method } = $meth_ref;
    }

    sub AUTOLOAD
    {
        my ($self) = @_;
        my ($name) = our $AUTOLOAD =~ /::(\w+)$/;&gt;

        return unless my $meth_ref = $self-&gt;can( $name );
        goto &amp;$meth_ref;
    }</code></pre>

<p><code>AUTOLOAD()</code> &mdash; большой молоток; он может ловить функции и методы, которые вы не собирались автозагружать, такие как <code>DESTROY()</code>, деструктор объектов. Если напишете метод <code>DESTROY</code> без имплементации, Perl с удовольствием направится к нему вместо <code>AUTOLOAD()</code>:</p>

<pre><code>    # &#x43F;&#x440;&#x43E;&#x43F;&#x443;&#x441;&#x442;&#x438;&#x442;&#x44C; AUTOLOAD()
    sub DESTROY {}</code></pre>

<p>Специальные методы <code>import()</code>, <code>unimport()</code> и <code>VERSION()</code> никогда не проходят через <code>AUTOLOAD()</code>.</p>

<p>Если вы смешаете функции и методы в едином пространстве имён, наследующем от другого пакета, имеющего собственную <code>AUTOLOAD()</code>, вы можете увидеть странную ошибку:</p>

<pre><code>  Use of inherited AUTOLOAD for non-method
      <em>slam_door</em>() is deprecated</code></pre>

<p>Если с вами это произошло, упростите свой код; вы вызвали несуществующую функцию в пакете, наследующем от класса, содержащего свою собственную <code>AUTOLOAD()</code>. Проблема состоит из нескольких частей: смешивание функций и методов в одном пространстве имён зачастую является недостатком дизайна, наследование и <code>AUTOLOAD()</code> очень быстро становятся сложными, и делать выводы о коде, когда вы не знаете, какие методы предоставляет объект, трудно.</p>

<p><code>AUTOLOAD()</code> полезна для быстрого и грязного программирования, но надёжный код её избегает.</p>

</body></html>