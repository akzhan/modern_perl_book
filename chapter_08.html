<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="style.css" type="text/css"></head><body><h1>Стиль и эффективность</h1>

<p>Качество имеет значение.</p>

<p>В программах есть ошибки. Программы требуют поддержки и расширения. Над программами работает множество программистов.</p>

<p>Хорошее программирование требует от нас находить баланс между выполнением работы и созданием условий для того, чтобы выполнять её успешно и в будущем. Мы можем менять друг на друга время, ресурсы и качество. То, насколько хорошо мы это делаем, определяет наш уровень как практичных профессионалов.</p>

<p>Понимание Perl важно. Так же как и развитие чувства хорошего вкуса. Единственный способ этого добиться &mdash; практиковаться в поддержке кода и в чтении и написании хорошего кода. На этом пути нет срезов, но есть направляющие ориентиры.</p>

<p><a name="style"></p>

<h2>Написание поддерживаемого кода на Perl</h2>

<p></p>

<p><em>Поддерживаемость</em> &mdash; туманная мера простоты понимания и изменения существующей программы. Оставьте какой-нибудь код в стороне на шесть месяцев, а затем снова к вернитесь нему. Поддерживаемость определяет сложность, с котороый вы встретитесь при внесении изменений.</p>

<p>Поддерживаемость &mdash; не вопрос синтаксиса, как и не мера того, как ваш код будет выглядеть для непрограммиста. Представим компетентного программиста, понимающего суть задачи, которую код должен решать. С какими проблемами он встретится при корректном исправлении бага или добавлении улучшений?</p>

<p>Способность писать поддерживаемый код приходит из заработанного тяжёлым трудом опыта и поддерживается умелым обращением с идиомами, техниками и преобладающим стилем языка. Но даже новички могут улучшить поддерживаемость своего кода, следуя нескольким принципам:</p>

<ul>

<li><em>Избавляйтесь от дублирования.</em> Баги скрываются в кусках повторяющегося и одинакового кода &mdash; когда вы исправите баг в одном месте, исправите ли в другом? Когда вы внесёте изменения в одно место, внесёте ли в другое?</li>

<p>Хорошо спроектированные системы содержат мало дублирования. Они используют функции, модули, объекты и роли для выделения дублирующегося кода в пригодные для повторного использования компоненты, которые точно моделируют предметную область задачи. Самый лучший дизайн позволяет вам добавлять возможности, <em>удаляя</em> код.</p>

<li><em>Правильно именуйте сущности.</em> Ваш код рассказывает историю. Каждый именованный символ &mdash; переменные, функции, модели, классы &mdash; позволяет вам прояснить или затуманить свои намерения. Простота выбора имён показывает ваше понимание проблемы и ваш дизайн. Выбирайте ваши имена тщательно.</li>

<li><em>Избегайте ненужной заумности.</em> Краткий код хорош, если он отражает намерение кода. Заумный код скрывает ваши намерения за яркими трюками. Perl даёт вам возможность писать правильный код в правильное время. Там, где возможно, используйте наиболее очевидное решение. Опыт, хороший вкус и понимание того, что на самом деле важно, будут направлять вас.</li>

<p>Некоторые задачи требуют изощрённых решений. Инкапсулируйте этот код за простым интерфейсом и документируйте свою изощрённость.</p>

<li><em>Поощряйте простоту.</em> При прочих равных, более простую программа легче поддерживать, чем её более сложный аналог. Простота означает понимание того, что наиболее важно, и выполнение ровно этого.</li>

<p>Всё это не может служить извинением попыток увильнуть от обработки ошибок, или модульности, или валидации, или безопасности. Простой код может использовать продвинутые возможности. Простой код может применять огромные залежи CPAN-модулей. Простой код может требовать некоторого труда для его понимания. Однако простой код решает проблемы эффективно, без выполнения ненужной работы.</p>

<p>Иногда вам требуется мощный, надёжный код. Иногда вам требуется однострочник. Простота означает понимание разницы и создание только того, что вам нужно.</p>

</ul>

<h2>Написание идиоматического кода на Perl</h2>

<p></p>

<p>Perl свободно заимствует у других языков. Perl позволяет вам писать код так, как вы хотите его писать. Программисты на C зачастую пишут на Perl в стиле C, также как Java-программисты пишут на Perl в стиле Java. Эффективные Perl-программисты пишут на Perl в стиле Perl, включая применение идиом языка.</p>

<ul>

<li><em>Понимайте мудрость сообщества.</em> Perl-программисты зачастую ведут яростные дебаты о разных техниках. Кроме того, Perl-программисты часто делятся результатами своего труда, и не только в CPAN. Обращайте на это внимание и просвещайтесь в области компромиссов между разными идеалами и стилями.</li>

<p>CPAN-разработчики, Perl-монгеры и участники списков рассылок обладают заработанным тяжёлым трудом опытом в решении задач мириадами разных способов. Говорите с ними. Читайте их код. Задавайте вопросы. Учитесь у них и давайте им учиться у вас.</p>

<p>  </p>

<li><em>Следуйте нормам сообщества.</em> Perl &mdash; сообщество инструментальщиков. Мы выполняем широкий круг задач, включая статический анализ кода (<code>Perl::Critic</code>), переформатирование (<code>Perl::Tidy</code>) и частные системы распространения (<code>CPAN::Mini</code>). Пользуйтесь инфраструктурой CPAN; следуйте модели CPAN в написании, документировании, сборке, тестировании и распространении вашего кода.</li>

<li><em>Читайте код.</em> Присоединяйтесь к спискам рассылок, таким как Perl Beginners (http://learn.perl.org/faq/beginners.html), просматривайте PerlMonks (http://perlmonks.org/) и другими способами погружайтесь в сообщество (footnote: См. http://www.perl.org/community.html.). Читайте код и пытайтесь отвечать на вопросы &mdash; даже если вы сами никогда их не задаёте, это отличная возможность учиться.</li>

</ul>

<h2>Написание эффективного кода на Perl</h2>

<p></p>

<p>Поддерживаемость &mdash; в конечном счёте, вопрос дизайна. Хороший дизайн приходит с практикой полезных привычек:</p>

<ul>

<li><em>Пишите тестируемый код.</em> Написание эффективного набора тестов упражняет те же самые навыки дизайна, что и написание эффективного кода. Код есть код. Кроме того, хорошие тесты дают вам при модификации программы уверенность в том, что она продолжает работать правильно.</li>

<li><em>Разбивайте на модули.</em> Обеспечивайте соблюдение границ инкапсуляции и абстракции. Находите правильные интерфейсы между компонентами. Правильно именуйте сущности и помещайте их туда, где им место. Модульность заставляет вас размышлять об абстракциях в ваших программах для понимания того, как всё это работает вместе. Находите куски, которые не вписываются. Улучшайте свой код до тех пор, пока они не впишутся.</li>

<li><em>Следуйте разумным стандартам кодирования.</em> Эффективные руководства определяют обработку ошибок, безопасность, инкапсуляцию, дизайн API, план проекта и другие вопросы поддерживаемости. Отличные руководства помогают разработчикам общаться друг с другом через код. Вы выполняете задачи. Говорите чётко.</li>

<li><em>Используйте CPAN.</em> Perl-программисты решают задачи. Затем мы делимся полученными решениями. Пользуйтесь этим увеличителем силы. Сначала поищите в CPAN решение или частичное решение вашей проблемы. Инвестируйте время в исследования; оно окупится.</li>

<p>Если вы найдёте баг, сообщите о нём. Предложите патч, если возможно. Исправьте опечатку. Попросите реализовать возможность. Скажите &laquo;Спасибо!&raquo;. Вместе мы лучше, чем по отдельности. Мы сильны и эффективны, если повторно используем код.</p>

<p>Когда вы готовы, когда вы решили новую задачу, поделитесь решением. Присоединяйтесь к нам. Мы решаем задачи.</p>

</ul>

<h2>Исключения</h2>

<p><a name="exceptions"> </p>

<p>Программировать хорошо означает предвидеть неожиданное. Файлы, которые должны существовать, не существуют. Этот огромный диск, который никогда не заполнится, оказывается полным. Всегда доступная сеть не доступна. Неломающиеся базы данных ломаются. Исключения случаются, и надёжное программное обеспечение должно их обрабатывать. Если вы можете восстановиться, отлично! Если не можете, запишите нужную информацию в лог и повторите попытку.</p>

<p>Pelr 5 обрабатывает исключительные ситуации с помощью <em>исключений</em>: механизм потока управления динамической области видимости, разработанный для генерации и обработки ошибок.</p>

<h3>Выбрасывание исключений</h3>

<p><a name="throwing_exceptions"></p>

<p>Предположим, вы хотите записать в лог файл. Если вы не смогли открыть файл, что-то пошло не так. Используйте <code>die</code> чтобы выбросить исключение:</p>

<pre><code>    sub open_log_file
    {
        my $name = shift;
        open my $fh, &#39;&gt;&gt;&#39;, $name
            <strong>or die &quot;Can&#39;t open logging file &#39;$name&#39;: $!&quot;;</strong>
        return $fh;
    }</code></pre>

<p>     </p>

<p><code>die()</code> устанавливает значение своего операнда в глобальную переменную <code>$@</code> и немедленно выходит из текущей функции, <em>ничего не возвращая</em>. Это выброшенное исключение будет подниматься по стеку вызовов (<a href="chapter_10.html#controlled_execution">Контроллируемое выполнение</a>) до тех пор, пока не будет где-нибудь поймано. Если исключение не будет поймано нигде, программа завершится с ошибкой.</p>

<p>Обработка исключений использует ту же самую динамическую область видимости (<a href="chapter_05.html#dynamic_scope">Динамическая область видимости.</a>), что и символы, объявленные с помощью <code>local</code>.</p>

<h3>Отлавливание исключений</h3>

<p><a name="catching_exceptions"></p>

<p></p>

<p>Иногда исключение, приводящее к выходу из программы, удобно. Программа, выполняемая как синхронизированный процесс, может выбросить исключение, если логи ошибок заполнены, что приведёт к отправке SMS администраторам. Однако, не все исключения должны быть фатальными. От некоторых из них хорошие программы должны уметь восстанавливаться, или по крайней мере сохранять текущее состояние и завершаться чисто.</p>

<p> </p>

<p>Используйте блочную форму оператора <code>eval</code> чтобы поймать исключение:</p>

<pre><code>    # &#x43B;&#x43E;&#x433;-&#x444;&#x430;&#x439;&#x43B; &#x43C;&#x43E;&#x436;&#x435;&#x442; &#x43D;&#x435; &#x43E;&#x442;&#x43A;&#x440;&#x44B;&#x442;&#x44C;&#x441;&#x44F;
    my $fh = eval { open_log_file( &#39;monkeytown.log&#39; ) };</code></pre>

<p>Если файл успешно открыт, <code>$fh</code> будет содержать дескриптор файла. Если нет, <code>$fh</code> останется неопределённой и выполнение программы продолжится.</p>

<p>Блочный аргумента <code>eval</code> вводит новую область видимости, и лексическую, и динамическую. Если <code>open_log_file()</code> вызывает другие функции, и какая-нибудь из них в конечном счёте выбросила исключение, этот <code>eval</code> его поймает.</p>

<p></p>

<p>Обработка исключений &mdash; грубый инструмент. Он будет ловить все исключения в своей динамической области видимости. Чтобы проверить, какое исключение вы поймали (и поймали ли вообще), проверьте значение <code>$@</code>. Убедитесь, что локализовали <code>$@</code> с помощью <code>local</code>, прежде чем попытаться поймать исключение; помните, что <code>$@</code> &mdash; глобальная переменная:</p>

<pre><code>    <strong>local $@;</strong>

    # &#x43B;&#x43E;&#x433;-&#x444;&#x430;&#x439;&#x43B; &#x43C;&#x43E;&#x436;&#x435;&#x442; &#x43D;&#x435; &#x43E;&#x442;&#x43A;&#x440;&#x44B;&#x442;&#x44C;&#x441;&#x44F;
    my $fh = eval { open_log_file( &#39;monkeytown.log&#39; ) };

    # &#x43F;&#x43E;&#x439;&#x43C;&#x430;&#x43D;&#x43E; &#x438;&#x441;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x438;&#x435;
    <strong>if (my $exception = $@) { ... }</strong></code></pre>

<p></p>

<p>Сразу же скопируйте <code>$@</code> в лексическую переменную, чтобы избежать возможности того, что последующий код перезапишет глобальную переменную <code>$@</code>. Вы никогда не знаете, что ещё могло использовать блок <code>eval</code> в каком-нибудь другом месте и сбросить <code>$@</code>.</p>

<p><code>$@</code> обычно содержит строку, описывающую исключение. Проверьте её содержимое, чтобы увидеть, можете ли вы обработать исключение:</p>

<pre><code>    if (my $exception = $@)
    {
        die $exception
            unless $exception =~ /^Can&#39;t open logging/;
        $fh = log_to_syslog();
    }</code></pre>

<p>Пробросьте исключение, снова вызвав <code>die()</code>. Передайте существующее исключение или новое, в зависимости от необходимости.</p>

<p></p>

<p>Применение к строковым исключениям регулярных выражений может быть ненадёжным, потому что сообщения об ошибках могут со временем меняться. Это относится и к внутренним исключениям, которые выбрасывает сам Perl. К счастью, вы можете также передавать в <code>die</code> ссылку &mdash; даже благословлённую ссылку. Это позволяет вам предоставлять в вашем исключении гораздо больше информации: номера строк, файлы и другую отладочную информацию. Получение этой информации из чего-то структурированного намного легче, чем разбор строки. Ловите эти исключения так же, как любые другие.</p>

<p> </p>

<p>CPAN-дистрибутив <code>Exception::Class</code> упрощает создание и использование объектов-исключений:</p>

<pre><code>    package Zoo::Exceptions
    {
        use Exception::Class
            &#39;Zoo::AnimalEscaped&#39;,
            &#39;Zoo::HandlerEscaped&#39;;
    }

    sub cage_open
    {
        my $self = shift;
        Zoo::AnimalEscaped-&gt;throw
            unless $self-&gt;contains_animal;
        ...
    }

    sub breakroom_open
    {
        my $self = shift;
        Zoo::HandlerEscaped-&gt;throw
            unless $self-&gt;contains_handler;
        ...
    }</code></pre>

<h3>Предостережения об исключениях</h3>

<p><a name="exception_caveats"></p>

<p></p>

<p>Хотя выбрасывание исключений относительно просто, ловить их сложнее. Корректное использование <code>$@</code> требует от вас обходить некоторые неочевидные риски:</p>

<ul>

<li>Нелокализованное с помощью <code>local</code> использование дальше в динамической области видимости может модифицировать <code>$@</code></li>

<li>Она может содержать объкт, перегружающий своё булево значение для возврата ложного значения</li>

<li>Обработчик сигнала (особенно обработчик сигнала <code>DIE</code>) может изменять <code>$@</code></li>

<li>Уничтожение объекта при выходе из области видимости может вызывать <code>eval</code> и изменять <code>$@</code></li>

</ul>

<p> </p>

<p>Perl 5.14 исправил некоторые из этих проблем. Признаем, они встречаются очень редко, но зачастую сложны для диагностики и исправления. CPAN-дистрибутив <code>Try::Tiny</code> улучшает безопасность обработки исключений <em>и</em> синтаксис (footnote: На самом деле, <code>Try::Tiny</code> помог вдохновить на улучшения в обработке исключений в Perl 5.14.).</p>

<p><code>Try::Tiny</code> прост в использовании:</p>

<pre><code>    use Try::Tiny;

    my $fh = try   { open_log_file( &#39;monkeytown.log&#39; ) }
             catch { log_exception( $_ ) };</code></pre>

<p><code>try</code> заменяет <code>eval</code>. Необязательный блок <code>catch</code> выполняется, только если <code>try</code> поймал исключение. <code>catch</code> получает пойманное исключение как переменную-топик <code>$_</code>.</p>

<h3>Встроенные исключения</h3>

<p><a name="builtin_exceptions"></p>

<p></p>

<p>Сам Perl 5 выбрасывает несколько исключительных условий. <code>perldoc perldiag</code> перечисляет несколько &laquo;отлавливаемых фатальных ошибок&raquo;. Тогда как часть из них &mdash; синтаксические ошибки, выбрасываемые в процессе компиляции, другие вы можете поймать во время выполнения. Наиболее интересны следующие:</p>

<ul>

<li>Using a disallowed key in a locked hash (использование недопустимого ключа в заблокированном хеше) (<a href="chapter_03.html#locked_hashes">Блокировка хешей</a>)</li>

<li>Blessing a non-reference (Благословление не-ссылки) (<a href="chapter_07.html#blessed_references">Благословлённые ссылки</a>)</li>

<li>Calling a method on an invalid invocant (вызов метода на некорректном инвоканте) (<a href="chapter_07.html#moose">Moose</a>)</li>

<li>Failing to find a method of the given name on the invocant (не удалось обнаружить метод с заданным именем в инвоканте)</li>

<li>Using a tainted value in an unsafe fashion (небезопасное использование испорченного значения) (<a href="chapter_09.html#taint">Испорченность</a>)</li>

<li>Modifying a read-only value (модификация значения, доступного только для чтения)</li>

<li>Performing an invalid operation on a reference (выполнение недопустимой операции над ссылкой) (<a href="chapter_03.html#references">Ссылки</a>)</li>

</ul>

<p></p>

<p>Конечно, вы также можете ловить исключения, производимые <code>autodie</code> (<a href="chapter_12.html#autodie">Прагма autodie</a>), и любые лексические предупреждения, повышенные до исключений (<a href="chapter_09.html#registering_warnings">Регистрация своих собственных предупреждений</a>).</p>

<h2>Прагмы</h2>

<p><a name="pragmas"></p>

<p> </p>

<p>Большинство расширений Perl 5 &mdash; модули, предоставляющие новые функции или определяющие классы (<a href="chapter_07.html#moose">Moose</a>). Некоторые же модули вместо этого влияют на поведение самого языка, как <code>strict</code> или <code>warnings</code>. Такие модули называют <em>прагмами</em>. По соглашению прагмы имеют имена в нижнем регистре, чтобы отличить их от других модулей.</p>

<h3>Прагмы и область видимости</h3>

<p></p>

<p>Прагмы работают посредством экспорта определённого поведения или информации в лексические области видимости вызывающего их кода. Так же как объявление лексической переменной делает символическое имя доступным в пределах области видимости, использование прагм делает их поведение действующим в пределах этой области видимости:</p>

<pre><code>    {
        # $lexical <strong>&#x43D;&#x435;&#x432;&#x438;&#x434;&#x438;&#x43C;&#x430;</strong>; strict <strong>&#x43D;&#x435; &#x434;&#x435;&#x439;&#x441;&#x442;&#x432;&#x443;&#x435;&#x442;</strong>
        {
            use strict;
            my $lexical = &#39;available here&#39;;
            # $lexical <strong>&#x432;&#x438;&#x434;&#x438;&#x43C;&#x430;</strong>; strict <strong>&#x434;&#x435;&#x439;&#x441;&#x442;&#x432;&#x443;&#x435;&#x442;</strong>
            ...
        }
        # $lexical &#x441;&#x43D;&#x43E;&#x432;&#x430; &#x43D;&#x435;&#x432;&#x438;&#x434;&#x438;&#x43C;&#x430;; strict <strong>&#x43D;&#x435;</strong> &#x434;&#x435;&#x439;&#x441;&#x442;&#x432;&#x443;&#x435;&#x442;
    }</code></pre>

<p>Также как лексические объявления воздействуют на внутренние области видимости, прагмы сохраняют свой эффект во внутренних областях видимости:</p>

<pre><code>    # &#x43E;&#x431;&#x43B;&#x430;&#x441;&#x442;&#x44C; &#x432;&#x438;&#x434;&#x438;&#x43C;&#x43E;&#x441;&#x442;&#x438; &#x444;&#x430;&#x439;&#x43B;&#x430;
    use strict;

    {
        # &#x432;&#x43D;&#x443;&#x442;&#x440;&#x435;&#x43D;&#x43D;&#x44F;&#x44F; &#x43E;&#x431;&#x43B;&#x430;&#x441;&#x442;&#x44C; &#x432;&#x438;&#x434;&#x438;&#x43C;&#x43E;&#x441;&#x442;&#x438;, &#x43D;&#x43E; strict &#x432;&#x441;&#x451; &#x435;&#x449;&#x451; &#x434;&#x435;&#x439;&#x441;&#x442;&#x432;&#x443;&#x435;&#x442;
        my $inner = &#39;another lexical&#39;;
        ...
    }</code></pre>

<h3>Использование прагм</h3>

<p></p>

<p>Подключайте прагмы с помощью <code>use</code>, как и любой другой модуль. Прагмы принимают аргументы, такие как минимальный номер используемой версии и список аргументов для изменения поведения прагмы:</p>

<pre><code>    # &#x442;&#x440;&#x435;&#x431;&#x443;&#x435;&#x442; &#x43E;&#x431;&#x44A;&#x44F;&#x432;&#x43B;&#x435;&#x43D;&#x438;&#x44F; &#x43F;&#x435;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x44B;&#x445;, &#x437;&#x430;&#x43F;&#x440;&#x435;&#x449;&#x430;&#x435;&#x442; &#x433;&#x43E;&#x43B;&#x44B;&#x435; &#x441;&#x43B;&#x43E;&#x432;&#x430;
    use strict qw( subs vars );</code></pre>

<p> </p>

<p>Иногда вам нужно <em>отключить</em> все или часть этих эффектов в глубже вложенной лексической области видимости. Встроенная директива <code>no</code> отменяет импорт (<a href="chapter_05.html#importing">Импорт</a>), что отменяет эффекты правильно работающих прагм. Например, так можно отключить защиту <code>strict</code>, если вам нужно сделать что-нибудь символьное:</p>

<pre><code>    use Modern::Perl;
    # &#x438;&#x43B;&#x438; use strict;

    {
        no strict &#39;refs&#39;;
        # &#x437;&#x434;&#x435;&#x441;&#x44C; &#x43C;&#x43E;&#x436;&#x43D;&#x43E; &#x43C;&#x430;&#x43D;&#x438;&#x43F;&#x443;&#x43B;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x442;&#x44C; &#x441;&#x438;&#x43C;&#x432;&#x43E;&#x43B;&#x44C;&#x43D;&#x43E;&#x439; &#x442;&#x430;&#x431;&#x43B;&#x438;&#x446;&#x435;&#x439;
    }</code></pre>

<h3>Полезные прагмы</h3>

<p> </p>

<p>Perl 5.10.0 добавил возможность писать свои собственные лексические прагмы в виде кода на чистом Perl. <code>perldoc perlpragma</code> объясняет как это делать, а описание <code>$^H</code> в <code>perldoc perlvar</code> объясняет, как эта возможность работает.</p>

<p></p>

<p>Но и до 5.10 Perl 5 включал несколько полезных встроенных прагм.</p>

<p></p>

<ul>

<li>прагма <code>strict</code> включает проверку компилятором символических ссылок, использования голых слов и объявлений переменных.</li>

<p></p>

<li>прагма <code>warnings</code> включает опциональные предупреждения о нерекомендуемых, непреднамеренных и неудачных поведений.</li>

<p></p>

<li>прагма <code>utf8</code> заставляет парсер воспринимать исходный код как имеющий кодировку UTF-8.</li>

<p></p>

<li>прагма <code>autodie</code> включает автоматическую проверку ошибок системных вызовов и встроенных функций.</li>

<p></p>

<li>прагма <code>constant</code> позволяет вам создавать константные значения времени компиляции (см. <code>Const::Fast</code> CPAN в качестве альтернативы).</li>

<p></p>

<li>прагма <code>vars</code> позволяет вам объявлять глобальные переменные пакета, такие как <code>$VERSION</code> или <code>@ISA</code> (<a href="chapter_07.html#blessed_references">Благословлённые ссылки</a>).</li>

<p></p>

<li>прагма <code>feature</code> позволяет вам отдельно включать и отключать возможности Perl 5, появившиеся после 5.10. Как <code>use 5.14;</code> включает все возможности Perl 5.14 и прагму <code>strict</code>, так и <code>use feature ':5.14';</code> делает то же самое. Эта прагма более полезна для <em>отключения</em> отдельных возможностей в лексической области видимости.</li>

<p></p>

<li>прагма <code>less</code> демонстрирует, как написать прагму.</li>

</ul>

<p>CPAN начал собирать невстроенные прагмы:</p>

<p>   </p>

<ul>

<li><code>autobox</code> включает объектоподобное поведение для встроенных типов Perl 5 (скаляров, ссылок, массивов и хешей).</li>

<li><code>perl5i</code> собирает и включает многие экспериментальные расширения языка в одно целое.</li>

<li><code>autovivification</code> отключает автовивификацию (<a href="chapter_03.html#autovivification">Автовивификация</a>)</li>

<li><code>indirect</code> предотвращает использование непрямых вызовов (<a href="chapter_11.html#indirect_objects">Непрямые объекты</a>)</li>

</ul>

<p>Эти инструменты пока не имеют широкого использования. Два последних могут помочь вам писать более корректный код, тогда как с двумя предыдущими стоит поэкспериментировать в небольших проектах. Они показывают, чем мог бы быть Perl 5.</p>

</body></html>