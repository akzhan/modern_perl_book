<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="style.css" type="text/css"></head><body><h1>Философия Perl</h1>

<p>Perl позволяет добиваться результата &mdash; он гибкий, прощающий и пластичный. Умелые программисты используют его каждый день для любых задач &mdash; от однострочников и разовых автоматизаций, до многолетних проектов, выполняемых множеством программистов.</p>

<p>Perl прагматичен. Вы &mdash; главный. Вы выбираете, как решать ваши проблемы, и Perl действует в соответствии с вашими намерениями, без фрустраций и церемоний.</p>

<p>Perl будет расти вместе с вами. В течение следующего часа вы узнаете достаточно, чтобы писать реальные полезные программы &mdash; и вы поймёте, <em>как</em> работает язык, и <em>почему</em> он работает именно так. Современный Perl применяет это знание и объединённый опыт глобального Perl-сообщества, чтобы помочь вам писать работающий, поддерживаемый код.</p>

<p>Для начала, вы должны понять, как узнать больше.</p>

<h2>Perldoc</h2>

<p><a name="perldoc"></p>

<p></p>

<p>Perl обладает культурой полезной документации. Утилита <code>perldoc</code> &mdash; часть любой полной инсталляции Perl 5 (footnote: Однако, ваша Unix-подобная система может потребовать установки дополнительного пакета, такого как <code>perl-doc</code> в Debian или Ubuntu GNU/Linux.). <code>perldoc</code> отображает документацию для каждого установленного в системе Perl-модуля &mdash; будь это базовый модуль или установленный из CPAN (Comprehensive Perl Archive Network, Всеобъемлющая архивная сеть Perl) &mdash; а также тысячи страниц обширной встроенной документации Perl.</p>

<blockquote>

<p> </p>

<p>На сайте http://perldoc.perl.org/ размещены свежие версии документации Perl. Индексы CPAN на http://search.cpan.org/ и http://metacpan.org/ предоставляют документацию по всем модулям CPAN. Другие дистрибутивы Perl 5, такие как ActivePerl и Strawberry Perl, предоставляют локальную документацию в формате HTML.</p>

</blockquote>

<p>Используйте <code>perldoc</code> для чтения документации по модулю или части базовой документации:</p>

<pre><code>    $ <strong>perldoc List::Util</strong>
    $ <strong>perldoc perltoc</strong>
    $ <strong>perldoc Moose::Manual</strong></code></pre>

<p>Первый пример отображает документацию, встроенную в модуль <code>List::Util</code>. Второй пример отображает отдельный файл документации, в данном случае &mdash; оглавление базовой документации. Третий пример отображает отдельный файл документации, являющийся частью CPAN-дистрибутива (<a href="chapter_07.html#moose">Moose</a>). <code>perldoc</code> скрывает эти детали; нет никакой разницы между чтением документации по базовой библиотеке, такой как <code>Data::Dumper</code>, или по установленой из CPAN.</p>

<p>Стандартный шаблон документации включает описание модуля, демонстрацию примеров использования, и затем &mdash; детальное разъяснение модуля и его интерфейса. Объём документации различается у разных авторов, но её форма поразительно последовательна.</p>

<p><code>perldoc perltoc</code> выводит оглавление базовой документации, а <code>perldoc perlfaq</code> &mdash; оглавление часто задаваемых вопросов (Frequently Asked Questions, FAQ) о Perl 5. <code>perldoc perlop</code> и <code>perldoc perlsyn</code> документируют символьные операторы и синтаксические конструкции Perl. <code>perldoc perldiag</code> объясняет значение предупреждающих сообщений Perl 5. <code>perldoc perlvar</code> содержит список всех символьных переменных Perl. Ознакомление с этими файлами даст вам отличный общий обзор Perl 5.</p>

<p></p>

<p>Утилита <code>perldoc</code> имеет много других возможностей (см. <code>perldoc perldoc</code>). Опция <code>-q</code> осуществляет поиск указанных ключевых слов по Perl FAQ. Так <code>perldoc -q sort</code> возвращает три вопроса: <em>How do I sort an array by (anything)?</em> (<em>Как мне отсортировать массив по (чему бы то ни было)?</em>), <em>How do I sort a hash (optionally by value instead of key)?</em> (<em>Как мне отсортировать хеш (опционально по значению вместо ключа)?</em>), и <em>How can I always keep my hash sorted?</em> (<em>Как мне всегда поддерживать мой хеш отсортированным?</em>).</p>

<p></p>

<p>Опция <code>-f</code> выводит документацию по встроенным функциям Perl. <code>perldoc -f sort</code> объясняет поведение оператора <code>sort</code>. Если вы не знаете имени нужной вам функции, просмотрите список доступных встроенных функций в <code>perldoc perlfunc</code>.</p>

<p></p>

<p>Опция <code>-v</code> ищет встроенную переменную. Например, <code>perldoc -v $PID</code> выводит документацию по переменной, содержащей идентификатор процесса текущей программы. В зависимости от вашей оболочки, вам, возможно, придётся соответствующим образом заключить переменную в кавычки.</p>

<p>Опция <code>-l</code> заставляет <code>perldoc</code> вывести <em>путь</em> к файлу документации вместо его содержимого (footnote: Имейте ввиду, что модуль может иметь отдельный файл <em>.pod</em> в придачу к файлу <em>.pm</em>).</p>

<p>Опция <code>-m</code> отображает полное <em>содержимое</em> модуля, код и всё остальное, не выполняя никакого специального форматирования.</p>

<p>    </p>

<p>Система документации в Perl 5 &mdash; <em>POD</em>, или <em>Plain Old Documentation</em> (<em>Старая добрая документация</em>). <code>perldoc perlpod</code> описывает, как работает POD. В число других инструментов для работы с POD входят <code>podchecker</code>, который проверяет корректность формы вашей POD-документации, и <code>Pod::Webserver</code>, отображающий локальную POD-документацию в виде HTML через минимальный веб-сервер.</p>

<h2>Выразительность</h2>

<p><a name="expressivity"></p>

<p> </p>

<p>Изучение Ларри Уоллом (Larry Wall) лингвистики и естественных языков повлияло на дизайн Perl. Язык предоставляет вам потрясающую свободу в решении ваших задач, в зависимости от вашего коллективного стиля, имеющегося времени, ожидаемого срока жизни программы или даже вашего вдохновения. Вы можете писать простой, прямолинейный код, или интегрировать его в большие, чётко структурированные программы. Вы можете выбирать из множества парадигм дизайна, можете избегать или приветствовать использование дополнительных возможностей.</p>

<p>Там, где другие языки навязывают один оптимальный способ написания кода, Perl позволят <em>вам</em> решать, какой вариант более читаемый, или полезный, или весёлый.</p>

<p> </p>

<p>У Perl-хакеров есть девиз для этого: <em>TIMTOWTDI</em>, произносится как &laquo;Tim Toady&raquo; (&laquo;Тим Тоуди&raquo;), или &laquo;There's more than one way to do it!&raquo; (&laquo;Есть более чем один способ сделать это!&raquo;).</p>

<p>Хотя эта выразительность позволяет мастерам создавать изумительные программы, она же позволяет неблагоразумным и неосторожным устраивать беспорядок. Опыт и хороший вкус приведут вас к написанию хорошего кода. Выбор за вами &mdash; но не забывайте о читаемости и поддерживаемости, особенно для тех, кто придёт после вас.</p>

<p>Новички в Perl зачастую могут найти некоторые конструкции трудными для понимания. Многие из этих идиом (<a href="chapter_10.html#idioms">Идиомы</a>) предлагают большую (хотя и неочевидную) мощь. Вполне нормально избегать их, пока вы не будете чувствовать себя с ними комфортно.</p>

<p>Изучение Perl подобно изучению нового разговорного языка. Вы изучите несколько слов, составите предложения и вскоре будете наслаждаться простыми беседами. Мастерство приходит с практикой чтения и написания. Вам не обязательно понимать каждую деталь Perl, чтобы быть продуктивным, но принципы, изложенные в этой главе, жизненно важны для вашего роста как программиста.</p>

<p>Ещё одна цель дизайна Perl состоит в том, чтобы пытаться избегать того, что может удивить опытных (Perl) программистов. Например, сложение двух переменных (<code>$first_num + $second_num</code>) очевидно числовая операция (<a href="chapter_04.html#numeric_operators">Числовые операторы</a>); оператор сложения должен воспринимать обе переменные как числовые значения, чтобы получить числовой результат. Независимо от содержимого <code>$first_num</code> и <code>$second_num</code>, Perl преобразует их в числовые значения (<a href="chapter_03.html#numeric_coercion">Числовое приведение типов</a>). Вы выразили своё намерение работать с ними как с числами, использовав числовой оператор. Perl с удовольствием сделает это.</p>

<p> </p>

<p>Адепты Perl часто называют этот принцип <em>DWIM</em>, или <em>do what I mean</em> (<em>делай то, что я имею ввиду</em>). Иначе говоря, Perl следует <em>принципу наименьшего удивления</em>. Имея поверхностное понимание Perl (особенно контекста, <a href="chapter_01.html#context_philosophy">Контекст</a>), должно быть возможно понять смысл незнакомого выражения. Вы разовьёте этот навык.</p>

<p></p>

<p>Выразительность Perl, кроме того, позволяет новичкам писать полезные программы без необходимости понимать всё. Получающийся код часто называют <em>baby Perl</em> (<em>детский Perl</em>), в том смысле, что почти каждый хочет помочь детям научиться хорошо говорить. Каждый начинает как новичок. Практикуясь и обучаясь у более опытных программистов, вы будете понимать и воспринимать более мощные идиомы и техники.</p>

<p>Например, опытный Perl-хакер может утроить список чисел таким образом:</p>

<pre><code>    my @tripled = map { $_ * 3 } @numbers;</code></pre>

<p>&hellip;а знаток Perl может написать так:</p>

<pre><code>    my @tripled;

    for my $num (@numbers)
    {
        push @tripled, $num * 3;
    }</code></pre>

<p>&hellip;тогда как новичок попытается сделать следующее:</p>

<pre><code>    my @tripled;

    for (my $i = 0; $i &lt; scalar @numbers; $i++)
    {
        $tripled[$i] = $numbers[$i] * 3;
    }</code></pre>

<p>Все три подхода делают одно и то же, но каждый использует Perl по-своему.</p>

<p>Опыт в программировании на Perl поможет вам фокусироваться на том, <em>что</em> вам нужно, а не на том, <em>как</em> это сделать. В любом случае, Perl с удовольствием будет выполнять простые программы. Вы можете разрабатывать и усовершенствовать ваши программы для повышения ясности, выразительности, пригодности к повторному использованию и поддерживаемости, частично или целиком. Пользуйтесь преимуществами этой гибкости и прагматизма: намного лучше выполнить вашу задачу эффективно сейчас, чем написать концептуально чистую и красивую программу в следующем году.</p>

<h2>Контекст</h2>

<p><a name="context_philosophy"></p>

<p></p>

<p>В разговорных языка значение слова или фразы может зависеть от того, как вы их используете; локальный <em>контекст</em> помогает прояснить намерение. Например, несоответствующее употребление множественного числа во фразе &laquo;Please give me one hamburgers!&raquo; (footnote: множественное число существительного не соответствует количеству.) звучит неправильно, так же как неправильный пол в &laquo;la gato&raquo; (footnote: Артикль женского рода, тогда как существительное &mdash; мужского.) заставляет носителей языка посмеиваться. Примите также во внимание местоимение &laquo;you&raquo; или существительное &laquo;sheep&raquo;, которое может единственным или множественным числом в зависимости от контекста.</p>

<p>Контекст в Perl сходен. Он определяет как количесто, так и вид используемых данных. Perl охотно попытается предоставить именно то, чего вы просите &mdash; при условии, если вы это делаете, выбирая соответствующий контекст.</p>

<p>Некоторые операции в Perl ведут себя по-разному в случаях, когда вы хотите получить ноль, один или несколько результатов. Конкретная конструкция в Perl в случае, если вы напишете &laquo;Сделай это, но результаты меня не волнуют&raquo;, может делать нечто совершенно другое по сравнению с &laquo;Сделай это, и я ожидаю получить несколько результатов&raquo;. Другие операции позволяют вам определённо указать, предполагаете ли вы работать с числовыми данными, текстовыми данными, или данными, содержащими &laquo;истину&raquo; или &laquo;ложь&raquo;.</p>

<p>Контекст может быть коварным если вы пытаетесь писать или читать код на Perl как серию единичных выражений в отрыве от их окружения. Вы можете обнаружить себя хлопающим по лбу после долгой сессии отладки, когда выясните, что ваши предположения относительно контекста были неверны. Если же напротив вы осознаёте контекст, ваш код будет более правильным &mdash; а также более чистым, гибким и лаконичным.</p>

<h3>Пустой, скалярный и списочный контекст</h3>

<p><a name="amount_context"></p>

<p> </p>

<p><em>Контекст количества</em> определяет, <em>сколько</em> элементов вы ожидаете получить от операции. Близкая параллель &mdash; согласование числа между субъектом и глаголом в английском языке. Даже не зная формального определения этого лингвистического принципа, вы, вероятно, поймёте ошибку в предложении &laquo;Perl are a fun language&raquo;. В Perl количество элементов, которое вы запросите, определяет, сколько вы получите.</p>

<p> </p>

<p>Предположим, у вас есть функция (<a href="chapter_05.html#functions">Объявление функций</a>) под названием <code>find_chores()</code>, которая сортирует ваш список домашних дел по приоритету задач. Способ, которым вы вызовете эту функцию, определяет, что она будет делать. У вас можете не быть времени что либо делать, в этом случае вызов функции &mdash; это просто попытка выглядеть работящим. У вас может быть достаточно времени для выполнения одной задачи, или, может быть, у вас взрыв энергии в свободный выходной, и вы хотите выполнить как можно больше.</p>

<p>Если вы просто вызовете функция и никак не используете возвращаемое ей значение, вы вызвали функцию в <em>пустом контексте</em>:</p>

<pre><code>    find_chores();</code></pre>

<p> </p>

<p>Присвоение возвращаемого функцией значения единственному элементу (<a href="chapter_03.html#scalars">Скаляры</a>) вычисляет функцию в <em>скалярном контексте</em>:</p>

<pre><code>    my $single_result = find_chores();</code></pre>

<p> </p>

<p>Присвоение результатов вызова функции массиву (<a href="chapter_03.html#arrays">Массивы</a>) или списку, или использование её в списке, вычисляет функцию в <em>списочном контексте</em>:</p>

<pre><code>    my @all_results             = find_chores();
    my ($single_element, @rest) = find_chores();
    process_list_of_results( find_chores() );</code></pre>

<p>Скобки во второй строке предыдущего примера группируют объявление двух переменных (<a href="chapter_05.html#lexical_scope">Лексическая область видимости</a>), чтобы присвоение вело себя так, как вы ожидаете. Если переменная <code>@rest</code> не используется, вы можете написать и так:</p>

<pre><code>    my <strong>(</strong>$single_element<strong>)</strong>   = find_chores();</code></pre>

<p>&hellip;в этом случае скобки поясняют парсеру Perl 5, что вы подразумеваете списочный контекст для присваивания, несмотря на то, что присваиваете только одному элементу списка. Это неочевидно, но теперь, когда вы знаете об этом, различие контекста количества между этими двумя выражениями должно быть ясно:</p>

<pre><code>    my $scalar_context = find_chores();
    my <strong>(</strong>$list_context<strong>)</strong> = find_chores();</code></pre>

<p>Вычисление функции или выражения &mdash; исключая присваивание &mdash; в списочном контексте может вызвать путаницу. Списки распространяют списочный контекст на выражения, которые они содержат. Оба этих вызова <code>find_chores()</code> происходят в списочном контексте:</p>

<pre><code>    process_list_of_results( find_chores() );

    my %results =
    (
        cheap_operation     =&gt; $cheap_results,
        expensive_operation =&gt; find_chores(), # &#x423;&#x41F;&#x421;!
    );</code></pre>

<p></p>

<p>Последний пример часто удивляет начинающих программистов, так как инициализация хеша (<a href="chapter_03.html#hashes">Хеши</a>) списком значений налагает списочный контекст на <code>find_chores</code>. Используйте оператор <code>scalar</code> для наложения скалярного контекста:</p>

<pre><code>    my %results =
    (
        cheap_operation     =&gt; $cheap_results,
        expensive_operation =&gt; <strong>scalar</strong> find_chores(),
    );</code></pre>

<p>Почему контекст важен? Зависящая от контекста функция может проверить контекст, в котором она вызывается, и определить, как много работы она должна сделать. В пустом контексте функция <code>find_chores()</code> может законно ничего не делать. В скалярном контексте она может найти только самую важную задачу. В списочном контексте она должна отсортировать и вернуть весь список.</p>

<h3>Числовой, строковый и булев контекст</h3>

<p><a name="value_contexts"></p>

<p> </p>

<p>Другой вид контекста в Perl &mdash; <em>контекст значения</em> &mdash; определяет, как Perl интерпретирует кусок данных. Вы, вероятно, уже заметили, что Perl проявляет гибкость в определении того, имеете вы число или строку, и преобразовании их в тот вид, в который вы хотите. В обмен на отсутствие обязательств объявлять (или хотя бы следить) какой именно <em>тип</em> данных содержит переменная или выдаёт функция, контекст типа в Perl предоставляет подсказки, которые говорят компилятору, как обращаться с данными.</p>

<p></p>

<p>Perl приводит значения в конкретный надлежащий тип (<a href="chapter_03.html#coercion">Приведение типов</a>), в зависимости от используемого вами оператора. Например, оператор <code>eq</code> проверяет, что строки содержат одну и ту же информацию <em>как строки</em>:</p>

<pre><code>    say &quot;Catastrophic crypto fail!&quot; if $alice eq $bob;</code></pre>

<p>Возможно, у вас был ставящий в тупик опыт, когда вы <em>знаете</em>, что строки различаются, но сравнение всё равно показывает, что они одинаковые:</p>

<pre><code>    my $alice = &#39;alice&#39;;
    say &quot;Catastrophic crypto fail!&quot; if $alice == &#39;Bob&#39;;</code></pre>

<p>   </p>

<p></p>

<p>Оператор <code>eq</code> обращается со своими операндами как со строками, принудительно налагая на них <em>строковый контекст</em>. Оператор <code>==</code> налагает <em>числовой контекст</em>. В числовом контексте обе строки возвращают <code>0</code> (<a href="chapter_03.html#numeric_coercion">Числовое приведение типов</a>). Убедитесь, что используете соответствующий оператор для того типа контекста, который вам требуется.</p>

<p> </p>

<p><em>Булев контекст</em> имеет место, когды вы используете значение в условном выражении. В предыдущем примере <code>if</code> вычисляет результат операторов <code>eq</code> и <code>==</code> в булевом контексте.</p>

<p></p>

<p>В редких случаях вам, возможно, понадобится принудительно задать определённый контекст в случае, когда не существует оператора подходящего типа. Чтобы принудительно задать числовой контекст, прибавьте к переменной ноль. Чтобы принудительно задать строковый контекст, конкатенируйте переменную с пустой строкой. Чтобы принудительно задать булев контекст, используйте удвоенный оператор отрицания:</p>

<pre><code>    my $numeric_x =  0 + $x;  # &#x43F;&#x440;&#x438;&#x43D;&#x443;&#x434;&#x438;&#x442;&#x435;&#x43B;&#x44C;&#x43D;&#x43E; &#x437;&#x430;&#x434;&#x430;&#x451;&#x442; &#x447;&#x438;&#x441;&#x43B;&#x43E;&#x432;&#x43E;&#x439;  &#x43A;&#x43E;&#x43D;&#x442;&#x435;&#x43A;&#x441;&#x442;
    my $stringy_x = &#39;&#39; . $x;  # &#x43F;&#x440;&#x438;&#x43D;&#x443;&#x434;&#x438;&#x442;&#x435;&#x43B;&#x44C;&#x43D;&#x43E; &#x437;&#x430;&#x434;&#x430;&#x451;&#x442; &#x441;&#x442;&#x440;&#x43E;&#x43A;&#x43E;&#x432;&#x44B;&#x439; &#x43A;&#x43E;&#x43D;&#x442;&#x435;&#x43A;&#x441;&#x442;
    my $boolean_x =    !!$x;  # &#x43F;&#x440;&#x438;&#x43D;&#x443;&#x434;&#x438;&#x442;&#x435;&#x43B;&#x44C;&#x43D;&#x43E; &#x437;&#x430;&#x434;&#x430;&#x451;&#x442; &#x431;&#x443;&#x43B;&#x435;&#x432;     &#x43A;&#x43E;&#x43D;&#x442;&#x435;&#x43A;&#x441;&#x442;</code></pre>

<p>Контекст типа проще распознать, чем контекст количества. Как только вы узнаете, какой оператор предоставляет какой контекст (<a href="chapter_04.html#operator_types">Типы операторов</a>), вы редко будете ошибаться.</p>

<h2>Неявные идеи</h2>

<p><a name="implicit_ideas"></p>

<p>Контекст &mdash; лишь одна из лингвистических уловок в Perl. Программисты, понимающие эти уловки, могут, бросив взгляд на код, сразу же понять его наиболее важные характеристики. Другая важная лингвистическая особенность &mdash; эквивалент местоимений в Perl.</p>

<h3>Подразумеваемая переменная-скаляр</h3>

<p><a name="default_scalar_variable"></p>

<p>   </p>

<p><em>Подразумеваемая переменная-скаляр</em> (ещё называемая <em>переменная-топик</em>), <code>$_</code>, наиболее примечательна своим <em>отсутствием</em>: многие встроенные операции в Perl работают с содержимым <code>$_</code> в отсутствие явно указанной переменной. Вы можете использовать <code>$_</code> и как переменную, но это зачастую излишне.</p>

<p>      </p>

<p>Многие скалярные операторы Perl (включая <code>chr</code>, <code>ord</code>, <code>lc</code>, <code>length</code>, <code>reverse</code> и <code>uc</code>) работают с подразумеваемой переменной-скаляром, если вы не предоставили альтернативы. Например, встроенная функция <code>chomp</code> удаляет все завершающие последовательности новых строк из своего операнда (footnote: См. <code>perldoc -f chomp</code> и <code>$/</code> для более точных деталей её поведения.):</p>

<pre><code>    my $uncle = &quot;Bob\n&quot;;
    chomp $uncle;
    say &quot;&#39;$uncle&#39;&quot;;</code></pre>

<p><code>$_</code> в Perl имеет ту же самую функцию, что и местоимение <em>it</em> (<em>это</em>) в английском. Без явно указанной переменной, <code>chomp</code> удаляет все завершающие последовательности новых строк из <code>$_</code>. Perl понимает, что вы имеете ввиду говоря &laquo;<code>chomp</code>&raquo; (&laquo;обгрызть&raquo;); Perl всегда обгрызёт <em>это</em>, так что следующие две строки кода эквивалентны:</p>

<pre><code>    chomp $_;
    chomp;</code></pre>

<p> </p>

<p>Аналогично, <code>say</code> и <code>print</code> оперируют с <code>$_</code> в отстутствие других аргументов:</p>

<pre><code>    print;  # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; $_ &#x432; &#x442;&#x435;&#x43A;&#x443;&#x449;&#x438;&#x439; &#x434;&#x435;&#x441;&#x43A;&#x440;&#x438;&#x43F;&#x442;&#x43E;&#x440; &#x444;&#x430;&#x439;&#x43B;&#x430;
    say;    # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; &quot;$_\n&quot; &#x432; &#x442;&#x435;&#x43A;&#x443;&#x449;&#x438;&#x439; &#x434;&#x435;&#x441;&#x43A;&#x440;&#x438;&#x43F;&#x442;&#x43E;&#x440; &#x444;&#x430;&#x439;&#x43B;&#x430;</code></pre>

<p>  </p>

<p>Средства работы с регулярными выражениями в Perl (<a href="chapter_06.html#regex">Регулярные выражения и сопоставление</a>) по умолчанию используют <code>$_</code> для сопоставления, замены и транслитерации:</p>

<pre><code>    $_ = &#39;My name is Paquito&#39;;
    say if /My name is/;

    s/Paquito/Paquita/;

    tr/A-Z/a-z/;
    say;</code></pre>

<p></p>

<p>Директивы циклов в Perl (<a href="chapter_03.html#looping_directives">Директивы циклов</a>) по умолчанию используют <code>$_</code> как итерационную переменную. Рассмотрим директиву <code>for</code>, итерирующую по списку:</p>

<pre><code>    say &quot;#<strong>$_</strong>&quot; for 1 .. 10;

    for (1 .. 10)
    {
        say &quot;#<strong>$_</strong>&quot;;
    }</code></pre>

<p></p>

<p>&hellip;или <code>while</code>:</p>

<pre><code>    while (&lt;STDIN&gt;)
    {
        chomp;
        say scalar reverse;
    }</code></pre>

<p></p>

<p>&hellip;или <code>map</code>, преобразовывающую список:</p>

<pre><code>    my @squares = map { <strong>$_</strong> * <strong>$_</strong> } 1 .. 10;
    say for @squares;</code></pre>

<p></p>

<p>&hellip;или <code>grep</code>, фильтрующую список:</p>

<pre><code>    say &#39;Brunch time!&#39;
        if grep { /pancake mix/ } @pantry;</code></pre>

<p>Как английский становится запутанным, если вы используете слишком много местоимений и антецедентов, так и со смешанным использованием <code>$_</code>, явным или неявным, нужно быть осторожным. Неосмотрительное параллельное использование <code>$_</code> может привести к тому, что один кусок кода молча перезапишет значение, записанное другим. Если вы пишете функцию, которая использует <code>$_</code>, вы можете сломать работу с <code>$_</code> в вызывающей функции.</p>

<p>Начиная с Perl 5.10 появилась возможность объявлять <code>$_</code> как лексическую переменную (<a href="chapter_05.html#lexical_scope">Лексическая область видимости</a>), чтобы предотвратить такое разрушительное поведение:</p>

<pre><code>    while (&lt;STDIN&gt;)
    {
        chomp;

        # &#x41F;&#x41B;&#x41E;&#x425;&#x41E;&#x419; &#x41F;&#x420;&#x418;&#x41C;&#x415;&#x420;
        my $munged = calculate_value( $_ );
        say &quot;Original: $_&quot;;
        say &quot;Munged  : $munged&quot;;
    }</code></pre>

<p>Если <em>calculate_value()</em> или любая другая функция изменит <code>$_</code>, это изменение сохранится на протяжении текущей итерации цикла. Добавление объявления <code>my</code> предотвращает потерю существующего экземпляра <code>$_</code>:</p>

<pre><code>    while (my $_ = &lt;STDIN&gt;)
    {
        ...
    }</code></pre>

<p>Конечно, использование именованной лексической переменной может быть таким же ясным:</p>

<pre><code>    while (my $line = &lt;STDIN&gt;)
    {
        ...
    }</code></pre>

<p>Используйте <code>$_</code>, так же, как вы использовали бы слово &laquo;это&raquo; в формальном письме: экономно, в разумных и хорошо определённых границах.</p>

<p></p>

<p>В Perl 5.12 появился оператор троеточие (<code>...</code>) как заполнитель для кода, который вы намереваетесь поместить позже. Perl будет парсить его как законченную инструкцию, но выбросит исключение, что вы пытаетесь выполнить неимплементированный код, если вы попытаетесь его запустить. См. подробности в <code>perldoc perlop</code>.</p>

<h3>Подразумеваемая переменная-массив</h3>

<p><a name="default_array_variables"></p>

<p>   </p>

<p>Perl также предоставляет две неявные переменные-массива. Perl передаёт аргументы в функции (<a href="chapter_05.html#functions">Объявление функций</a>) в массиве <code>@_</code>. Операции работы с массивами (<a href="chapter_03.html#arrays">Массивы</a>) внутри функций по умолчанию воздействуют на эту переменную, поэтому два этих фрагмента кода эквивалентны:</p>

<pre><code>    sub foo
    {
        my $arg = shift;
        ...
    }

    sub foo_explicit_args
    {
        my $arg = shift @_;
        ...
    }</code></pre>

<p> </p>

<p>Так же как <code>$_</code> соответствует местоимению <em>it</em> (<em>это</em>), <code>@_</code> соответствует местоимениям <em>they</em> (<em>они</em>) и <em>them</em> (<em>их</em>). <em>В отличие</em> от <code>$_</code>, Perl автоматически локализует для вас <code>@_</code> когда вы вызываете другие функции. Встроенные функции <code>shift</code> и <code>pop</code> работают с <code>@_</code>, если отсутствуют другие операнды.</p>

<p>  </p>

<p>Снаружи всех функций подразумеваемая переменная-массив <code>@ARGV</code> содержит аргументы командной строки, переданные в программу. Операции работы с массивами в Perl (включая <code>shift</code> и <code>pop</code>) неявно работают с <code>@ARGV</code> за пределами функций. Вы не сможете использовать <code>@_</code> когда подразумеваете <code>@ARGV</code>.</p>

<p> </p>

<p>Оператор <code><$fh></code> в Perl &mdash; то же самое, что встроенная функция <code>readline</code>. <code>readline $fh</code> делает то же самое, что и <code><$fh></code>. Начиная с Perl 5.10 голая <code>readline</code> ведёт себя точно так же, как <code><></code>, так что теперь вы можете везде использовать <code>readline</code>. По историческим причинам <code><></code> &mdash; всё ещё более распространённый вариант, однако рассмотрите использование <code>readline</code> как более читаемой альтернативы. Вы возможно предпочтёте <code>glob '*.html'</code> варианту <code><*.html></code>, правда? Здесь та же самая идея.</p>

<p></p>

<p><code>@ARGV</code> имеет один специальный случай. Если вы читаете из пустого дескриптора файла <code><></code>, Perl будет воспринимать каждый элемент в <code>@ARGV</code> как <em>имя</em> файла, который нужно открыть для чтения. (Если массив <code>@ARGV</code> пуст, Perl будет читать со стандартного ввода.) Это неявное поведение <code>@ARGV</code> полезно при написании коротких программ, таких как этот фильтр для командной строки, изменяющий порядок своих входных данных на противоположный:</p>

<pre><code>    while (&lt;&gt;)
    {
        chomp;
        say scalar reverse;
    }</code></pre>

<p>Почему <code>scalar</code>? <code>say</code> налагает списочный контекст на свои операнды. <code>reverse</code> передаёт свой контекст своим операндам, обрабатывая их как список в списочном контексте и как конкатенированную строку в скалярном контексте. Если поведение <code>reverse</code> выглядит сбивающим с толку, ваши инстинкты верны. Perl 5 вероятно должен быть разделить &laquo;перевернуть строку&raquo; и &laquo;перевернуть список&raquo;.</p>

<p>Если вы запустите этот код со списком файлов:</p>

<pre><code>    $ <strong>perl reverse_lines.pl encrypted/*.txt</strong></code></pre>

<p>&hellip;результат будет одним длинным потоком вывода. Не передавая никаких аргументов, вы можете задать свой собственный стандартный ввод, передав его по конвейеру из другой программы или введя напрямую. Однако, Perl хорош для гораздо большего, чем маленькие программы для командной строки&hellip;</p>

</body></html>