<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="style.css" type="text/css"></head><body><h1>Управление реальными программами</h1>

<p><a name="writing_real_programs"></p>

<p>Книга может научить вас писать маленькие программы, решающие маленькие задачи-упражнения. Этим способом вы можете научиться синтаксису. Чтобы писать реальные программы, выполняющие реальные задачи, вам нужно научиться <em>управлять</em> кодом, написанным на вашем языке. Как вам организовать код? Как убедиться, что он работает? Как сделать его надёжным перед лицом ошибок? Что делает код кратким, ясным и поддерживаемым?</p>

<p>Современный Perl предоставляет множество инструментов и техник для написания реальных программ.</p>

<h2>Тестирование</h2>

<p><a name="testing"></p>

<p></p>

<p><em>Тестирование</em> &mdash; это процесс написания и запуска маленьких кусочков кода, помогающих удостовериться, что ваше программное обеспечение ведёт себя так, как задумано. Эффективное тестирование автоматизирует процесс, который вы уже выполняли бесчисленное количество раз: написать какое-то количество кода, запустить его, и убедиться, что он работает. Эта <em>автоматизация</em> чрезвычайно важна. Вместо того, чтобы доверять людям в том, что они буду идеально выполнять повторяющиеся ручные проверки, позвольте делать это компьютеру.</p>

<p>Perl 5 предоставляет отличные инструменты, помогающие вам писать правильные тесты.</p>

<h3>Test::More</h3>

<p>  </p>

<p>Тестирование в Perl начинается с базового модуля <code>Test::More</code> и его функции <code>ok()</code>. <code>ok()</code> принимает два параметра, булево значение и строку, описывающую назначение теста:</p>

<pre><code>    ok(   1, &#39;the number one should be true&#39;         );
    ok(   0, &#39;... and zero should not&#39;               );
    ok(  &#39;&#39;, &#39;the empty string should be false&#39;      );
    ok( &#39;!&#39;, &#39;... and a non-empty string should not&#39; );

    done_testing();</code></pre>

<p></p>

<p>Любое условие в вашей программе, которое вы можете протестировать, так или иначе может стать двоичным значением. Каждая тестовая <em>проверка</em> &mdash; это простой вопрос, на который можно ответить &laquo;да&raquo; или &laquo;нет&raquo;: работает ли этот маленький кусочек кода так, как я ожидаю? Сложные программы могут иметь тысячи отдельных условий, и, в общем, чем мельче разбиение, тем лучше. Изолирование конкретных поведений в отдельные проверки позволяет вам свести к минимуму баги и недопонимания, особенно когда вы будете модифицировать код в будущем.</p>

<p>Функция <code>done_testing()</code> сообщает <code>Test::More</code>, что программа успешно выполнила все ожидаемые тестовые проверки. Если программа столкнулась с исключением времени выполнения, или по другим причинам неожиданно завершилась прежде, чем произошёл вызов <code>done_testing()</code>, тестовый фреймворк уведомит вас, что что-то пошло не так. Без механизма, подобного <code>done_testing()</code>, как бы вы <em>узнали</em>? Правда, этот пример кода слишком прост, чтобы сломаться, но код, который слишком прост, чтобы сломаться, ломается гораздо чаще, чем кто-либо мог ожидать.</p>

<blockquote>

<p> </p>

<p><code>Test::More</code> также позволяет использовать <em>план тестов</em> для указания числа отдельных проверок, которые вы планируете выполнить:</p>

<pre><code>    use Test::More tests =&gt; 4;

    ok(   1, &#39;the number one should be true&#39;         );
    ok(   0, &#39;... and zero should not&#39;               );
    ok(  &#39;&#39;, &#39;the empty string should be false&#39;      );
    ok( &#39;!&#39;, &#39;... and a non-empty string should not&#39; );</code></pre>

<p>Аргумент <code>test</code>, указываемый для <code>Test::More</code>, устанавливает план тестов для программы. Это предохранительная сетка. Если выполнено меньше, чем четыре теста, что-то пошло не так. Если выполнено больше, чем четыре теста, что-то пошло не так.</p>

</blockquote>

<h3>Запуск тестов</h3>

<p><a name="running_tests"></p>

<p>Результирующая программа теперь &mdash; полноценная программа на Perl 5, которая генерирует следующий вывод:</p>

<pre><code>    ok 1 - the number one should be true
    not ok 2 - ... and zero should not
    #   Failed test &#39;... and zero should not&#39;
    #   at truth_values.t line 4.
    not ok 3 - the empty string should be false
    #   Failed test &#39;the empty string should be false&#39;
    #   at truth_values.t line 5.
    ok 4 - ... and a non-empty string should not
    1..4
    # Looks like you failed 2 tests of 4.</code></pre>

<p> </p>

<p>Этот формат соответствует стандартному выводу тестов, называемому <em>TAP</em>, <em>Test Anything Protocol</em>, <em>Протокол тестирования чего угодно</em> (http://testanything.org/). Проваленные TAP-тесты выдают диагностические сообщения для помощи отладке.</p>

<p>   </p>

<p>Вывод тестового файла, содержащего множество проверок (особенно множество <em>проваленных</em> проверок) может быть многословным. В большинстве случаев вам достаточно знать либо что всё прошло, либо конкретику имеющихся провалов. Базовый модуль <code>Test::Harness</code> интерпретирует TAP, и связанная с ним программа <code>prove</code> запускает тесты и отображает только наиболее релевантную информацию:</p>

<pre><code>    $ <strong>prove truth_values.t</strong>
    truth_values.t .. 1/?
    #   Failed test &#39;... and zero should not&#39;
    #   at truth_values.t line 4.

    #   Failed test &#39;the empty string should be false&#39;
    #   at truth_values.t line 5.
    # Looks like you failed 2 tests of 4.
    truth_values.t .. Dubious, test returned 2
        (wstat 512, 0x200)
    Failed 2/4 subtests

    Test Summary Report
    -------------------
    truth_values.t (Wstat: 512 Tests: 4 Failed: 2)
      Failed tests:  2-3</code></pre>

<p>Тут много вывода, отображающего то, что и так очевидно: второй и третий тесты проваливаются, потому что ноль и пустая строка являются ложными значениями. Эти провалы легко исправить, инвертировав смысл условий с помощью булева приведения типов (<a href="chapter_03.html#boolean_coercion">Булево приведение типов</a>):</p>

<pre><code>    ok(   <strong>!</strong> 0, &#39;... and zero should not&#39;          );
    ok(  <strong>!</strong> &#39;&#39;, &#39;the empty string should be false&#39; );</code></pre>

<p>После этих двух изменений <code>prove</code> выводит следующее:</p>

<pre><code>    $ <strong>prove truth_values.t</strong>
    truth_values.t .. ok
    All tests successful.</code></pre>

<blockquote>

<p>Смотрите в <code>perldoc prove</code> полезные опции тестов, такие как параллельный запуск тестов (<code>-j</code>), автоматическое добавление <em>lib/</em> во включаемые пути Perl (<code>-l</code>), рекурсивный запуск всех файлов тестов, найденных в <em>t/</em> (<code>-r t</code>) и запуск медленных тестов сначала (<code>--state=slow,save</code>).</p>

<p> </p>

<p>Псевдоним оболочки bash <code>proveall</code> может оказаться полезным:</p>

<pre><code>    alias proveall=&#39;prove -j9 --state=slow,save -lr t&#39;</code></pre>

</blockquote>

<h3>Лучшее сравнение</h3>

<p>Хотя сердце всех автоматизированных тестов &mdash; булево условие &laquo;истинно или ложно?&raquo;, сведение всего к этому булеву условию утомительно и даёт небольшие диагностические возможности. <code>Test::More</code> предоставляет несколько других удобных функций проверок.</p>

<p>  </p>

<p>Функция <code>is()</code> сравнивает два значения, используя оператор <code>eq</code>. Если значения равны, тест проходит. В противном случае, тест проваливается с диагностическим сообщением:</p>

<pre><code>    is(         4, 2 + 2, &#39;addition should work&#39; );
    is( &#39;pancake&#39;,   100, &#39;pancakes are numeric&#39; );</code></pre>

<p>Как вы можете предположить, первый тест проходит, а второй &mdash; проваливается.</p>

<pre><code>    t/is_tests.t .. 1/2
    #   Failed test &#39;pancakes are numeric&#39;
    #   at t/is_tests.t line 8.
    #          got: &#39;pancake&#39;
    #     expected: &#39;100&#39;
    # Looks like you failed 1 test of 2.</code></pre>

<p>Тогда как <code>ok()</code> предоставляет только номер строки провалившегося теста, <code>is()</code> отображает ожидаемое и полученное значение.</p>

<p><code>is()</code> налагает неявный скалярный контекст на свои значения (<a href="chapter_11.html#prototypes">Прототипы</a>). Это означает, например, что вы можете проверить количество элементов в массиве без необходимости явного вычисления массива в скалярном контексте:</p>

<pre><code>    my @cousins = qw( Rick Kristen Alex
                      Kaycee Eric Corey );
    is( @cousins, 6, &#39;I should have only six cousins&#39; );</code></pre>

<p>&hellip;хотя некоторые для ясности предпочитают писать <code>scalar @cousins</code>.</p>

<p>  </p>

<p>Соответствующая функция <code>Test::More</code> <code>isnt()</code> сравнивает два значения, используя оператор <code>ne</code>, и проходит, если они не равны. Она также налагает скалярный контекст на свои операнды.</p>

<p> </p>

<p>И <code>is()</code>, и <code>isnt()</code> используют <em>строковое сравнение</em> с помощью операторов Perl 5 <code>eq</code> и <code>ne</code>. Это почти всегда то, что нужно, но для сложных значений, таких как объекты с перегрузкой (<a href="chapter_09.html#overloading">Перегрузка</a>) или двойные переменные (<a href="chapter_03.html#dualvars">Двойные переменные</a>), вы можете предпочесть явное тестирование сравнения. Функция <code>cmp_ok()</code> позволяет вам указать свой собственный оператор сравнения:</p>

<pre><code>    cmp_ok( 100, $cur_balance, &#39;&lt;=&#39;,
           &#39;I should have at least $100&#39; );

    cmp_ok( $monkey, $ape, &#39;==&#39;,
           &#39;Simian numifications should agree&#39; );</code></pre>

<p> </p>

<p>Классы и объекты предоставляют свои собственные интересные способы взаимодействия с тестами. Протестировать, что класс или объект расширяет другой класс (<a href="chapter_07.html#inheritance">Наследование</a>), можно с помощью <code>isa_ok()</code>:</p>

<pre><code>    my $chimpzilla = RobotMonkey-&gt;new();
    isa_ok( $chimpzilla, &#39;Robot&#39; );
    isa_ok( $chimpzilla, &#39;Monkey&#39; );</code></pre>

<p><code>isa_ok()</code> предоставляет свои собственные диагностические сообщенния при провалах.</p>

<p><code>can_ok()</code> проверяет, что класс или объект может выполнить запрошенный метод (или методы):</p>

<pre><code>    can_ok( $chimpzilla, &#39;eat_banana&#39; );
    can_ok( $chimpzilla, &#39;transform&#39;, &#39;destroy_tokyo&#39; );</code></pre>

<p>Функция <code>is_deeply()</code> сравнивает две ссылки, чтобы убедиться, что их содержимое идентично:</p>

<pre><code>    use Clone;

    my $numbers   = [ 4, 8, 15, 16, 23, 42 ];
    my $clonenums = Clone::clone( $numbers );

    is_deeply( $numbers, $clonenums,
         &#39;clone() should produce identical items&#39; );</code></pre>

<p> </p>

<p>Если сравнение проваливается, <code>Test::More</code> сделает всё, что в его силах, чтобы предоставить разумную диагностику, указывающую позицию первого несоответствия между структурами. Для более настраиваемых тестов смотрите CPAN-модули <code>Test::Differences</code> и <code>Test::Deep</code>.</p>

<p>В <code>Test::More</code> есть ещё несколько тестовых функций, но эти наиболее полезны.</p>

<h3>Организация тестов</h3>

<p>   </p>

<p>CPAN-дистрибутивы должны включать директорию <em>t/</em>, содержающую один или более файлов тестов, имеющих расширение <em>.t</em>. По умолчанию, когда вы собираете дистрибутив с помощью <code>Module::Build</code> или <code>ExtUtils::MakeMaker</code>, этап тестирования запускает все файлы <em>t/*.t</em>, суммирует их вывод, и проходит успешно или проваливается в зависимости от результатов набора тестов как целого. Нет конкретных руководств, как управлять содержимым отдельных файлов <em>.t</em>, хотя наиболее популярны две стратегии:</p>

<ul>

<li>Каждый файл <em>.t</em> должен соответствовать файлу <em>.pm</em>.</li>

<li>Каждый файл <em>.t</em> должен соответствовать некоторому функционалу.</li>

</ul>

<p>Смешанный подход наиболее гибок; один тест может проверять, что все ваши модули компилируются, тогда как другие тесты будут проверять, что каждый модуль ведёт себя так, как ожидается. Когда дистрибутив разрастается, полезность управления тестами в привязке к функционалу становится более привлекательной; большие тестовые файлы сложнее поддерживать.</p>

<p>Кроме того, раздельные файлы тестов могут ускорить разработку. Если вы добавляете способность дышать огнём к вашему классу <code>RobotMonkey</code>, вы, вероятно, захотите запускать только тестовый файл <em>t/breathe_fire.t</em>. Когда же вы добъётесь удовлетворительной работы функционала, запустите весь набор тестов для проверки того, что локальные изменения не имеют непреднамеренных глобальных эффектов.</p>

<h3>Другие модули для тестирования</h3>

<p> </p>

<p><code>Test::More</code> полагается на тестовый бэкенд, известный как <code>Test::Builder</code>. Этот модуль управляет планом тестов и приводит вывод тестов в TAP. Такой дизайн позволяет множеству тестовых модулей использовать один и тот же бэкенд <code>Test::Builder</code>. Вследствие этого, на CPAN доступны сотни тестовых модулей &mdash; и все они могут работать вместе в одной и той же программе.</p>

<p>               </p>

<ul>

<li><code>Test::Fatal</code> помогает протестировать, что ваш код выбрасывает (и не выбрасывает) исключения соответствующим образом. Вам также может встретиться <code>Test::Exception</code>.</li>

<li><code>Test::MockObject</code> и <code>Test::MockModule</code> позволяют вам тестировать сложные интерфейсы, <em>имитируя</em> (<em>mocking</em>) их (эмулируя, но производя другие результаты).</li>

<li><code>Test::WWW::Mechanize</code> помогает тестировать веб-приложения, тогда как <code>Plack::Test</code>, <code>Plack::Test::Agent</code> и подкласс <code>Test::WWW::Mechanize::PSGI</code> могут делать это, не используя внешний живой веб-сервер.</li>

<li><code>Test::Database</code> предоставляет функции для тестирования правильного и неправильного использования баз данных. <code>DBICx::TestDatabase</code> помогает тестировать схемы, сгенерированные с помощью <code>DBIx::Class</code>.</li>

<li><code>Test::Class</code> предлагает альтернативный механизм организации наборов тестов. Он позволяет вам создавать классы, в которых конкретные методы группируют тесты. Вы можете наследовать от этих тестовых классов, так же как ваши классы кода наследуют друг от друга. Это превосходный способ уменьшить дублирование в тестовых наборах. См. превосходную серию статей по <code>Test::Class</code> Кёртиса Пое (Curtis Poe) (footnote: http://www.modernperlbooks.com/mt/2009/03/organizing-test-suites-with-testclass.html). Более новый дистрибутив <code>Test::Routine</code> предлагает аналогичные возможности посредством использования Moose (<a href="chapter_07.html#moose">Moose</a>).</li>

<li><code>Test::Differences</code> тестирует строки и структуры данных на идентичность и отображает любые найденные различия в своей диагностике. <code>Test::LongString</code> добавляет похожие проверки.</li>

<li><code>Test::Deep</code> тестирует идентичность вложенных структур данных (<a href="chapter_03.html#nested_data_structures">Вложенные структуры данных</a>).</li>

<li><code>Devel::Cover</code> анализирует выполнение ваших наборов тестов и даёт отчёт о количестве кода, которое тесты действительно выполняют. В общем, чем больше покрытие, тем лучше &mdash; хотя стопроцентное покрытие не всегда возможно, 95% гораздо лучше, чем 80%.</li>

</ul>

<p>См. проект Perl QA (http://qa.perl.org/) для большей информации о тестировании в Perl.</p>

<h2>Обработка предупреждений</h2>

<p><a name="handling_warnings"></p>

<p>Хотя существует более чем один способ написать работающую программу на Perl 5, некоторые из этих способов могут быть путающими, неясными и даже некорректными в некоторых хитрых ситуациях. Система опциональных предупреждений в Perl 5 может помочь вам распознавать такие ситуации и избегать их.</p>

<h3>Генерация предупреждений</h3>

<p><a name="producing_warnings"></p>

<p></p>

<p>Используйте встроенную функцию <code>warn</code> чтобы выдать предупреждение:</p>

<pre><code>    warn &#39;Something went wrong!&#39;;</code></pre>

<p><code>warn</code> выводит список значений в файловый дескриптор STDERR (<a href="chapter_09.html#filehandle">Ввод и вывод</a>). Perl будет добавлять имя файла и номер строки, на которой произошёл вызов <code>warn</code>, если последний элемент списка не заканчивается переводом строки.</p>

<p>    </p>

<p>Встроенный модуль <code>Carp</code> предлагает другие механизмы для генерации предупреждений. Его функция <code>carp()</code> выводит предупреждение с точки зрения вызывающего кода. Если есть такая валидация параметров функции:</p>

<pre><code>    use Carp &#39;carp&#39;;

    sub only_two_arguments
    {
        my ($lop, $rop) = @_;
        carp( &#39;Too many arguments provided&#39; ) if @_ &gt; 2;
        ...
    }</code></pre>

<p>&hellip;предупреждение об арности (<a href="chapter_04.html#arity">Арность</a>) будет включать имя файла и номер строки <em>вызывающего</em> кода, а не <code>only_two_arguments()</code>. <code>cluck()</code> из того же модуля <code>Carp</code> аналогично генерирует обратную трассировку всех вызовов функций до текущей функции.</p>

<p></p>

<p>Многословный режим <code>Carp</code> добавляет обратную трассировку ко всем предупреждениям, генерируемым <code>carp()</code> и <code>croak()</code> (<a href="chapter_05.html#reporting_errors">Оповещение об ошибках</a>) по всей программе:</p>

<pre><code>    $ perl -MCarp=verbose my_prog.pl</code></pre>

<p>Используйте <code>Carp</code> при написании модулей (<a href="chapter_09.html#modules">Модули</a>) вместо <code>warn</code> или <code>die</code>.</p>

<h3>Включение и выключение предупреждений</h3>

<p> </p>

<p>В старом коде вы можете встретить аргумент командной строки <code>-w</code>. Он включает предупреждения по всей программе, даже во внешних модулях, написанных и поддерживаемых другими людьми. Тут всё или ничего, хотя это и может быть полезным, если у вас есть необходимые средства для устранения и предупреждений, и потенциальных предупреждений по всей кодовой базе.</p>

<p> </p>

<p>Современный подход &mdash; использование прагмы <code>warnings</code> (footnote: &hellip;или эквивалента, такого как <code>use Modern::Perl;</code>.). Это включает предупреждения в <em>лексической</em> области видимости и указывает, что автор кода не подразумевает, что в нормальных условиях он будет генерировать предупреждения.</p>

<p>   </p>

<p>Флаг <code>-W</code> включает предупреждения по всей программе в одностороннем порядке, независимо от лексического включения или выключения с помощью прагмы <code>warnings</code>. Флаг <code>-X</code> <em>отключает</em> предупреждения по всей программе в одностороннем порядке. Ни один из них не имеет широкого распространения.</p>

<p> </p>

<p>Все эти флаги, <code>-w</code>, <code>-W</code> и <code>-X</code>, воздействуют на глобальную переменную <code>$^W</code>. Код, написанный до появления прагмы <code>warnings</code> (Perl 5.6.0 весной 2000 года) может локализовать <code>$^W</code>, чтобы подавить некоторые предупреждения в пределах заданной области видимости.</p>

<h3>Отключение категорий предупреждений</h3>

<p>Чтобы отключить выбранные предупреждения в области видимости, используйте <code>no warnings;</code> со списком аргументов. Опускание списка аргументов отключает все предупреждения в этой области видимости.</p>

<p><code>perldoc perllexwarn</code> приводит список всех категорий предупреждений, которые ваша версия Perl 5 воспринимает с прагмой <code>warnings</code>. Большая часть из них представляет действительно интересные условия, но некоторые могут быть явно бесполезны в ваших конкретных обстоятельствах. Например, предупреждение <code>recursion</code> будет происходить, если Perl обнаружил, что функция вызвала себя более чем сто раз. Если вы уверены в своей способности написать условия завершения рекурсии, вы можете отключить это предупреждение в области видимости рекурсии (хотя хвостовые вызовы, возможно, подойдут лучше; <a href="chapter_05.html#tail_calls">Хвостовые вызовы</a>).</p>

<p>Если вы генерируете код (<a href="chapter_09.html#code_generation">Кодогенерация</a>) или локально переопределяете символы, вам может понадобиться отключить предупреждение <code>redefine</code>.</p>

<p>Некоторые опытные Perl-хакеры отключают предупреждение об неинициализированных значениях (<code>uninitialized</code>) в коде обработки строк, который конкатенирует значения из множества источников. Тщательная инициализация переменных помогает избежать необходимости отключения предупреждения, но локальный стиль и лаконичность могут сделать использование этого предупреждения спорным.</p>

<h3>Сделать предупреждения фатальными</h3>

<p><a name="fatal_warnings"> </p>

<p>Если ваш проект считает предупреждения такими же обременительными, как ошибки, вы можете сделать их лексически фатальными. Так можно повысить <em>все</em> предупреждения до исключений:</p>

<pre><code>    use warnings FATAL =&gt; &#39;all&#39;;</code></pre>

<p>Также вы можете сделать фатальными конкретные категории предупреждений, как, например, использование нерекомендуемых конструкций:</p>

<pre><code>    use warnings FATAL =&gt; &#39;deprecated&#39;;</code></pre>

<p>С надлежащей дисциплиной, это может привести к очень надёжному код &mdash; но будьте осторожны. Многие предупреждения вызываются условиями времени исполнения. Если ваш набор тестов не сможет распознать все предупреждения, с которыми вы можете столкнуться, ваша программа может завершиться при выполнении из-за непойманного исключения.</p>

<h3>Отлавливание предупреждений</h3>

<p> </p>

<p>Так же как вы ловите исключения, так же вы можете ловить и предупреждения. Переменная <code>%SIG</code> (footnote: См. <code>perldoc perlvar</code>.) содержит обработчики внеполосных сигналов, генерируемых Perl или вашей операционной системой. Чтобы поймать предупреждение, присвойте <code>$SIG{__WARN__}</code> ссылку на функцию:</p>

<pre><code>    {
        my $warning;
        local $SIG{__WARN__} = sub { $warning .= shift };

        # &#x441;&#x434;&#x435;&#x43B;&#x430;&#x442;&#x44C; &#x447;&#x442;&#x43E;-&#x43D;&#x438;&#x431;&#x443;&#x434;&#x44C; &#x440;&#x438;&#x441;&#x43A;&#x43E;&#x432;&#x430;&#x43D;&#x43D;&#x43E;&#x435;
        ...

        say &quot;Caught warning:\n$warning&quot; if $warning;
    }</code></pre>

<p>Внутри обработчика предупреждений, первым аргументом будет сообщение предупреждения. Надо сказать, эта техника менее удобна, чем отключение предупреждений лексически &mdash; но это может оказаться полезным в тестовых модулях, таких как <code>Test::Warnings</code> из CPAN, где важен фактический текст предупреждения.</p>

<p>Имейте ввиду, что переменная <code>%SIG</code> глобальна. Локализуйте её в наименьшей возможной области видимости с помощью <code>local</code>, но понимайте, что это всё ещё глобальная переменная.</p>

<h3>Регистрация своих собственных предупреждений</h3>

<p><a name="registering_warnings"></p>

<p> </p>

<p>Прагма <code>warnings::register</code> позволяет вам создавать свои собственные лексические предупреждения, чтобы пользователи вашего кода могли включать и отключать лексические предупреждения. Используйте (<code>use</code>) прагму <code>warnings::register</code> в модуле:</p>

<pre><code>    package Scary::Monkey;

    <strong>use warnings::register;</strong></code></pre>

<p>Это создаст новую категорию предупреждений, названную по имени пакета <code>Scary::Monkey</code>. Включите эти предупреждения с помощью <code>use warnings 'Scary::Monkey'</code> и отключите с помощью <code>no warnings 'Scary::Monkey'</code>.</p>

<p>Используйте <code>warnings::enabled()</code> чтобы проверить, что категория предупреждения включена в вызывающей лексической области. Используйте <code>warnings::warnif()</code> для генерации предупреждений, только если предупреждения действуют. Например, чтобы выдать предупреждение в категории <code>deprecated</code>:</p>

<pre><code>    package Scary::Monkey;

    use warnings::register;

    <strong>sub import</strong>
    <strong>{</strong>
        <strong>warnings::warnif( &#39;deprecated&#39;,</strong>
            <strong>&#39;empty imports from &#39; . __PACKAGE__ .</strong>
            <strong>&#39; are now deprecated&#39; )</strong>
        <strong>unless @_;</strong>
    <strong>}</strong></code></pre>

<p>См. <code>perldoc perllexwarn</code> для больших подробностей.</p>

<h2>Файлы</h2>

<p><a name="files"></p>

<p>Большинству программ нужно как-то взаимодействовать с реальным миром. Большинству программ нужно писать, читать или другими способами манипулировать с файлами. Происхождение Perl как инструмента для системных администраторов привело к созданию языка, отлично подходящего для обработки текста.</p>

<h3>Ввод и вывод</h3>

<p><a name="filehandle">       </p>

<p><em>Дескриптор файла</em> представляет текущее состояние одного конкретного канала ввода или вывода. В каждой программе на Perl доступны три стандартных дескриптора файлов, <code>STDIN</code> (ввод программы), <code>STDOUT</code> (вывод программы) и <code>STDERR</code> (вывод ошибок программы). По умолчанию всё, что вы выводите с помощью <code>print</code> или <code>say</code>, отправляется на <code>STDOUT</code>, тогда как ошибки, предупреждения и всё, что вы выводите с помощью <code>warn()</code>, отправляется на <code>STDERR</code>. Такое разделение вывода позволяет вам перенаправить полезный вывод и ошибки в два разных места &mdash; например, в выходной файл и лог ошибок.</p>

<p></p>

<p>Используйте встроенную функцию <code>open</code> для получения дескриптора файла. Так файл открывается для чтения:</p>

<pre><code>    open my $fh, &#39;&lt;&#39;, &#39;filename&#39;
        or die &quot;Cannot read &#39;$filename&#39;: $!\n&quot;;</code></pre>

<p>Первый операнд &mdash; это лексическая переменная, которая будет содержать результирующий дескриптор файла. Второй оператор &mdash; <em>режим файла</em>, определяющий тип операций с дескриптором файла. Последний операнд &mdash; это имя файла. Если <code>open</code> провалится, оператор <code>die</code> выбросит исключение, с содержимым <code>$!</code>, описывающим причину, по которой открытие файла не удалось.</p>

<p>Кроме этого, вы можете открывать файлы для записи, добавления, чтения и записи и т. д. Здесь перечислены наиболее важные режимы файлов:</p>

<p><em>Table: Режимы файлов</em></p>
<table>

<p><a name="file_modes_table"></p>

<th><strong>Символ</strong></th>

<th><strong>Описание</strong></th>

<tr>

<td><code><</code></td>

<td>Открыть для чтения</td>

</tr>

<tr>

<td><code>></code></td>

<td>Открыть для записи, перезаписывая существующее содержимое, если файл существует, и создавая новый файл в противном случае.</td>

</tr>

<tr>

<td><code>>></code></td>

<td>Открыть для записи, добавляя к существующему контенту или создавая новый файл.</td>

</tr>

<tr>

<td><code>+<</code></td>

<td>Открыть для чтения и записи.</td>

</tr>

<tr>

<td><code>-|</code></td>

<td>Открыть канал к внешнему процессу для чтения.</td>

</tr>

<tr>

<td><code>|-</code></td>

<td>Открыть канал к внешнему процессу для записи.</td>

</tr>

</table>

<p>Вы даже можете создавать дескрипторы файлов, который могут читать или писать в простые скаляры Perl, используя любой существующий режим файла:</p>

<pre><code>    open my $read_fh,  &#39;&lt;&#39;, \$fake_input;
    open my $write_fh, &#39;&gt;&#39;, \$captured_output;

    do_something_awesome( $read_fh, $write_fh );</code></pre>

<p>Все примеры в этом разделе имеют включенный режим <code>use autodie;</code>, а потому могут безопасно игнорировать обработку ошибок. Если вы выбрали не использовать <code>autodie</code>, хорошо &mdash; но не забудьте проверить возвращаемые значения всех системных вызовов, чтобы соответствующим образом обработать ошибки.</p>

<p></p>

<p><code>perldoc perlopentut</code> предлагает гораздо больше деталей о более экзотических применениях <code>open</code>, включая её способность запускать и контролировать другие процессы, а также использование <code>sysopen</code> для более точного контроля ввода и вывода. <code>perldoc perlfaq5</code> приводит рабочий код для многих задач ввода/вывода.</p>

<h4>Двухаргументный вызов <code>open</code></h4>

<p>Старый код часто использует двухаргументную форму <code>open()</code>, которая объединяет режим файла с именем открываемого файла:</p>

<pre><code>    open my $fh, <strong>&quot;&gt; $some_file&quot;</strong>
        or die &quot;Cannot write to &#39;$some_file&#39;: $!\n&quot;;</code></pre>

<p>Соответственно, Perl должен извлечь режим файла из имени файла, и здесь лежат потенциальные проблемы. Каждый раз, когда Perl приходится догадываться, что вы имеете ввиду, вы получаете риск того, что он может догадаться неверно. Хуже того, если <code>$some_file</code> приходит из недоверенного пользовательского ввода, у вас возникает потенциальная проблема безопасности, так как любые неожиданные символы могут изменить поведение вашей программы.</p>

<p>Трёхаргументный вызов <code>open()</code> &mdash; более безопасная замена для этого кода.</p>

<p>  </p>

<p>Дескриптор файла <code>DATA</code>, специальная глобальная переменная пакета, представляет текущий файл. Когда Perl заканчивает компиляцию файла, он оставляет <code>DATA</code> открытым на конце компилируемой части, <em>если</em> файл содержит секцию <code>__DATA__</code> или <code>__END__</code>. Любой текст, находящийся за пределами этого токена, доступен для чтения через <code>DATA</code>. Это полезно для коротких, самодостаточных программ. См. <code>perldoc perldata</code> для дальнейших подробностей.</p>

<h4>Чтение из файлов</h4>

<p>  </p>

<p>Имея открытый для ввода дескриптор файла, прочитать из него можно с помощью встроенной функции <code>readline</code>, также записываемой как <code><></code>. Распространённая идиома читает по строке за раз в цикле <code>while()</code>:</p>

<pre><code>    open my $fh, &#39;&lt;&#39;, &#39;some_file&#39;;

    while (&lt;$fh&gt;)
    {
        chomp;
        say &quot;Read a line &#39;$_&#39;&quot;;
    }</code></pre>

<p></p>

<p>В скалярном контексте <code>readline</code> итерирует по строкам файла, пока не достигнет его конца (<code>eof()</code>). Каждая итерация возвращает следующую строку. После достижения конца файла, каждая итерация возвращает <code>undef</code>. Эта идиома с <code>while</code> явно проверяет определённость переменной, используемой для итерации, так что только достижение конца файла завершит цикл. Другими словами, это сокращение для следующего:</p>

<pre><code>    open my $fh, &#39;&lt;&#39;, &#39;some_file&#39;;

    while (defined($_ = &lt;$fh&gt;))
    {
        chomp;
        say &quot;Read a line &#39;$_&#39;&quot;;
        last if eof $fh;
    }</code></pre>

<p><code>for</code> налагает списочный контекст на свой операнд. В случае <code>readline</code> Perl прочитает <em>весь</em> файл, прежде чем обработать <em>какую-либо</em> его часть. <code>while</code> выполняет итерацию и читает по строке за раз. Когда использование памяти имеет значение, используйте <code>while</code>.</p>

<p></p>

<p>Каждая строка, прочитанная с помощью <code>readline</code>, содержит символ или символы, отмечающие конец строки. В большинстве случаев это платформозависимая последовательность, состоящая из перевода строки (<code>\n</code>), возврата каретки (<code>\r</code>), или сочетания их обоих (<code>\r\n</code>). Используйте <code>chomp</code> для их удаления.</p>

<p>Наиболее ясный способ прочитать файл строка за строкой в Perl 5 такой:</p>

<pre><code>    open my $fh, &#39;&lt;&#39;, $filename;

    while (my $line = &lt;$fh&gt;)
    {
        chomp $line;
        ...
    }</code></pre>

<p></p>

<p>Perl по умолчанию работает с файлами в текстовом режиме. Если вы читатете <em>двоичные</em> данные, такие как медиафайл или сжатый файл &mdash; используйте <code>binmode</code> прежде чем выполнять какой-либо ввод/вывод. Это укажет Perl обрабатывать данные файла как чистые данные, никаким образом их не модифицируя (footnote: Модификации включают перевод <code>\n</code> в платформозависимую последовательность новой строки.). Хотя на Unix-подобных платформах <code>binmode</code> может быть не всегда <em>обязателен</em>, переносимые программы играют наверняка (<a href="chapter_03.html#unicode">Юникод и строки</a>).</p>

<h4>Запись в файлы</h4>

<p> </p>

<p>Имея открытый для вывода дескриптор файла, осуществляйте вывод в него с помощью <code>print</code> или <code>say</code>:</p>

<pre><code>    open my $out_fh, &#39;&gt;&#39;, &#39;output_file.txt&#39;;

    print $out_fh &quot;Here&#39;s a line of text\n&quot;;
    say   $out_fh &quot;... and here&#39;s another&quot;;</code></pre>

<p>Обратите внимание на отсутствие запятой между дескриптором файла и следующим операндом.</p>

<p></p>

<p><em>Perl Best Practices</em> Демьена Конвея (Damian Conway) рекомендует придерживаться привычки заключать дескриптор файла в фигурные скобки. Это необходимо для устранения неоднозначности парсинга дескриптора файла, содержащегося в агрегатной переменной, и ничему не повредит в более простых случаях.</p>

<p>   </p>

<p>И <code>print</code>, и <code>say</code> принимают список операндов. Perl 5 использует магическую глобальную переменную <code>$,</code> как разделитель значений списка. Perl также использует любое значение <code>$\</code> как последний аргумент <code>print</code> или <code>say</code>. Так что эти две строки кода дают один и тот же результат:</p>

<pre><code>    my @princes = qw( Corwin Eric Random ... );

    print @princes;
    print join( $,, @princes ) . $\;</code></pre>

<h4>Закрытие файлов</h4>

<p></p>

<p>Когда вы закончили работать с файлом, закройте его дескриптор явно с помощью <code>close</code>, или дайте ему выйти из области видимости. Perl закроет его для вас. Преимущество явного вызова <code>close</code> в том, что вы можете проверить &mdash; и восстановиться после них &mdash; специфические ошибки, такие как недостаток места на устройстве хранения или разорванное сетевое соединение.</p>

<p>Как обычно, <code>autodie</code> выполнит эти проверки за вас:</p>

<pre><code>    use autodie;

    open my $fh, &#39;&gt;&#39;, $file;

    ...

    close $fh;</code></pre>

<h4>Специальные переменные обработки файлов</h4>

<p><a name="file_handling_variables">  </p>

<p>Для каждой прочитанной строки Perl 5 инкрементирует значение переменной <code>$.</code>, которая служит счётчиком строк.</p>

<p> </p>

<p><code>readline</code> использует текущее содержимое <code>$/</code> как последовательность завершения строки. По умолчанию значение этой переменной содержит последовательность символов завершения строки, наиболее подходяющую для текстовых файлов на текущей платформе. По правде говоря, слово <em>строка</em> &mdash; неправильное название. Вы можете установить в <code>$/</code> любую последовательность символов (footnote: &hellip;но, к сожалению, не регулярное выражение. Perl 5 этого не поддерживает.). Это полезно для сильно структурированных данных, в которых вы хотите считывать <em>запись</em> за раз. Имея файл с записями, разделёнными двумя пустыми строками, установите <code>$/</code> в <code>\n\n</code> для чтения по записи за раз. Применение <code>chomp</code> к прочитанной из файла записи удалит последовательность двойного перевода строки.</p>

<p>  </p>

<p>Perl по умолчанию <em>буферизует</em> свой вывод, выполняя ввод/вывод только когда ожидающий вывод превышает порог по размеру. Это позволяет Perl группировать дорогие операции ввода/вывода вместо того, чтобы всегда записывать очень малые количества данных. Однако иногда вам нужно отправить данные как только вы их получаете, не ожидая буферизации &mdash; особенно если вы пишете фильтр для командной строки, соединённый с другими программами, или строко-ориентированный сетевой сервис.</p>

<p>Переменная <code>$|</code> контролирует буферизацию на текущем активном файловом дескрипторе вывода. При установке ненулевого значения Perl будет сбрасывать вывод после каждой записи в дескриптор файла. При установке нулевого значения Perl будет использовать свою стратегию буферизации по умолчанию.</p>

<p>Для файлов по умолчанию действует стратегия полной буферизации. <code>STDOUT</code>, присоединённый к активному терминалу &mdasy; но <em>не</em> к другой программе &mdash; использует стратегию построчной буферизации, при которой Perl будет сбрасывать <code>STDOUT</code> каждый раз, как встретит в выводе перевод строки.</p>

<p> </p>

<p>Вместо глобальной переменной, используйте на лексическом дескрипторе файла метод <code>autoflush()</code>:</p>

<pre><code>    open my $fh, &#39;&gt;&#39;, &#39;pecan.log&#39;;
    $fh-&gt;autoflush( 1 );

    ...</code></pre>

<p> </p>

<p>Начиная с Perl 5.14, вы можете использовать на дескрипторе файла любые методы, предоставляемые <code>IO::File</code>. Вам не требуется явно загружать <code>IO::File</code>. В Perl 5.12 вы должны сами загрузить <code>IO::File</code>. В Perl 5.10 и раньше вы должны вместо этого загрузить <code>FileHandle</code>.</p>

<p>   </p>

<p>Методы <code>IO::File</code> <code>input_line_number()</code> и <code>input_record_separator()</code> обеспечивают пофайловый доступ к тому, для чего обычно вам пришлось бы использовать глобальные <code>$.</code> и <code>$/</code>. Смотрите документацию по <code>IO::File</code>, <code>IO::Handle</code> и <code>IO::Seekable</code> для большей информации.</p>

<h3>Директории и пути</h3>

<p></p>

<p>Работа с директориями похожа на работу с файлами, за исключением того, что вы не можете <em>писать</em> в директории (footnote: Вместо этого вы сохраняете, перемещаете, переименовываете и удаляете файлы.). Открыть дескриптор директории можно с помощью встроенной функции <code>opendir</code>:</p>

<pre><code>    opendir my $dirh, &#39;/home/monkeytamer/tasks/&#39;;</code></pre>

<p></p>

<p>Встроенная функция <code>readdir</code> читает из директории. Как и с <code>readline</code>, вы можете выполнить итерацию по содержимому директории по одному элементу за раз, или вы можете присвоить их списку сразу:</p>

<pre><code>    # &#x438;&#x442;&#x435;&#x440;&#x430;&#x446;&#x438;&#x44F;
    while (my $file = readdir $dirh)
    {
        ...
    }

    # &#x440;&#x430;&#x437;&#x433;&#x43B;&#x430;&#x436;&#x438;&#x432;&#x430;&#x43D;&#x438;&#x435; &#x432; &#x441;&#x43F;&#x438;&#x441;&#x43E;&#x43A;
    my @files = readdir $otherdirh;</code></pre>

<p>Perl 5.12 добавил возможность, благодаря которой <code>readdir</code> в <code>while</code> устанавливает <code>$_</code>:</p>

<pre><code>    use 5.012;

    opendir my $dirh, &#39;tasks/circus/&#39;;

    while (readdir $dirh)
    {
        next if /^\./;
        say &quot;Found a task $_!&quot;;
    }</code></pre>

<p> </p>

<p>Любопытное регулярное выражение в этом примере пропускает так называемые <em>скрытые файлы</em> в Unix и Unix-подобных системах, где ведущая точка предотвращает появление их в листинге директории по умолчанию. Оно также пропускает два специальных файла <code>.</code> и <code>..</code>, которые представляют текущую директорию и родительскую директорию соответственно.</p>

<p> </p>

<p>Имена, возвращаемые из <code>readdir</code>, <em>относительны</em> к самой директории. Другими словами, если директория <em>tasks/</em> содержит три файла, <em>eat</em>, <em>drink</em> и <em>be_monkey</em>, <code>readdir</code> вернёт <code>eat</code>, <code>drink</code> и <code>be_monkey</code>, а <em>не</em> <em>tasks/eat</em>, <em>tasks/drink</em> и <em>task/be_monkey</em>. Напротив, <em>абсолютный</em> путь &mdash; это путь, полностью определённый в файловой системе.</p>

<p></p>

<p>Закройте дескриптор директории, позволив ему выйти за пределы области видимости, или с помощью встроенной функции <code>closedir</code>.</p>

<h4>Манипулирование путями</h4>

<p>Perl 5 предлагает взгляд в стиле Unix на вашу файловую систему и будет интерпретировать пути в стиле Unix соответствующим образом для вашей операционной системы и файловой системы. Другими словами, если вы используете Microsoft Windows, вы можете использовать путь <em>C:/My Documents/Robots/Bender/</em> так же легко, как <em>C:\My Documents\Robots\Caprica Six\</em>.</p>

<p></p>

<p>Хотя операциями Perl и управляет семантика файлов Unix, кросс-платформенные манипуляции файлами намного легче осуществлять с помощью модуля. Семейство базовых модулей <code>File::Spec</code> предоставляет абстракции, позволяющие вам манипулировать путями к файлам безопасным и переносимым образом. Эти модули уважаемы и легко понимаемы, хотя и громоздки.</p>

<p>  </p>

<p>Дистрибутив <code>Path::Class</code> из CPAN предоставляет более приятный интерфейс. Используйте фукнцию <code>dir()</code> для создания объекта, представляющего директорию, и функцию <code>file()</code> для создания объекта, представляющего файл:</p>

<pre><code>    use Path::Class;

    my $meals = dir( &#39;tasks&#39;, &#39;cooking&#39; );
    my $file  = file( &#39;tasks&#39;, &#39;health&#39;, &#39;robots.txt&#39; );</code></pre>

<p>Вы можете получить объекты файлов из директорий и т. д.:</p>

<pre><code>    my $lunch      = $meals-&gt;file( &#39;veggie_calzone&#39; );
    my $robots_dir = $robot_list-&gt;dir();</code></pre>

<p>Вы даже можете отрыть дескрипторы файлов для директорий и файлов:</p>

<pre><code>    my $dir_fh    = $dir-&gt;open();
    my $robots_fh = $robot_list-&gt;open( &#39;r&#39; )
                        or die &quot;Open failed: $!&quot;;</code></pre>

<p>И <code>Path::Class::Dir</code>, и <code>Path::Class::File</code> предлагают и другие полезные поведения &mdash; хотя имейте ввиду, что если вы используете какой-нибудь объект <code>Path::Class</code> с другим кодом на Perl 5, таким как оператор или функция, ожидающая строку, содержащую путь к файлу, вам придётся самостоятельно преобразовать объект в строку. Это постоянное, но небольшое раздражение.</p>

<pre><code>    my $contents = read_from_filename( <strong>&quot;</strong>$lunch<strong>&quot;</strong> );</code></pre>

<h3>Манипуляции с файлами</h3>

<p> </p>

<p>Помимо чтения и записи файлов, вы также можете манипулировать ими, как делали бы это напрямую из командной строки или файлового менеджера. Операторы проверки файлов, все вместе называемые операторы <code>-X</code>, из-за того, что все они представляют собой дефис и одну букву, проверяют атрибуты файла и директории. Например, так можно проверить, что файл существует:</p>

<p> </p>

<pre><code>    say &#39;Present!&#39; if -e $filename;</code></pre>

<p>Оператор <code>-e</code> имеет один операнд, имя файла или дескриптор файла или директории. Если файл существует, выражение вернёт истинное значение. <code>perldoc -f -X</code> содержит список всех остальных проверок файлов; наиболее популярны следующие:</p>

<p>       </p>

<ul>

<li><code>-f</code>, возвращающий истинное значение, если его операнд &mdash; простой файл;

<li><code>-d</code>, возвращающий истинное значение, если его операнд &mdash; директория;

<li><code>-r</code>, возвращающий истинное значение, если настройка доступа к файлу, указанному как его операнд, позволяет чтение текущим пользователем;

<li><code>-s</code>, возвращающий истинное значение, если его операнд &mdash; непустой файл.

</ul>

<p>Начиная с Perl 5.10.1, вы можете искать документацию по любому из этих операторов, например, как <code>perldoc -f -r</code>.</p>

<p></p>

<p>Встроенная функция <code>rename</code> может переименовать файл или переместить его между директориями. Они принимает два операнда, старое и новое имя файла:</p>

<pre><code>    rename &#39;death_star.txt&#39;, &#39;carbon_sink.txt&#39;;

    # &#x438;&#x43B;&#x438; &#x435;&#x441;&#x43B;&#x438; &#x432;&#x44B; &#x441;&#x442;&#x438;&#x43B;&#x44C;&#x43D;&#x44B;&#x439;:
    rename &#39;death_star.txt&#39; =&gt; &#39;carbon_sink.txt&#39;;</code></pre>

<p>      </p>

<p>Встроенной функции для копирования файла нет, но базовый модуль <code>File::Copy</code> предоставляет как фукнцию <code>copy()</code>, так и <code>move()</code>. Используйте встроенную функцию <code>unlink</code> для удаления одного или нескольких файлов. (Встроенная функция <code>delete</code> удаляет элемент из хеша, а не файл из файловой системы.) Все эти функции возвращают истинные значения в случае успеха и устанавливают <code>$!</code> при ошибке.</p>

<p><code>Path::Class</code> предоставляет удобные методы для проверки некоторых атрибутов файла, а также для полного удаления файла, в кросс-платформенной манере.</p>

<p>  </p>

<p>Perl отслеживает свою текущую рабочую директорию. По умолчанию, это активная директория, из которой запущена программа. Функция <code>cwd()</code> базового модуля <code>Cwd</code> возвращает имя текущей рабочей директории. Встроенная функция <code>chdir</code> пытается сменить текущую рабочую директорию. Работа из корректной директории важна для работы с файлами с относительными путями.</p>

<h2>Модули</h2>

<p><a name="modules"></p>

<p></p>

<p>Многие считают CPAN (<a href="chapter_02.html#cpan">CPAN</a>) самой мощной возможностью Perl 5. CPAN, по сути, представляет собой систему для поиска и установки модулей. <em>Модуль</em> &mdash; это пакет, содержащийся в своём собственном файле, который можно загружать с помощью <code>use</code> или <code>require</code>. Модуль должен быть валидным кодом на Perl 5. Он должен завершаться выражением, возвращающим истинное значение, чтобы парсер Perl 5 мог понять, что он успешно загрузил и скомпилировал модуль. Других требований нет, только твёрдые соглашения.</p>

<p></p>

<p>Когда вы загружаете модуль, Perl разбивает имя пакета по двойным двоеточиям (<code>::</code>) и превращает компоненты имени пакета в имя файла. На практике, <code>use StrangeMonkey;</code> заставляет Perl искать файл с именем <em>StrangeMonkey.pm</em> во всех директориях, входящих в <code>@INC</code>, по порядку, пока он его не найдёт или не израсходует список.</p>

<p>Аналогично, <code>use StrangeMonkey::Persistence;</code> заставляет Perl искать файл с именем <em>Persistence.pm</em> в каждой директории с именем <em>StrangeMonkey/</em>, находящейся в любой из директорий, входящих в <code>@INC</code>, и т. д. <code>use StrangeMonkey::UI::Mobile;</code> заставляет Perl искать относительный файловый путь <em>StrangeMonkey/UI/Mobile.pm</em> в каждой директории в <code>@INC</code>.</p>

<p>Результирующий файл может содержать или не содержать объявление пакета, совпадающее с именем файла &mdash; такого технического <em>требования</em> нет &mdash; но вопросы поддержки рекомендуют это соглашение.</p>

<p>  </p>

<p><code>perldoc -l Module::Name</code> выведет полный путь к соответствующему файлу <em>.pm</em>, в случае, если <em>документация</em> к этому модулю существует в файле <em>.pm</em>. <code>perldoc -lm Module::Name</code> выведет полный путь к файлу <em>.pm</em>, независимо от существования параллельного файла <em>.pod</em>. <code>perldoc -m Module::Name</code> отобразит содержимое файла <em>.pm</em>.</p>

<h3>Использование и импортирование</h3>

<p><a name="import"></p>

<p>    </p>

<p>Когда вы загружаете модуль с помощью <code>use</code>, Perl загружает его с диска, а затем вызывает его метод <code>import()</code>, передавая все указанные вами аргументы. По соглашению метод <code>import()</code> модуля принимает список имён и экспортирует функции и другие символы в вызывающее пространство имён. Это всего лишь соглашение; модуль может отказаться предоставлять <code>import()</code>, или его <code>import()</code> может выполнять другие действия. Прагмы (<a href="chapter_08.html#pragmas">Прагмы</a>), такие как <code>strict</code>, используют аргументы для изменения поведения вызывающей лексической области видимости вместо экспорта символов:</p>

<pre><code>    use strict;
    # &hellip;&#x432;&#x44B;&#x437;&#x44B;&#x432;&#x430;&#x435;&#x442; strict-&gt;import()

    use CGI &#39;:standard&#39;;
    # &hellip;&#x432;&#x44B;&#x437;&#x44B;&#x432;&#x430;&#x435;&#x442; CGI-&gt;import( &#39;:standard&#39; )

    use feature qw( say switch );
    # &hellip;&#x432;&#x44B;&#x437;&#x44B;&#x432;&#x430;&#x435;&#x442; feature-&gt;import( qw( say switch ) )</code></pre>

<p> </p>

<p>Встроенная директива <code>no</code> вызывает метод <code>unimport()</code> модуля, если он существует, передавая любые аргументы. Это наиболее распространено с прагмами, использование которых модифицирует поведение через <code>import()</code>:</p>

<pre><code>    use strict;
    # &#x437;&#x430;&#x43F;&#x440;&#x435;&#x449;&#x435;&#x43D;&#x44B; &#x441;&#x438;&#x43C;&#x432;&#x43E;&#x43B;&#x44C;&#x43D;&#x44B;&#x435; &#x441;&#x441;&#x44B;&#x43B;&#x43A;&#x438; &#x438;&#x43B;&#x438; &#x433;&#x43E;&#x43B;&#x44B;&#x435; &#x441;&#x43B;&#x43E;&#x432;&#x430;
    # &#x442;&#x440;&#x435;&#x431;&#x443;&#x435;&#x442;&#x441;&#x44F; &#x43E;&#x431;&#x44A;&#x44F;&#x432;&#x43B;&#x435;&#x43D;&#x438;&#x435; &#x43F;&#x435;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x44B;&#x445;

    {
        no strict &#39;refs&#39;;
        # &#x441;&#x438;&#x43C;&#x432;&#x43E;&#x43B;&#x44C;&#x43D;&#x44B;&#x435; &#x441;&#x441;&#x44B;&#x43B;&#x43A;&#x438; &#x440;&#x430;&#x437;&#x440;&#x435;&#x448;&#x435;&#x43D;&#x44B;
        # &#x43E;&#x433;&#x440;&#x430;&#x43D;&#x438;&#x447;&#x435;&#x43D;&#x438;&#x44F; &#39;subs&#39; &#x438; &#39;vars&#39; &#x432;&#x441;&#x451; &#x435;&#x449;&#x451; &#x430;&#x43A;&#x442;&#x438;&#x432;&#x43D;&#x44B;
    }</code></pre>

<p>И <code>use</code>, и <code>no</code> действуют во время компиляции, так что:</p>

<pre><code>    use Module::Name qw( list of arguments );</code></pre>

<p>&hellip;это то же самое, что:</p>

<pre><code>    BEGIN
    {
        require &#39;Module/Name.pm&#39;;
        Module::Name-&gt;import( qw( list of arguments ) );
    }</code></pre>

<p>Аналогично:</p>

<pre><code>    no Module::Name qw( list of arguments );</code></pre>

<p>&hellip;это то же самое, что:</p>

<pre><code>    BEGIN
    {
        require &#39;Module/Name.pm&#39;;
        Module::Name-&gt;unimport(qw( list of arguments ));
    }</code></pre>

<p>&hellip;включая <code>require</code> модуля.</p>

<p>Если <code>import()</code> или <code>unimport()</code> не существует в модуле, Perl не будет выдавать сообщение об ошибке. Они совершенно опциональны.</p>

<p>Вы <em>можете</em> вызвать <code>import()</code> и <code>unimport()</code> напрямую, хотя за пределами блока <code>BEGIN</code> делать это мало смысла; после завершения компиляции действие <code>import()</code> или <code>unimport()</code> может не иметь особого эффекта.</p>

<p> </p>

<p>В Perl 5 <code>use</code> и <code>require</code> регистрозависимы, хотя, в то время как Perl понимает разницу между <code>strict</code> и <code>Strict</code>, ваше сочетание операционной системы и файловой системы может не знать. Если бы вы написали <code>use Strict;</code>, Perl не нашёл бы <em>strict.pm</em> в регистрозависимых файловых системах. В регистронезависимых файловых системах Perl охотно загрузит <em>Strict.pm</em>, но когда он попытается вызвать <code>Strict->import()</code>, ничего не случится. (<em>strict.pm</em> объявляет пакет с именем <code>strict</code>.)</p>

<p>Переносимые программы придерживаются строгих правил относительно этого случая, даже если и не обязаны.</p>

<h3>Экспортирование</h3>

<p><a name="exporting"> </p>

<p>Модуль может сделать определённые глобальные символы доступными другим пакетам посредством процесса, известного как <em>экспорт</em> &mdash; процесс, инициируемый вызовом <code>import()</code>, явным или неявным.</p>

<p>  </p>

<p>Базовый модуль <code>Exporter</code> предоставляет стандартный механизм экспорта символов из модуля. <code>Exporter</code> полагается на присутствие глобальных переменных пакета &mdash; в частности, <code>@EXPORT_OK</code> и <code>@EXPORT</code> &mdash; которые содержат список символов, экспортируемых по запросу.</p>

<p>Рассмотрим модуль <code>StrangeMonkey::Utilities</code>, предоставляющий несколько автономных функций, применимых по всей системе:</p>

<pre><code>    package StrangeMonkey::Utilities;

    use Exporter &#39;import&#39;;

    our @EXPORT_OK = qw( round translate screech );

    ...</code></pre>

<p>Любой другой код теперь может использовать этот модуль и, опционально, импортировать любую или все три экспортируемые функции. Также вы можете экспортировать переменные:</p>

<pre><code>    push @EXPORT_OK, qw( $spider $saki $squirrel );</code></pre>

<p>Экспортируйте символы по умолчанию, перечислив их в <code>@EXPORT</code> вместо <code>@EXPORT_OK</code>:</p>

<pre><code>    our @EXPORT = qw( monkey_dance monkey_sleep );</code></pre>

<p>&hellip;так что любая конструкция <code>use StrangeMonkey::Utilities;</code> будет импортировать обе функции. Имейте ввиду, что указание символов для импорта <em>не</em> импортирует символы по умолчанию, вы получите только то, что запросили. Чтобы загрузить модуль, не импортируя никаких символов, явно укажите пустой список:</p>

<pre><code>    # &#x441;&#x434;&#x435;&#x43B;&#x430;&#x442;&#x44C; &#x43C;&#x43E;&#x434;&#x443;&#x43B;&#x44C; &#x434;&#x43E;&#x441;&#x442;&#x443;&#x43F;&#x43D;&#x44B;&#x43C;, &#x43D;&#x43E; &#x43D;&#x438;&#x447;&#x435;&#x433;&#x43E; &#x43D;&#x435; &#x438;&#x43C;&#x43F;&#x43E;&#x440;&#x442;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x442;&#x44C;
    use StrangeMonkey::Utilities ();</code></pre>

<p>Независимо от любых списков импорта, вы всегда можете вызвать функции из другого пакета с помощью их полностью определённых имён:</p>

<pre><code>    StrangeMonkey::Utilities::screech();</code></pre>

<p></p>

<p>CPAN-модуль <code>Sub::Exporter</code> предоставляет более приятный интерфейс для экспорта функций без использования глобальных переменных пакета. Он также предлагает более широкие настройки. Однако, <code>Exporter</code> может экспортировать переменные, тогда как <code>Sub::Exporter</code> экспортирует только функции.</p>

<h3>Организация кода с помощью модулей</h3>

<p>Perl 5 не заставляет вас использовать ни модули, ни пакеты, ни пространства имён. Вы можете разместить весь свой код в единственном файле <em>.pl</em>, или в нескольких файлах <em>.pl</em>, подключаемых с помощью <code>require</code> по необходимости. Вам предоставлена гибкость в управлении вашим кодом наиболее соответствующим способом, в зависимости от вашего стиля разработки, формальностей, рисков и вознаграждений проекта, вашего опыта и вашего комфорта в развёртывании Perl 5.</p>

<p>Несмотря на это, проект с более чем несколькими сотнями строк кода получает множество преимуществ от модульной организации:</p>

<ul>

<li>Модули помогают обеспечить логическое разделение между отдельными сущностями в системе.</li>

<li>Модули предоставляют границы API, процедурного или ОО.</li>

<li>Модули предлагают естественную организацию исходного кода.</li>

<li>Экосистема Perl 5 имеет множество инструментов, предназначенных для создания, поддержки, организации и развёртывания модулей и дистрибутивов.</li>

<li>Модули предоставляют механизм повторного использования кода.</li>

</ul>

<p>Даже если вы не используете объектно-ориентированный подход, моделирование каждой отдельной сущности или ответственности в вашей системе в виде её собственного модуля сохраняет связанный код вместе и независимый код раздельно.</p>

<h2>Дистрибутивы</h2>

<p><a name="distributions"></p>

<p></p>

<p>Самый простой способ управлять конфигурацией, сборкой, упаковкой, тестированием и установкой программного обеспечения &mdash; следовать соглашениям CPAN-дистрибутивов. <em>Дистрибутив</em> &mdash; это набор метаданных и одного или нескольких модулей (<a href="chapter_09.html#modules">Модули</a>), формирующих одну пригодную для распространения, тестирования и установки единицу.</p>

<p>Все эти руководства &mdash; как упаковать дистрибутив, как разрешать его зависимости, куда устанавливать программное обеспечение, как проверять, что оно работает, как отображать документацию, как управлять репозиторием &mdash; родились из примерного консенсуса тысяч контрибуторов, работающих над десятками тысяч проектов. Дистрибутив, построенный по стандартам CPAN, может быть протестирован на нескольких версиях Perl 5 на нескольких разных аппаратных платформах в течение нескольких часов после загрузки, при этом об ошибках будет автоматически сообщено авторам &mdash; и всё это без вмешательства человека.</p>

<p>Вы можете никогда не выпускать свой код как публичные CPAN-дистрибутивы, но вы можете использовать инструменты и соглашения CPAN даже для управления частным кодом. Сообщество Perl построило восхитительную инфраструктуру; почему бы ей не воспользоваться?</p>

<h3>Характеристики дистрибутива</h3>

<p>Помимо одного или нескольких модулей, дистрибутив включает несколько других файлов и директорий:</p>

<ul>

<li><em>Build.PL</em> или <em>Makefile.PL</em>, программа-драйвер, используемая для конфигурации, сборки, тестирования, компоновки и установки дистрибутива.</li>

<li><em>MANIFEST</em>, список всех файлов, входящих в дистрибутив. Это помогает инструментам удостовериться, что комплект полон.</li>

<li><em>META.yml</em> и/или <em>META.json</em>, файл, содержащий метаданные о дистрибутиве и его зависимостях.</li>

<li><em>README</em>, описание дистрибутива, его предназначения, его авторских прав и информации о лицензии.</li>

<li><em>lib/</em>, директория, в которой содержатся Perl-модули.</li>

<li><em>t/</em>, директория, в которой содержатся файлы тестов.</li>

<li><em>Changes</em>, лог каждого изменения дистрибутива.</li>

</ul>

<p></p>

<p>Правильно построенный дистрибутив должен содержать уникальное имя и единый номер версии (который часто берётся из его основного модуля). Любой дистрибутив, который вы скачаете из публичной CPAN, должен соответствовать этим стандартам. Публичный сервис CPANTS (http://cpants.perl.org/) проверяет каждый загруженный модуль по руководствам и соглашениям сборки и рекомендует улучшения. Следование руководствам CPANTS не означает, что код работает, но означает, что инструменты сборки CPAN должны понять дистрибутив.</p>

<h3>Инструменты CPAN для управления дистрибутивами</h3>

<p>Ядро Perl 5 включает несколько инструментов для установки, разработки и управления вашими собственными дистрибутивами:</p>

<p> </p>

<ul>

<li><code>CPAN.pm</code> &mdash; официальный CPAN-клиент; <code>CPANPLUS</code> &mdash; альтернатива. Они в основном аналогичны. Хотя по умолчанию эти клиенты устанавливают дистрибутивы из публичной CPAN, вы можете вместо или дополнительно к этому направить их на свой собственный репозиторий.</li>

<p></p>

<li><code>Module::Build</code> &mdash; это написанный на чистом Perl набор инструментов для конфигурирования, сборки, установки и тестирования дистрибутивов. Он работает с файлами <em>Build.PL</em>.</li>

<p></p>

<li><code>ExtUtils::MakeMaker</code> &mdash; это унаследованный инструмент, на замену которому предназначен <code>Module::Build</code>. Он всё ещё широко используется, хотя находится в режиме поддержки и получает только критические исправления ошибок. Он работает с файлами <em>Makefile.PL</em>.</li>

<p></p>

<li><code>Test::More</code> (<a href="chapter_09.html#testing">Тестирование</a>) &mdash; базовый и самый широко используемый модуль тестирования, предназначенный для написания автоматизированных тестов для программного обеспечения на Perl.</li>

<p> </p>

<li><code>Test::Harness</code> и <code>prove</code> (<a href="chapter_09.html#running_tests">Запуск тестов</a>) запускают тесты и интерпретируют и генерируют отчёты по их результатам.</li>

</ul>

<p>В дополнение к этому, несколько дополнительных CPAN-модулей сделают легче вашу жизнь как разработчика:</p>

<p>  </p>

<ul>

<li><code>App::cpanminus</code> &mdash; это не требующий конфигурации CPAN-клиент. Он обрабатывает наиболее распространённые случаи, использует мало памяти и быстро работает.</li>

<p> </p>

<li><code>App::perlbrew</code> помогает вам управлять несколькими инсталляциями Perl 5. Установите новые версии Perl 5 для тестирования или производственной среды, или чтобы изолировать приложения и их зависимости.</li>

<p> </p>

<li><code>CPAN::Mini</code> и комманда <code>cpanmini</code> позволяют вам создать своё собственное (частное) зеркало публичной CPAN. Вы можете ввести в этот репозиторий свои собственные дистрибутивы и управлять тем, какие версии публичных модулей доступны в вашей организации.</li>

<p>  </p>

<li><code>Dist::Zilla</code> автоматизирует наиболее распространённые задачи распространения дистрибутивов. Хотя он использует либо <code>Module::Build</code>, либо <code>ExtUtils::MakeMaker</code>, он может заменить <em>ваше</em> использование их напрямую. Смотрите интерактивное руководство по адресу http://dzil.org/.</li>

<p></p>

<li><code>Test::Reporter</code> позволяет вам выводить отчёты по результатам запуска набора автоматизированных тестов дистрибутивов, которые вы устанавливаете, давая их авторам больше данных о сбоях.</li>

</ul>

<h3>Проектирование дистрибутивов</h3>

<p></p>

<p>Описание процесса проектирования дистрибутива может занять целую книгу (см. <em>Writing Perl Modules for CPAN</em> Сэма Трегара (Sam Tregar)), но несколько принципов дизайна помогут вам. Начните с такой утилиты как <code>Module::Starter</code> или <code>Dist::Zilla</code>. Начальная стоимость изучения конфигурации и правил может выглядеть как чрезмерная инвестиция, но преимущества того, что всё будет правильно настроено (и в случае <code>Dist::Zilla</code> <em>никогда</em> не устареет) освобождает вас от намного более утомительной бухгалтерии.</p>

<p>Затем рассмотрите несколько правил:</p>

<ul>

<li><em>Каждый дистрибутив должен иметь единственное, чётко определённое предназначение.</em> Этим предназначением может быть даже сборка нескольких связанных дистрибутивов в один устанавливаемый комплект. Декомпозиция вашего программного обеспечения на отдельные дистрибутивы позволяет вам соответственно управлять их зависимостями и соблюдать их инкапсуляцию.</li>

<li><em>Каждый дистрибутив должен иметь единственный номер версии.</em> Номера версий всегда должны увеличиваться. Политика семантических версий (http://semver.org/) разумна и совместима с подходом Perl 5.</li>

<li><em>Каждый дистрибутив требует хорошо определённого API.</em> Всесторонний автоматизированный набор тестов может проверить, что вы поддерживаете этот API между версиями. Если вы используете локальное зеркало CPAN для установки своих собственных дистрибутивов, вы можете использовать инфраструктуру CPAN для тестирования дистрибутивов и их зависимостей. Вы получите лёгкий доступ к интеграционному тестированию пригодных к повторному использованию компонентов.</li>

<li><em>Автоматизируйте тесты вашего дистрибутива и сделайте их повторяемыми и ценными.</em> Инфраструктура CPAN поддерживает отчёты автоматизированного тестирования. Используйте это!</li>

<li><em>Предоставьте эффективный и простой интерфейс.</em> Избегайте использования глобальных символов и экспорта по умолчанию; позвольте людям использовать только то, что им нужно. Не загрязняйте их пространства имён.</li>

</ul>

<h2>Пакет UNIVERSAL</h2>

<p><a name="universal"></p>

<p></p>

<p>Встроенный пакет <code>UNIVERSAL</code> в Perl 5 &mdash; предок всех остальных пакетов &mdash; в объектно-ориентированном смысле (<a href="chapter_07.html#moose">Moose</a>). <code>UNIVERSAL</code> предоставляет несколько методов, которые его потомки могут унаследовать или переопределить.</p>

<h3>Метод isa()</h3>

<p> </p>

<p>Метод <code>isa()</code> принимает строку, содержащую имя класса или имя встроенного типа. Вызывайте его как метод класса или метод экземпляра на объекте. Он возвращает истинное значение, если его инвокант является указанным классом или происходит от него, или если инвокант &mdash; благословлённая ссылка на заданный тип.</p>

<p>Пусть есть объект <code>$pepper</code> (ссылка на хеш, благословлённая в класс <code>Monkey</code>, наследующий от класса <code>Mammal</code>), тогда:</p>

<pre><code>    say $pepper-&gt;isa( &#39;Monkey&#39;  );  # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 1
    say $pepper-&gt;isa( &#39;Mammal&#39;  );  # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 1
    say $pepper-&gt;isa( &#39;HASH&#39;    );  # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 1
    say Monkey-&gt;isa(  &#39;Mammal&#39;  );  # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 1

    say $pepper-&gt;isa( &#39;Dolphin&#39; );  # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 0
    say $pepper-&gt;isa( &#39;ARRAY&#39;   );  # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 0
    say Monkey-&gt;isa(  &#39;HASH&#39;    );  # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 0</code></pre>

<p>     </p>

<p>Встроенные типы Perl 5 &mdash; <code>SCALAR</code>, <code>ARRAY</code>, <code>HASH</code>, <code>Regexp</code>, <code>IO</code> и <code>CODE</code>.</p>

<p> </p>

<p>Любой класс может переопределить <code>isa()</code>. Это может быть полезно при работе с объектами-моками (см. <code>Test::MockObject</code> и <code>Test::MockModule</code> в CPAN) или с кодом, не использующим ролей (<a href="chapter_07.html#roles">Роли</a>). Имейте ввиду, что любой класс, <em>переопределяющий</em> <code>isa()</code>, обычно имеет для этого хорошую причину.</p>

<h3>Метод can()</h3>

<p> </p>

<p>Метод <code>can()</code> принимает строку, содержащую имя метода. Он возвращает ссылку на функцию, имплементирующую этот метод, если она существует. В противном случае он возвращает ложное значение. Вы можете вызвать его на классе, объекте или имени пакета. В последнем случае он возвращает ссылку на функцию, а не метод (footnote: &hellip;не то чтобы вы могли определить разницу, имея только ссылку.).</p>

<p>Хотя и <code>UNIVERSAL::isa()</code>, и <code>UNIVERSAL::can()</code> &mdash; методы (<a href="chapter_11.html#method_sub_equivalence">Эквивалентность методов и функций</a>), вы можете <em>безопасно</em> использовать последний как функцию единственно для определения, существует ли класс в Perl 5. Если <code>UNIVERSAL::can( $classname, 'can' )</code> возвращает истинное значение, кто-то где-то определил класс с именем <code>$classname</code>. Этот класс может быть непригодным к использованию, но он существует.</p>

<p>Имея класс, названный <code>SpiderMonkey</code>, с методом, названным <code>screech</code>, получить ссылку на метод можно так:</p>

<pre><code>    if (my $meth = SpiderMonkey-&gt;can( &#39;screech&#39; )) {...}

    if (my $meth = $sm-&gt;can( &#39;screech&#39; )
    {
        $sm-&gt;$meth();
    }</code></pre>

<p> </p>

<p>Используйте <code>can()</code> чтобы проверить, что класс имплементирует конкретную функцию или метод:</p>

<pre><code>    use Class::Load;

    die &quot;Couldn&#39;t load $module!&quot;
        unless load_class( $module );

    if (my $register = $module-&gt;can( &#39;register&#39; ))
    {
        $register-&gt;();
    }</code></pre>

<p> </p>

<p>В то время как CPAN-модуль <code>Class::Load</code> упрощает работу по загрузке классов по имени &mdash; вместо танцев с <code>require</code> &mdash; <code>Module::Pluggable</code> выполняет большую часть работы по сборке и управлению системой плагинов. Ознакомьтесь с обоими дистрибутивами.</p>

<h3>Метод VERSION()</h3>

<p> </p>

<p>Метод <code>VERSION</code> возвращает значение переменной <code>$VERSION</code> соответствующего пакета или класса. Если вы укажете номер версии как необязательный параметр, метод выбросит исключение, если опрашиваемая <code>$VERSION</code> не равна или больше чем параметр.</p>

<p>Пусть есть модуль <code>HowlerMonkey</code> версии <code>1.23</code>, тогда:</p>

<pre><code>    say HowlerMonkey-&gt;VERSION();    # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 1.23
    say $hm-&gt;VERSION();             # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 1.23
    say $hm-&gt;VERSION( 0.0  );       # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 1.23
    say $hm-&gt;VERSION( 1.23 );       # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 1.23
    say $hm-&gt;VERSION( 2.0  );       # &#x438;&#x441;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x438;&#x435;!</code></pre>

<p>Нет особых причин переопределять <code>VERSION()</code>.</p>

<h3>Метод DOES()</h3>

<p> </p>

<p>Метод <code>DOES()</code> появился в Perl 5.10.0. Он существует для поддержки использования в программах ролей (<a href="chapter_07.html#roles">Роли</a>). Передайте ему инвокант и имя роли, и метод вернёт истинное значение, если соответствующий класс как-либо выполняет эту роль &mdash; будь то через наследование, делегирование, композицию, применение роли или любой другой механизм.</p>

<p>По умолчанию реализация <code>DOES</code> откатывается к <code>isa()</code>, потому что наследование &mdash; единственный механизм, с помощью которого класс может выполнять роль. Пусть есть <code>Cappuchin</code>:</p>

<pre><code>    say Cappuchin-&gt;DOES( &#39;Monkey&#39;       );  # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 1
    say $cappy-&gt;DOES(    &#39;Monkey&#39;       );  # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 1
    say Cappuchin-&gt;DOES( &#39;Invertebrate&#39; );  # &#x432;&#x44B;&#x432;&#x43E;&#x434;&#x438;&#x442; 0</code></pre>

<p>Переопределите <code>DOES()</code>, если вы вручную предоставляете роль или предоставляете другое алломорфичное поведение.</p>

<h3>Расширение UNIVERSAL</h3>

<p>Возникает соблазн сохранять в <code>UNIVERSAL</code> другие методы, чтобы сделать их доступными для всех других классов и объектов в Perl 5. Избегайте этого соблазна; это глобальное поведение можеть иметь неочевидные побочные эффекты, потому что оно не ограничено.</p>

<p>   </p>

<p>Учитывая сказанное, редкое злоупотребление <code>UNIVERSAL</code> для целей <em>отладки</em> и для исправления неправильного поведения по умолчанию можеть быть извинено. Например, дистрибутив <code>UNIVERSAL::ref</code> Джошуа бен Джоре (Joshua ben Jore) делает практически бесполезный оператор <code>ref()</code> полезным. Дистрибутивы <code>UNIVERSAL::can</code> и <code>UNIVERSAL::isa</code> могут помочь вам отладить анти-полиморфные баги (<a href="chapter_11.html#method_sub_equivalence">Эквивалентность методов и функций</a>). <code>Perl::Critic</code> может обнаружить эти и другие проблемы.</p>

<p>За пределами очень осторожно контролируемого кода и очень специфичных, очень прагматичных ситуаций, нет причин напрямую помещать код в <code>UNIVERSAL</code>. Почти всегд есть намного лучшие альтернативы дизайна.</p>

<h2>Кодогенерация</h2>

<p><a name="code_generation"></p>

<p>Новички в программировании пишут больше кода, чем нужно, частично из-за недостаточно близкого знакомства с языками, библиотеками и идиомами, но также и из-за отсутствия опыта. Они начинают с написания длинного процедурного кода, затем открывают для себя функции, затем параметры, затем объекты, и &mdash; возможно &mdash; функции высших порядков и замыкания.</p>

<p>По мере того, как вы становитесь лучше как программист, вы будете писать меньше кода для решения тех же самых задач. Вы будете использовать лучшие абстракции. Вы будете писать более универсальный код. Вы сможете повторно использовать код &mdash; и когда вы сможете добавлять возможности, удаляя код, вы достигнене чего-то замечательного.</p>

<p> </p>

<p>Написание программ, пишуших для вас программы &mdash; <em>метапрограммирование</em> или <em>кодогенерация</em> &mdash; предлагает большие возможности для абстракции. Хотя вы можете устроить огромный бардак, но вы можете и создать изумительные вещи. Например, техники метапрограммирования делают возможным Moose (<a href="chapter_07.html#moose">Moose</a>):</p>

<p>Техника использования <code>AUTOLOAD</code> (<a href="chapter_05.html#autoload">AUTOLOAD</a>) для отсутствующих функций и методов демонстрирует эту технику в ограниченной форме; система диспетчеризации функций и методов в Perl 5 позволяет вам настроить, что происходит, когда нормальный поиск проваливается.</p>

<h3>eval</h3>

<p> </p>

<p>Самая простая техника кодогенерации &mdash; это формирование строки, содержащей фрагмент валидного кода на Perl, и компиляция её с помощью строкового оператора <code>eval</code>. В отличие от отлавливающего исключения блочного оператора <code>eval</code>, строковый <code>eval</code> компилирует содержимое строки в текущей области видимости, включая текущий пакет и лексические привязки.</p>

<p>Наиболее общее использование этой техники &mdash; предоставление возможности отката, если вы не можете (или не хотите) загружать опциональную зависимость:</p>

<pre><code>    eval { require Monkey::Tracer }
        or eval &#39;sub Monkey::Tracer::log {}&#39;;</code></pre>

<p>Если <code>Monkey::Tracer</code> недоступен, его функция <code>log()</code> будет существовать, но ничего не будет делать. Однако этот простой пример обманчив. Правильное использование <code>eval</code> требует определённой работы; вы должны обработать проблемы заключения в кавычки для включения переменных в передаваемый в <code>eval</code> код. Добавьте сложности чтобы интерполировать одни переменные, но не другие:</p>

<pre><code>    sub generate_accessors
    {
        my ($methname, $attrname) = @_;

        eval &lt;&lt;&quot;END_ACCESSOR&quot;;
        sub get_$methname
        {
            my \$self = shift;
            return \$self-&gt;{$attrname};
        }

        sub set_$methname
        {
            my (\$self, \$value) = \@_;
            \$self-&gt;{$attrname}  = \$value;
        }
    END_ACCESSOR
    }</code></pre>

<p>Горе тем, кто забыл обратный слеш! Удачи в объяснении вашей подсветке синтаксиса, что происходит! Хуже того, каждый вызов строкового <code>eval</code> создаёт новую структуру данных, представляющую код целиком, и компиляция кода тоже не бесплатна. Но даже с этими ограничениями эта техника проста.</p>

<h3>Параметризованные замыкания</h3>

<p></p>

<p>Хотя построение аксессоров и мутаторов с помощью <code>eval</code> просто, замыкания (<a href="chapter_05.html#closures">Замыкания</a>) позволяют вам добавлять параметры в генерируемый код во время компиляции без необходимости дополнительного вычисления:</p>

<pre><code>    sub generate_accessors
    {
        my $attrname = shift;

        my $getter = sub
        {
            my $self = shift;
            return $self-&gt;{$attrname};
        };

        my $setter = sub
        {
            my ($self, $value) = @_;
            $self-&gt;{$attrname} = $value;
        };

        return $getter, $setter;
    }</code></pre>

<p>Этот код избегает неприятных проблем с заключением в кавычки и компилирует каждое замыкание только один раз. Он даже использует меньше памяти из-за разделения скомпилированного кода между всеми экземплярами замыканий. Всё, что различается &mdash; это привязка к лексической переменной <code>$attrname</code>. В долго выполняющихся процессах, или при большом количестве аксессоров, эта техника может быть очень полезна.</p>

<p> </p>

<p>Установка в таблицу символов относительно проста, хоть и некрасива:</p>

<pre><code>    {
        my ($get, $set) = generate_accessors( &#39;pie&#39; );

        no strict &#39;refs&#39;;
        *{ &#39;get_pie&#39; } = $get;
        *{ &#39;set_pie&#39; } = $set;
    }</code></pre>

<p>  </p>

<p>Странный синтаксис звёздочки (footnote: Воспринимайте её как <em>сигил тайпглоба</em>, где <em>тайпглоб</em> &mdash; Perl-жаргон для &laquo;таблицы символов&raquo;.) разыменовывает хеш, ссылающийся на символ в текущей <em>таблице символов</em>, являющейся частью текущего пространства имён, содержащего глобально-доступные символы, такие как глобальные данные пакета, функции и методы. Присваивание ссылки записи таблицы символов устанавливает или заменяет соответствующую запись. Чтобы повысить анонимную функцию до метода, сохраните ссылку на эту функцию в таблице символов.</p>

<p></p>

<p>CPAN-модуль <code>Package::Stash</code> предлагает более приятный интерфейс для подобного хакинга таблицы символов.</p>

<p> </p>

<p>Присваивание таблице символов символа, содержащего строку, не литеральное имя переменной, это символическая ссылка. Для этой операции вам нужно отключить строгую проверку ссылок <code>strict</code>. Многие программы имеют неочевидный баг в аналогичном коде, так как они присваивают и генерируют в одной строчке:</p>

<pre><code>    {
        no strict &#39;refs&#39;;

        *{ $methname } = sub {
            # &#x43D;&#x435;&#x43E;&#x447;&#x435;&#x432;&#x438;&#x434;&#x43D;&#x44B;&#x439; &#x431;&#x430;&#x433;: strict refs &#x43E;&#x442;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x43E; &#x437;&#x434;&#x435;&#x441;&#x44C; &#x442;&#x43E;&#x436;&#x435;
        };
    }</code></pre>

<p>Этот пример отключает ограничения для внешнего блока, так же как и для тела самой функции. Только присваивание нарушает строгую проверку ссылок, так что отключайте ограничения только для этой операции.</p>

<p>Если имя метода &mdash; строковый литерал в вашем исходном коде, а не содержимое переменной, вы можете присвоить соответсвующему символу напрямую:</p>

<pre><code>    {
        no warnings &#39;once&#39;;
        (*get_pie, *set_pie) =
             generate_accessors( &#39;pie&#39; );
    }</code></pre>

<p>Прямое присваивание глобу не нарушает ограничения, но упоминание глоба только раз <em>будет</em> генерировать предупреждение &laquo;used only once&raquo;, если вы явно не подавите его в области видимости.</p>

<h3>Манипуляции времени компиляции</h3>

<p></p>

<p>В отличие от кода, написанного явно как код, код, генерируемый с помощью строкового <code>eval</code>, компилируется во время выполнения. Там, где вы можете ожидать от нормальной функции, что она будет доступна всё время жизни программы, сгенерированная функция может не быть доступной, когда вы этого ожидаете.</p>

<p></p>

<p>Заставьте Perl выполнять код &mdash; генерирующий другой код &mdash; во время компиляции, обернув его в блок <code>BEGIN</code>. Когда парсер Perl 5 встречает блок <code>BEGIN</code>, он парсит весь блок. Если он не содержит синтаксических ошибок, блок будет выполнен немедленно. После его завершения парсинг продолжится, как если бы не было никаких прерываний.</p>

<p>Разница между записью:</p>

<pre><code>    sub get_age    { ... }
    sub set_age    { ... }

    sub get_name   { ... }
    sub set_name   { ... }

    sub get_weight { ... }
    sub set_weight { ... }</code></pre>

<p>&hellip;и:</p>

<pre><code>    sub make_accessors { ... }

    BEGIN
    {
        for my $accessor (qw( age name weight ))
        {
            my ($get, $set) =
                make_accessors( $accessor );

            no strict &#39;refs&#39;;
            *{ &#39;get_&#39; . $accessor } = $get;
            *{ &#39;set_&#39; . $accessor } = $set;
        }
    }</code></pre>

<p>&hellip;преимущественно в поддерживаемости.</p>

<p> </p>

<p>Внутри модуля, любой код за пределами функций выполняется, когда вы используете его посредством <code>use</code>, из-за неявного <code>BEGIN</code>, который Perl добавляет вокруг <code>require</code> и <code>import</code> (<a href="chapter_05.html#importing">Импорт</a>). Любой код за пределами функций, но внутри модуля, будет выполнен <em>перед</em> тем, как произойдёт вызов <code>import()</code>. Если вы загружаете модуль с помощью <em>require</em>, неявного блока <code>BEGIN</code> не будет. Выполнение кода за пределами функций произойдёт в <em>конце</em> парсинга.</p>

<p>Учитывайте взаимодействие между лексическими <em>объявлениями</em> (ассоциирование имени с областью видимости) и лексическими <em>присваиваниями</em>. Первые происходят во время компиляции, тогда как последние происходят в точке выполнения. Этот код имеет неочевидный баг:</p>

<p></p>

<pre><code>    # &#x434;&#x43E;&#x431;&#x430;&#x432;&#x43B;&#x44F;&#x435;&#x442; &#x43C;&#x435;&#x442;&#x43E;&#x434; require() &#x432; UNIVERSAL
    use UNIVERSAL::require;

    # &#x432;&#x435;&#x434;&#x451;&#x442; &#x43A; &#x43E;&#x448;&#x438;&#x431;&#x43A;&#x430;&#x43C;; &#x43D;&#x435; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x442;&#x44C;
    my $wanted_package = &#39;Monkey::Jetpack&#39;;

    BEGIN
    {
        $wanted_package-&gt;require();
        $wanted_package-&gt;import();
    }</code></pre>

<p>&hellip;потому что блок <code>BEGIN</code> будет выпволнен <em>перед</em> тем, как произойдёт присваивание строкового значения <code>$wanted_package</code>. Результатом будет исключение из-за попытки вызвать метод <code>require()</code> на неопределённом значении.</p>

<h3>Class::MOP</h3>

<p><a name="class_mop"></p>

<p>   </p>

<p>В отличие от установки ссылок на функции для заполнения пространств имён и создания методов, в Perl 5 нет простого способа программного создания классов. На помощь приходит Moose с входящей в него библиотекой <code>Class::MOP</code>. Она предоставляет <em>протокол метаобъектов</em> &mdash; механизм для создания и манипулирования объектной системой в терминах её самой.</p>

<p>Вместо написания своего собственного хрупкого кода со строковым <code>eval</code> или попыток вручную ковыряться в таблицах символов, вы можете манипулировать сущностями и абстракциями вашей программы с помощью объектов и методов:</p>

<p>Так создаётся класс:</p>

<pre><code>    use Class::MOP;

    my $class = Class::MOP::Class-&gt;create(
                    &#39;Monkey::Wrench&#39;
                );</code></pre>

<p> </p>

<p>Добавьте атрибуты и методы в этот класс, когда создадите его:</p>

<pre><code>    my $class = Class::MOP::Class-&gt;create(
        &#39;Monkey::Wrench&#39; =&gt;
        (
            attributes =&gt;
            [
                Class::MOP::Attribute-&gt;new(&#39;$material&#39;),
                Class::MOP::Attribute-&gt;new(&#39;$color&#39;),
            ]
            methods =&gt;
            {
                tighten =&gt; sub { ... },
                loosen  =&gt; sub { ... },
            }
        ),
    );</code></pre>

<p>&hellip;или в метакласс (объект, представляющий этот класс), когда он будет создан:</p>

<pre><code>    $class-&gt;add_attribute(
        experience  =&gt; Class::MOP::Attribute-&gt;new(&#39;$xp&#39;)
    );

    $class-&gt;add_method( bash_zombie =&gt; sub { ... } );</code></pre>

<p>&hellip;и вы можете инспектировать метакласс:</p>

<pre><code>    my @attrs = $class-&gt;get_all_attributes();
    my @meths = $class-&gt;get_all_methods();</code></pre>

<p> </p>

<p>Аналогично, <code>Class::MOP::Attribute</code> и <code>Class::MOP::Method</code> позволяют вам создавать, манипулировать и анализировать атрибуты и методы.</p>

<h2>Перегрузка</h2>

<p><a name="overloading"> </p>

<p>Perl 5 не является глубоко объектно-ориентированным языком. Его внутренние типы данных (скаляры, массивы и хеши) не являются объектами с перегружаемыми методами, но вы <em>можете</em> контролировать поведение своих собственных классов и объектов, особенно когда они подвергаются приведению типов или контекстному вычислению. Это <em>перегрузка</em>.</p>

<p>Перегрузка может быть неочевидной, но мощной. Интересный пример &mdash; перегрузка того, как объект ведёт себя в булевом контексте, особенно если вы используете что-нибудь вроде шаблона ноль-объекта (http://www.c2.com/cgi/wiki?NullObject). В булевом контексте объект будет восприниматься как истинное значение, если вы не перегрузите преобразование в булево значение.</p>

<p>Вы можете перегрузить поведение объекта почти для любой операции или приведения типа: преобразование в строку, преобразование в число, преобразование в булево значение, итерации, вызов, обращение как к массиву, обращение как к хешу, арифметические операции, операции сравнения, умное сопоставление, побитовые операции и даже присваивание. Преобразование в строку, в число и в булево значение наиболее важны и наиболее распространены.</p>

<h3>Перегрузка распространённых операций</h3>

<p>    </p>

<p>Прагма <code>overload</code> позволяет вам ассоциировать функцию с операцией, которую вы можете перегрузить, передав пары аргументов, где ключ обозначает тип перегрузки, а значение &mdash; ссылка на функцию, которая должна вызываться для этой операции. Класс <code>Null</code>, перегружающий булево вычисление так, что он всегда будет восприниматься как ложное значение, может выглядеть так:</p>

<pre><code>    package Null
    {
        use overload &#39;bool&#39; =&gt; sub { 0 };

        ...
    }</code></pre>

<p>Можно легко добавить преобразование в строку:</p>

<pre><code>    package Null
    {
        use overload
            &#39;bool&#39; =&gt; sub { 0 },
            <strong>&#39;&quot;&quot;&#39;   =&gt; sub { &#39;(null)&#39; };</strong>
    }</code></pre>

<p>Переопределение преобразования в число более сложно, потому что арифметические операторы имеют тенденцию быть бинарными (<a href="chapter_04.html#arity">Арность</a>). Если есть два оператора, оба с перегруженными методами для сложения, какой будет приоритетнее? Ответ должен быть последовательным, простым для объяснения и понятным людям, которые не читали исходный код реализации.</p>

<p><code>perldoc overload</code> пытается объяснить это в разделах <em>Calling Conventions for Binary Operations</em> и <em>MAGIC AUTOGENERATION</em>, но наиболее простое решение &mdash; перегрузить преобразование в число (имеющее ключ <code>'0+'</code>) и указать <code>overload</code> использовать предоставленные перегрузки как запасной вариант (fallback) где возможно:</p>

<pre><code>    package Null
    {
        use overload
            &#39;bool&#39;   =&gt; sub { 0 },
            &#39;&quot;&quot;&#39;     =&gt; sub { &#39;(null)&#39; },
            <strong>&#39;0+&#39;     =&gt; sub { 0 },</strong>
            <strong>fallback =&gt; 1;</strong>
    }</code></pre>

<p>Установка <code>fallback</code> в истинное значение позволяет Perl использовать любые другие определённые перегрузки для выполнения запрошенной операции, если возможно. Если это невозможно, Perl будет действовать так, как если бы не было никаких перегрузок. Это часто именно то, чего вы хотите.</p>

<p>Без <code>fallback</code> Perl будет использовать только конкретные перегрузки, которые вы предоставили. Если кто-нибудь попытается выполнить операцию, которую вы не перегрузили, Perl выбросит исключение.</p>

<h3>Перегрузка и наследование</h3>

<p></p>

<p>Подклассы наследуют перегрузки от своих предков. Они могут переопределить это поведение одним из двух способов. Если родительский класс использует перегрузку как показано, с напрямую предоставленными ссылками на функции, класс-потомок <em>должен</em> переопределить перегруженное поведение родителя с помощью прямого использования <code>overload</code>.</p>

<p>Родительские классы могут позволить своим потомкам большую гибкость, указывая <em>имя</em> метода для вызова в качестве реализации перегрузки, вместо хардкода ссылки на функцию:</p>

<pre><code>    package Null
    {
        use overload
            &#39;bool&#39;   =&gt; &#39;get_bool&#39;,
            &#39;&quot;&quot;&#39;     =&gt; &#39;get_string&#39;,
            &#39;0+&#39;     =&gt; &#39;get_num&#39;,
            fallback =&gt; 1;
    }</code></pre>

<p>В этом случае любые дочерние классы могут выполнять эти перегруженные операции иначе, переопределив методы с соответствующими именами.</p>

<h3>Использование перегрузки</h3>

<p></p>

<p>Перегрузка может выглядеть заманчивым инструментом для использования для генерации символьных сокращений для новых операций, но это редко происходит в Perl 5 по весомым причинам. CPAN-дистрибутив <code>IO::All</code> доводит эту идею до предела в производстве умных идей для краткого и компонуемого кода. Однако на каждый блестящий API, доведённый до совершенства путём соответствующего использования перегрузки, дюжина других устраивают бардак. Иногда лучший код избегает умности в пользу простоты.</p>

<p>Переопределение сложения, умножения и даже конкатенации в классе <code>Matrix</code> имеет смысл только из-за того, что распространена существующая нотация для этих операций. Новая предметная область, не имеющая такой установившейся нотации &mdash; плохой кандидат для перегрузки, как и предметная область, в которой вам приходится изощряться, чтобы поставить существующие операторы Perl в соответствие с другой нотацией.</p>

<p><em>Perl Best Practices</em> Демьена Конвея (Damian Conway) предлагают другое использование перегрузки: для предотвращения случайного неправильного использования объектов. Например, перегрузка преобразования в число таким образом, чтобы она делала <code>croak()</code>, для объектов, не имеющих разумного представления в виде одного числа, может помочь вам найти и исправить реальные ошибки.</p>

<h2>Испорченность</h2>

<p><a name="taint"></p>

<p>Perl предоставляет инструменты для написания безопасных программ. Эти инструменты &mdash; не замена для внимательного обдумывания и планирования, но они <em>вознаграждают</em> внимание и понимание и могут помочь вам избежать неочевидных ошибок.</p>

<h3>Использование режима испорченных данных</h3>

<p></p>

<p><em>Режим испорченных данных</em> (<em>taint mode</em>, или просто <em>taint</em>) добавляет метаданные ко всем данным, приходящим из-за пределов вашей программы. Любые данные, производные от испорченных данных, тоже испорчены. Вы можете использовать испорченные данные в своей программе, но если вы используете их для воздействия на окружающий мир &mdash; если вы используете их небезопасно &mdash; Perl выбросит фатальное исключение.</p>

<p><code>perldoc perlsec</code> объясняет режим испорченных данных во всех подробностях.</p>

<p>  </p>

<p>Для включения режима испорченных данных запустите свою программу с аргументом командной строки <code>-T</code>. Если вы используете этот аргумент в строчке <code>#!</code>, вы должны запустить программу напрямую; если вы запустите её как <code>perl mytaintedapppl.pl</code> и пренебрежёте флагом <code>-T</code>, Perl выйдет с исключением. К тому моменту, когда Perl встречает флаг в строке <code>#!</code>, уже упущена возможность пометить испорченными данные окружения, например, входящие в <code>%ENV</code>.</p>

<h3>Источники испорченных данных</h3>

<p>Испорченные данные могут приходить из двух мест: файловый ввод и операционное окружение программы. Первое &mdash; это всё, что вы читаете из файла или получаете от пользователей в случае веб- или сетевого программирования. Второе включает любые аргументы командной строки, переменные окружения и данные из системных вызовов. Даже такие операции, как чтение из дескриптора директории, генерируют испорченные данные.</p>

<p>  </p>

<p>Функция <code>tainted()</code> из базового модуля <code>Scalar::Util</code> возвращает истину, если её аргумент испорчен:</p>

<pre><code>    die &#39;Oh no! Tainted data!&#39;
        if Scalar::Util::tainted( $suspicious_value );</code></pre>

<h3>Удаление испорченности из данных</h3>

<p> </p>

<p>Чтобы удалить испорченность, вы должны выделить заведомо нормальные порции данных с помощью захвата в регулярном выражении. С захваченных данных будет снята испорченность. Если ваш пользовательский ввод содержит телефонный номер США, вы можете снять с него испорченность так:</p>

<pre><code>    die &#39;Number still tainted!&#39;
        unless $number =~ /(\(/d{3}\) \d{3}-\d{4})/;

    my $safe_number = $1;</code></pre>

<p>Чем более конкретен ваш шаблон относительно того, что вы позволяете, тем более безопасной может быть ваша программа. Противоположный подход <em>запрета</em> конкретных элементов или форм имеет риск недосмотра чего-либо вредоносного. Гораздо лучше не пропустить что-нибудь безопасное, но неожиданное, чем пропустить что-нибудь опасное, но выглядящее безопасным. Несмотря на это, ничто не запрещает вам написать захват для всего содержимого переменной &mdash; но в этом случае зачем использовать режим испорченных данных?</p>

<h3>Удаление испорченности из окружения</h3>

<p></p>

<p>Суперглобальная переменная <code>%ENV</code> представляет переменные окружения системы. Эти данные испорчены, потому что силы за пределами контроля программы могут манипулировать данными в них. Любая переменная окружения, влияющая на то, как Perl или оболочка находит файлы и директории &mdash; это направление атаки. Чувствительная к испорченным данным программа должна удалить несколько ключей из <code>%ENV</code> и установить в <code>$ENV{PATH}</code> конкретный и хорошо защищённый путь:</p>

<pre><code>    delete @ENV{ qw( IFS CDPATH ENV BASH_ENV ) };
    $ENV{PATH} = &#39;/path/to/app/binaries/&#39;;</code></pre>

<p>Если вы не установите <code>$ENV{PATH}</code> соответствующим образом, вы будете получать сообщения о его небезопасности. Если эта переменная окружения содержит текущую рабочую директорию, или если она содержит относительные директории, или если указанные директории имеют общий доступ на запись, умный атакующий может взломать системные вызовы для нанесения вреда.</p>

<p>По аналогичным причинам <code>@INC</code> в режиме испорченных данных не содержит текущую рабочую директорию. Perl также будет игнорировать переменные окружения <code>PERL5LIB</code> и <code>PERLLIB</code>. Используйте прагму <code>lib</code> или флаг <code>-I</code> для <code>perl</code>, чтобы добавить библиотечные каталоги в программу.</p>

<h3>Недостатки режима испорченных данных</h3>

<p>Режим испорченных данных &mdash; это всё или ничего. Он либо включен, либо выключен. Это иногда приводит людей к использованию разрешительных шаблонов для снятия испорченности с данных и даёт иллюзию безопасности. Внимательно проверяйте снятие испорченности.</p>

<p> </p>

<p>К сожалению, не все модули правильно обрабатывают испорченные данные. Это ошибка, которую CPAN-авторы должны принимать всерьёз. Если вам нужно сделать унаследованный код taint-безопасным, рассмотрите использование флага <code>-t</code>, который включает режим испорченных данных, но понижает его нарушения с исключений до предупреждений. Это не замена для полного режима, но это позволяет вам сделать существующие программы безопасными без подхода &laquo;всё или ничего&raquo; <code>-T</code>.</p>

</body></html>